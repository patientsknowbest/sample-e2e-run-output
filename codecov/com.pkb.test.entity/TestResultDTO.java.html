<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestResultDTO.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.test.entity</a> &gt; <span class="el_source">TestResultDTO.java</span></div><h1>TestResultDTO.java</h1><pre class="source lang-java linenums">package com.pkb.test.entity;

import com.google.common.base.MoreObjects;
import com.pkb.annotation.EHRField;
import com.pkb.annotation.EHRField.QueryField;
import com.pkb.annotation.EHRMigration;
import com.pkb.app.dto.DTOBaseFields;
import com.pkb.app.entity.SourceDetails;
import com.pkb.app.interfaces.EncryptedDataPoint;
import com.pkb.app.interfaces.IBaseDTO;
import com.pkb.coding.entity.CodeableConcept;
import com.pkb.coding.entity.Coding;
import com.pkb.encounter.entity.GeographicLocation;
import com.pkb.entities.enums.MenuDataType;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.pkb.annotation.EHRField.ValueDTOType.NESTED;

/**
 * &lt;placeholder name=&quot;loincTestResult&quot; title=&quot;LoincTestResult&quot;
 * eventInstance=&quot;pkb:loincTestResult:wip&quot; page=&quot;/wizard/wizard.xhtml&quot;
 * heading=&quot;/five/testLink.xhtml&quot;&gt;
 * &lt;field name=&quot;loincTestPrivateId&quot; internal=&quot;string01&quot;&gt;
 * &lt;from&gt;#{trim.field['loincTestPrivateId']}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;loincMappingPrivateId&quot; internal=&quot;string02&quot;&gt;
 * &lt;from&gt;#{trim.field['loincMappingPrivateId']}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;!-- 2 new additions... for storing the UNmapped values when we have no access to the private map (API upload). MAY NOT HAVE VALUES --&gt;
 * &lt;field name=&quot;loincTestId&quot;&gt;
 * &lt;from&gt;#{source.loincTestId}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;loincMappingId&quot;&gt;
 * &lt;from&gt;#{source.loincMappingId}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;testCodeFromSource&quot;&gt;&lt;/field&gt;
 * &lt;field name=&quot;testCodingSystemFromSource&quot;&gt;&lt;/field&gt;
 * &lt;field name=&quot;testDate&quot; internal=&quot;date01&quot;&gt;
 * &lt;/field&gt;
 * &lt;!-- PHR-9654 removed testDateIncludesTimestamp --&gt;
 * &lt;field name=&quot;testDateIncludesTimestamp&quot; internal=&quot;long01&quot;&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;value&quot;&gt;
 * &lt;from&gt;#{trim.act.observation.value.PQ.value}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;textValue&quot;&gt;
 * &lt;from&gt;#{trim.act.observation.value.PQ.originalText}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;comments&quot;&gt;
 * &lt;from&gt;#{trim.field['comments']}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;rangeLow&quot;&gt;
 * &lt;from&gt;#{trim.act.relationship['normalRange'].act.observation.value.IVLPQ.low.PQ.value}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;rangeHigh&quot;&gt;
 * &lt;from&gt;#{trim.act.relationship['normalRange'].act.observation.value.IVLPQ.high.PQ.value}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;rangeLowInclusive&quot;&gt;
 * &lt;from&gt;#{source.rangeLowInclusive}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;rangeHighInclusive&quot;&gt;
 * &lt;from&gt;#{source.rangeHighInclusive}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;sourceFileId&quot;&gt;
 * &lt;from&gt;#{trim.field['sourceFileId']}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;!-- Migrated from long02 to long04. Then later, PHR-8952 removed it in favour of DTOBaseFields.uploadedDataId. --&gt;
 * &lt;field name=&quot;uploadedDataId&quot; internal=&quot;long04&quot;&gt;
 * &lt;from&gt;#{trim.field['uploadedDataId']}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;labOrderId&quot; internal=&quot;string03&quot;&gt;
 * &lt;from&gt;#{trim.field['labOrderId']}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;!-- The closely-named dataEntererId was removed in PHR-9360. --&gt;
 * &lt;field name=&quot;dataEntererUid&quot;&gt;
 * &lt;!-- obsolete: new values go in sourcePersonId --&gt;
 * &lt;!-- user.ldapUID in patientAct.trim.xml --&gt;
 * &lt;from&gt;#{trim.act.participation['dataEnterer'].role.id.IIS[0].extension}&lt;/from&gt;
 * &lt;/field&gt;
 * &lt;!-- Deleted in PHR-8533 --&gt;
 * &lt;field name=&quot;replacesResultId&quot; internal=&quot;long03&quot;&gt;
 * &lt;/field&gt;
 * &lt;field name=&quot;replacementTimestamp&quot; internal=&quot;date02&quot;&gt;
 * &lt;/field&gt;
 * &lt;!-- Unclear if this was ever used. Removed in PHR-9355. --&gt;
 * &lt;field name=&quot;deletedByPersonId&quot;&gt;&lt;/field&gt;
 *
 * &lt;field name=&quot;sourcePersonId&quot; internal=&quot;sourcePersonId&quot;&gt;&lt;/field&gt;
 * &lt;field name=&quot;sourceTeamId&quot; internal=&quot;sourceTeamId&quot;&gt;&lt;/field&gt;
 * &lt;field name=&quot;sourceOrgId&quot; internal=&quot;sourceOrgId&quot;&gt;&lt;/field&gt;
 * &lt;field name=&quot;sourceText&quot;&gt;&lt;/field&gt;
 */
@EHRMigration(migratorClass = TestResultMigrator.class)
public class TestResultDTO implements IBaseDTO, EncryptedDataPoint, Serializable {

<span class="fc" id="L107">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    public static final String TEST_RESULT_CODING = &quot;coding&quot;;

<span class="fc" id="L111">    public enum ComparatorOperator {</span>

<span class="fc" id="L113">        GREATER_OR_EQUAL(&quot;&gt;=&quot;), LESS_OR_EQUAL(&quot;&lt;=&quot;), GREATER(&quot;&gt;&quot;), LESS(&quot;&lt;&quot;);</span>

        private String symbol;

<span class="fc" id="L117">        ComparatorOperator(String symbol) {</span>
<span class="fc" id="L118">            this.symbol = symbol;</span>
<span class="fc" id="L119">        }</span>

        public String getSymbol() {
<span class="nc" id="L122">            return symbol;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L127">            return symbol;</span>
        }

    }

    private static final long serialVersionUID = 8322647369112978997L;

<span class="fc" id="L134">    public static final MenuDataType MS_PATH = MenuDataType.loincTestResult;</span>

    public static final String LOINC_TEST_ID = &quot;loincTestId&quot;;
    public static final String LOINC_MAPPING_ID = &quot;loincMappingId&quot;;
    public static final String TEST_DATE = &quot;testDate&quot;;
    public static final String VALUE = &quot;value&quot;;
    public static final String TEXT_VALUE = &quot;textValue&quot;;
    public static final String COMMENTS = &quot;comments&quot;;
    public static final String UPLOADED_DATA_ID = &quot;uploadedDataId&quot;;
    public static final String LAB_ORDER_ID = &quot;labOrderId&quot;;
    public static final String DELETED = &quot;deleted&quot;;

    /**
     * The menudata id which uniquely identifies this version of this test result.
     * Other test results, and other versions of this test result, will have a different ID.
     */
    @EHRField(queryField = QueryField.id)
    private Long id;

    /**
     * Each test result is associated with a test type. The type of test will either be captured by an entry in
     * LoincTest or LoincMapping.
     *
     * If the test type is LoincTest, then this value will be populated with LoincTest.id.
     *
     * Note: the presence of this value does not exclude the possibility of loincMappingId also being populated.
     */
    @EHRField(queryField = QueryField.long01)
    private Long loincTestId;

    /**
     * Each test result is associated with a test type. The type of test will either be captured by an entry in
     * LoincTest or LoincMapping.
     *
     * If the test type is LoincMapping, then this value will be populated with LoincMapping.id.
     *
     * Note: the corresponding LoincMapping might in reality represent a LOINC code, and even if not there might be a
     * transitive reference to a LoincTest via LoincMapping.loincTest.
     */
    @EHRField(queryField = QueryField.long02)
    private Long loincMappingId;

    @EHRField(valueDtoType = NESTED)
    private CodeableConcept coding;

    /**
     * A coding typically consists of: a code, a coding system, and some display text.
     *
     * testCodeFromSource represents the &quot;code&quot; portion of the coding that represents what type of test was performed.
     *
     * At the time of writing, this is only populated via HL7. If a &quot;single textual report&quot; content pattern was
     * provided then this will be the code of the panel (OBR-4.1), otherwise this will be the code of the observation
     * (OBX-3.1).
     *
     * The &quot;FromSource&quot; suffix indicates that this value is stored as provided, without processing or manipulation. The
     * reason for highlighting this is because the test code is also captured in the test type (whether loinctest or
     * loincmapping) and in theory these might differ; e.g. when entering a result manually a user picks from a list,
     * so they did not provide a known code of their own.
     */
    @EHRField
    private String testCodeFromSource;

    /**
     * testCodingSystemFromSource represents the &quot;coding system&quot; from which testCodeFromSource was taken.
     *
     * See testCodeFromSource for more information.
     */
    @EHRField
    private String testCodingSystemFromSource;

    /**
     * Tests results are sometimes ordered as part of a service (a.k.a. battery, panel). The service might report
     * multiple results, including this one. Tracking the name of the service from which the result was taken allows PKB
     * to show &quot;related results&quot; in the web interface.
     *
     * The service name might sometimes be the same as the test code, e.g. if a single test is being ordered.
     *
     * Note: the &quot;related results&quot; functionality is flaky not guaranteed to work reliably, this is a known issue.
     *
     * The &quot;FromSource&quot; suffix indicates that this value is stored as provided, without processing or manipulation. The
     * reason for highlighting this is because a service name is also captured in LoincMapping.serviceName, but that
     * only captures the first value seen, which might not match the service name provided with this particular result.
     */
    @EHRField
    private String serviceNameFromSource;

    /**
     * This is the primary timestamp for the test result, and captures the clinically relevant point in time. For
     * example, for a blood test, this should be when the sample was taken from the patient, regardless of when the
     * subsequent anaylsis was completed.
     */
    @EHRField(queryField = QueryField.date01)
    private Instant testDate;

    /**
     * Sometimes a numeric test result value will not produce an exact value. For example, if a specimen is below a
     * detectable threshold, the result might be &lt;X. This comparator allows the sender to indicate that the result value
     * is not an exact number.
     *
     * If no comparator is present, EQUAL should be assumed.
     */
    @EHRField
    private ComparatorOperator valueComparator;

    /**
     * A result value is either numeric, textual, or comments-only.
     *
     * If the result was numeric, the value is stored here.
     *
     * For HL7 results, a numeric result does not have textValue populated. This is lossy w.r.t the original input
     * value. For example, it is not possible to determine whether 1.0 or 1.00 was provided when the numeric value is 1.
     */
    @EHRField
    private Double value;

    /**
     * A result value is either numeric, textual, or comments-only.
     *
     * If the result was textual, the value is stored here.
     */
    @EHRField
    private String textValue;

    /**
     * A result value is either numeric, textual, or comments-only.
     *
     * If the result was comments-only, the value is stored here.
     *
     * Otherwise, this field will contain any notes provided to accompany a numeric or textual result.
     */
<span class="fc" id="L264">    @EHRField</span>
    private String comments = &quot;&quot;;

    /**
     * Some test results have a numeric reference range provided, which indicates the range of values a typically normal
     * result will fall between. This can be bounded (e.g. a-b) or unbounded (e.g. &gt;a, &lt;=b).
     *
     * See HL7ReferenceRange for more information on how these are parsed from HL7 messages.
     *
     * This value represents the lower bound of that range, when provided.
     */
    @EHRField
    private Double rangeLow;

    /**
     * Some test results have a numeric reference range provided, which indicates the range of values a typically normal
     * result will fall between. This can be bounded (e.g. a-b) or unbounded (e.g. &gt;a, &lt;=b).
     *
     * See HL7ReferenceRange for more information on how these are parsed from HL7 messages.
     *
     * This value represents the upper bound of that range, when provided.
     */
    @EHRField
    private Double rangeHigh;

    /**
     * Whether or not rangeLow (the lower bound) is inclusive. For example, an unbounded reference range of &gt;2 has a
     * lower bound that is not inclusive.
     */
<span class="fc" id="L293">    @EHRField</span>
<span class="fc" id="L294">    private Boolean rangeLowInclusive = true;</span>

    /**
     * Whether or not rangeHigh (the upper bound) is inclusive. For example, an unbounded reference range of &lt;2 has an
     * upper bound that is not inclusive.
     */
<span class="fc" id="L300">    @EHRField</span>
<span class="fc" id="L301">    private Boolean rangeHighInclusive = true;</span>

    /**
     * In the same way that numeric result types can have numeric ranges indicating a normal result value, textual
     * result types can have a textual &quot;range&quot; indicating a typically normal result. For example, this might be set to
     * &quot;POSITIVE&quot; for a result that is typically expected to be positive.
     */
    @EHRField
    private String textRange;

    /**
     * When a user manually adds test result(s) in the web interface, they might optionally include an attachment to
     * illustrate where the result came from (e.g. a picture of a letter they were sent containing the test results).
     *
     * sourceFileId can be used to track the corresponding FileDTO.id of the uploaded file. A single source file can be
     * associated with multiple results.
     */
    @EHRField
    private Long sourceFileId;

    /**
     * A test result is typically sent from a hospital lab system, which assigns a lab order ID (a.k.a. filler order
     * number) to each order. Like other external IDs, this ID is unique to the source org but not necessarily globally.
     *
     * A single lab order can lead to multiple results, so this ID might be shared across multiple test result data
     * points in PKB, which is why an ExternalId instance is not appropriate.
     */
    @EHRField(queryField = QueryField.string03)
    private String labOrderId;

    /**
     * If this TestResultDTO instance is not the first version of the data point, then this attribute contains a copy
     * of DTOBaseFields.enteredDate for the current version. This duplication should ultimately not be necessary, but
     * currently this is the only way that the web tier can determine whether this TestResultDTO is a correction to a
     * previous version, and hence whether to show the &quot;corrected&quot; warning.
     *
     * https://manual.patientsknowbest.com/patient/tests#h.p_Z6tK_pHcJHSd
     *
     * Note: Up until PHR-8533 this timestamp was also (unnecessarily) set on the previous version.
     */
    @EHRField(queryField = QueryField.date02)
    private Instant replacementTimestamp;

    /**
     * HL7 lab results can optionally include a delay in OBX-13. This represents the number of days that should have
     * elapsed from the testDate value before the result should be shown to the patient (or carers). Professionals can
     * see the result before the delay has elapsed.
     *
     * https://manual.patientsknowbest.com/professional/tests
     */
    @EHRField
    private Long delayDisplayDays;

    /**
     * At the time of writing, this is only populated via HL7. Only the description is populated; it is set to ORC-13.9.
     */
    @EHRField
    private GeographicLocation entererLocation;

    /**
     * In contrast to the primary testDate timestamp, this timestamp is optional and captures when the specimen was
     * received by the laboratory. This is therefore expected to be greater than testDate.
     */
    @EHRField
    private ZonedDateTime specimenReceivedTimestamp;

    /**
     * At the time of writing, this is only populated via HL7. It is set to OBR-24.1.
     *
     * This is expected to be a code value, rather than a textual name. The code should represent a lab discipline,
     * such as immunology, or microbiology.
     */
    @EHRField
    private String labDiscipline;

    @EHRField(queryField = QueryField.accountId)
    private Long patientAccountId;

    @EHRField
    private Long codingReceivedId;

    /**
     * DELIBERATELY PROTECTED DO NOT CHANGE! Use the available constructors!
     * &lt;p&gt;
     * Would have even less visibility but JPA spec &amp; Hibernate requires a no arg const. which is public or protected.
     * Other than those, nothing should be able to construct without parameters, as changelog wouldn't be filled correctly etc.
     */
<span class="fc" id="L388">    protected TestResultDTO() {</span>
<span class="fc" id="L389">        this.source = new SourceDetails();</span>
<span class="fc" id="L390">    }</span>

<span class="fc" id="L392">    public TestResultDTO(SourceDetails source) {</span>
<span class="fc" id="L393">        this.source = source;</span>
<span class="fc" id="L394">    }</span>

    // not persisted, only parsed from HL7 and used for privacy labels
<span class="fc" id="L397">    private String obrServiceCode = &quot;&quot;;</span>

    private SourceDetails source;

<span class="fc" id="L401">    private DTOBaseFields baseFields = new DTOBaseFields();</span>

    // some utility methods for the JSPs
    public Long getTestResultTypeId() {
<span class="fc bfc" id="L405" title="All 2 branches covered.">        return loincTestId != null ? loincTestId : loincMappingId;</span>
    }

    public String getTestResultTypeIdSource() {
<span class="fc bfc" id="L409" title="All 2 branches covered.">        return loincTestId != null ? TestResultType.ID_SOURCE_LOINC : TestResultType.ID_SOURCE_MAPPING;</span>
    }

    public boolean isValueNumeric() {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        return value != null;</span>
    }

    /**
     * From the graph standpoint the value is ranged only if it's numeric and the numeric range is provided
     */
    public boolean isRanged() {
<span class="fc bfc" id="L420" title="All 4 branches covered.">        return isValueNumeric() &amp;&amp; isNumericRangeProvided();</span>
    }

    public boolean isNumericRangeProvided() {
<span class="fc bfc" id="L424" title="All 4 branches covered.">        return rangeLow != null || rangeHigh != null;</span>
    }

    /**
     * Used in the UI to check if any range is provided
     */
    public boolean isRangeProvided() {
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        return isNumericRangeProvided() || isTextualRangeProvided();</span>
    }

    public boolean isTextualRangeProvided() {
<span class="fc" id="L435">        return StringUtils.isNotBlank(textRange);</span>
    }

    /**
     * - or &gt; or &lt;= etc.
     */
    public String getRangeSign() {
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        if (!isNumericRangeProvided()) {</span>
<span class="nc" id="L443">            return &quot;&quot;;</span>
        }

<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (rangeLow == null) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if (rangeHighInclusive) {</span>
<span class="fc" id="L448">                return &quot;&lt;=&quot;;</span>
            } else {
<span class="fc" id="L450">                return &quot;&lt;&quot;;</span>
            }
<span class="fc bfc" id="L452" title="All 2 branches covered.">        } else if (rangeHigh == null) {</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (rangeLowInclusive) {</span>
<span class="fc" id="L454">                return &quot;&gt;=&quot;;</span>
            } else {
<span class="fc" id="L456">                return &quot;&gt;&quot;;</span>
            }
        } else { // neither is null
            // assuming they're both inclusive bounds...
<span class="fc" id="L460">            return &quot; - &quot;;</span>
        }
    }

    public boolean isRangeSignBefore() {
<span class="fc bfc" id="L465" title="All 6 branches covered.">        return (rangeLow == null) == (rangeHigh != null);</span>
    }

    public boolean hasComments() {
<span class="fc" id="L469">        return StringUtils.isNotBlank(comments);</span>
    }

    /* See also: getTextValueAsHTML */
    public String getCommentsAsHtml() {
<span class="fc bfc" id="L474" title="All 2 branches covered.">        if (StringUtils.isBlank(getComments())) {</span>
<span class="fc" id="L475">            return comments;</span>
        }

        // first escape unwanted HTML in the message (script tags, etc...)
        // because escaping will be disabled in the JSP
<span class="fc" id="L480">        String html = StringEscapeUtils.escapeHtml4(getComments());</span>
        // only support \n for now, because that's all we'll have from the HL7
<span class="fc" id="L482">        return StringUtils.replace(html, &quot;\n&quot;, &quot;&lt;br /&gt;&quot;);</span>
    }

    // debugging util

    @Override
    public String toString() {
<span class="fc" id="L489">        return MoreObjects.toStringHelper(TestResultDTO.class)</span>
<span class="fc" id="L490">                .omitNullValues()</span>
<span class="fc" id="L491">                .add(&quot;id&quot;, id)</span>
<span class="fc" id="L492">                .add(&quot;testDate&quot;, testDate)</span>
<span class="fc" id="L493">                .add(&quot;sourceFileId&quot;, sourceFileId)</span>
<span class="fc" id="L494">                .add(&quot;labOrderId&quot;, labOrderId)</span>
<span class="fc" id="L495">                .add(&quot;uploadedDataId&quot;, baseFields.getUploadedDataId())</span>
<span class="fc" id="L496">                .add(&quot;deleted&quot;, baseFields.isDeleted())</span>
<span class="fc" id="L497">                .toString();</span>
    }

    public boolean isTestResultTypeMatchIgnoringUnits(TestResultDTO other) {
        // compare coding
<span class="pc bpc" id="L502" title="2 of 4 branches missed.">        if (coding != null &amp;&amp; other.getCoding() != null) {</span>

<span class="fc" id="L504">            Set&lt;String&gt; thisEmptyCodingSystems = coding.getCodings().stream()</span>
<span class="fc" id="L505">                    .filter(coding -&gt; StringUtils.isBlank(coding.getCodeSystem()))</span>
<span class="fc" id="L506">                    .map(Coding::getCode)</span>
<span class="fc" id="L507">                    .collect(Collectors.toSet());</span>

<span class="fc" id="L509">            Set&lt;String&gt; otherEmptyCodingSystems = other.getCoding().getCodings().stream()</span>
<span class="fc" id="L510">                    .filter(coding -&gt; StringUtils.isBlank(coding.getCodeSystem()))</span>
<span class="fc" id="L511">                    .map(Coding::getCode)</span>
<span class="fc" id="L512">                    .collect(Collectors.toSet());</span>


<span class="fc" id="L515">            boolean codingMatch = true;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (!otherEmptyCodingSystems.containsAll(thisEmptyCodingSystems)) {</span>
<span class="fc" id="L517">                codingMatch = false;</span>
            }

            // Coding list is ordered, so instead of using equals, we're going through they system by system
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (codingMatch) {</span>
<span class="fc" id="L522">                Map&lt;String, Set&lt;String&gt;&gt; thisCodingIdsCodingSystem = coding.getCodings().stream()</span>
<span class="fc" id="L523">                        .filter(coding -&gt; StringUtils.isNotBlank(coding.getCodeSystem()))</span>
<span class="fc" id="L524">                        .collect(Collectors.groupingBy(Coding::getCodeSystem, Collectors.collectingAndThen(Collectors.toSet(),</span>
<span class="fc" id="L525">                                codings -&gt; codings.stream().map(Coding::getCode).collect(Collectors.toSet()))));</span>

<span class="fc" id="L527">                Map&lt;String, Set&lt;String&gt;&gt; otherCodingIdsByCodingSystem = other.getCoding().getCodings().stream()</span>
<span class="fc" id="L528">                        .filter(coding -&gt; StringUtils.isNotBlank(coding.getCodeSystem()))</span>
<span class="fc" id="L529">                        .collect(Collectors.groupingBy(Coding::getCodeSystem, Collectors.collectingAndThen(Collectors.toSet(),</span>
<span class="fc" id="L530">                                codings -&gt; codings.stream().map(Coding::getCode).collect(Collectors.toSet()))));</span>

<span class="fc bfc" id="L532" title="All 2 branches covered.">                for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : thisCodingIdsCodingSystem.entrySet()) {</span>
<span class="fc" id="L533">                    var otherCodingIds = otherCodingIdsByCodingSystem.get(entry.getKey());</span>
<span class="fc bfc" id="L534" title="All 4 branches covered.">                    if (otherCodingIds == null || !otherCodingIds.containsAll(entry.getValue())) {</span>
<span class="fc" id="L535">                        codingMatch = false;</span>
                    }
<span class="fc" id="L537">                }</span>
            }

<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (codingMatch) {</span>
<span class="fc" id="L541">                return true;</span>
            }
        }

        // If we can't match using testCodingSystemFromSource/testCodeFromSource, fall back on isTestResultTypeMatch.
        // It's unit specific but was previously needed to match deleted results that had their information blanked
        // out until PHR-8492.
        // We should no longer do this, because it might incorrectly fail to match a test result
        // that had the same code but differing units.
<span class="fc" id="L550">        boolean result = isTestResultTypeMatch(other);</span>

        // PHR-11190: Log if this happens before removing and replacing with &quot;return false&quot;
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (result) {</span>
<span class="nc" id="L554">            LOGGER.warn(&quot;PHR-11190: test result matched on type but not identity&quot;);</span>
        }

<span class="fc" id="L557">        return result;</span>
    }

    public boolean isTestResultTypeMatch(TestResultDTO other) {
        // if there *is* a mapping ID in both, compare on that.  Otherwise fall back to LOINC.
<span class="pc bpc" id="L562" title="2 of 4 branches missed.">        if ((loincMappingId != null) &amp;&amp; (other.getLoincMappingId() != null)) {</span>
<span class="fc" id="L563">            return loincMappingId.equals(other.getLoincMappingId());</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        } else if (loincTestId != null) {</span>
<span class="nc" id="L565">            return loincTestId.equals(other.getLoincTestId());</span>
        }

<span class="nc" id="L568">        return false;</span>
    }

    public boolean hasPrivacyFlagChange(TestResultDTO other) {
<span class="fc bfc" id="L572" title="All 2 branches covered.">        return !((getBaseFields().isGeneralHealthConsentRequired() == other.getBaseFields().isGeneralHealthConsentRequired())</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                &amp;&amp; (getBaseFields().isMentalHealthConsentRequired() == other.getBaseFields().isMentalHealthConsentRequired())</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                &amp;&amp; (getBaseFields().isSexualHealthConsentRequired() == other.getBaseFields().isSexualHealthConsentRequired())</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                &amp;&amp; (getBaseFields().isSocialCareConsentRequired() == other.getBaseFields().isSocialCareConsentRequired()));</span>
    }

    public boolean isDuplicate(TestResultDTO other) {
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (!isTestResultTypeMatch(other)) {</span>
<span class="fc" id="L580">            return false;</span>
        }
<span class="fc" id="L582">        TestResultComparisonDTO otherComparison = TestResultDTOMapper.INSTANCE.map(other);</span>
<span class="fc" id="L583">        TestResultComparisonDTO thisComparison = TestResultDTOMapper.INSTANCE.map(this);</span>
<span class="fc" id="L584">        return otherComparison.equals(thisComparison);</span>
    }

    // util for HL7 API

    public void addComment(String _comment) {
        // DO NOT trim leading whitespace; some textual reports will have careful spacing
        // handle null values like blanks lines
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (StringUtils.isBlank(_comment)) {</span>
<span class="fc" id="L593">            _comment = &quot;&quot;;</span>
        }
<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (!comments.isEmpty()) {</span>
<span class="fc" id="L596">            comments += &quot;\n&quot;;</span>
        }

<span class="fc" id="L599">        comments += StringUtils.stripEnd(_comment, null/*default: strips whitespace*/);</span>
<span class="fc" id="L600">    }</span>

    // getters/setters
    @Override
    public MenuDataType getDataType() {
<span class="nc" id="L605">        return MS_PATH;</span>
    }

    @Override
    public Long getPatientAccountId() {
<span class="fc" id="L610">        return patientAccountId;</span>
    }

    public void setPatientAccountId(Long patientAccountId) {
<span class="fc" id="L614">        this.patientAccountId = patientAccountId;</span>
<span class="fc" id="L615">    }</span>

    public Long getCodingReceivedId() {
<span class="fc" id="L618">        return codingReceivedId;</span>
    }

    public void setCodingReceivedId(Long codingReceivedId) {
<span class="fc" id="L622">        this.codingReceivedId = codingReceivedId;</span>
<span class="fc" id="L623">    }</span>

    @Override
    public Long getId() {
<span class="fc" id="L627">        return id;</span>
    }

    @Override
    public void setId(Long id) {
<span class="fc" id="L632">        this.id = id;</span>
<span class="fc" id="L633">    }</span>

    public Long getLoincTestId() {
<span class="fc" id="L636">        return loincTestId;</span>
    }

    public void setLoincTestId(Long loincTestId) {
<span class="fc" id="L640">        this.loincTestId = loincTestId;</span>
<span class="fc" id="L641">    }</span>

    public Instant getTestDate() {
<span class="fc" id="L644">        return testDate;</span>
    }

    public void setTestDate(Instant testDate) {
<span class="fc" id="L648">        this.testDate = testDate;</span>
<span class="fc" id="L649">    }</span>

    public Double getValue() {
<span class="fc" id="L652">        return value;</span>
    }

    public void setValue(Double value) {
<span class="fc" id="L656">        this.value = value;</span>
<span class="fc" id="L657">    }</span>

    public Double getRangeLow() {
<span class="fc" id="L660">        return rangeLow;</span>
    }

    public void setRangeLow(Double rangeLow) {
<span class="fc" id="L664">        this.rangeLow = rangeLow;</span>
<span class="fc" id="L665">    }</span>

    public Double getRangeHigh() {
<span class="fc" id="L668">        return rangeHigh;</span>
    }

    public void setRangeHigh(Double rangeHigh) {
<span class="fc" id="L672">        this.rangeHigh = rangeHigh;</span>
<span class="fc" id="L673">    }</span>

    public boolean isRangeLowInclusive() {
<span class="pc bpc" id="L676" title="1 of 4 branches missed.">        return rangeLowInclusive != null &amp;&amp; rangeLowInclusive;</span>
    }

    public void setRangeLowInclusive(Boolean rangeLowInclusive) {
<span class="fc" id="L680">        this.rangeLowInclusive = rangeLowInclusive;</span>
<span class="fc" id="L681">    }</span>

    public boolean isRangeHighInclusive() {
<span class="pc bpc" id="L684" title="1 of 4 branches missed.">        return rangeHighInclusive != null &amp;&amp; rangeHighInclusive;</span>
    }

    public String getTextRange() {
<span class="fc" id="L688">        return textRange;</span>
    }

    public void setTextRange(String textRange) {
<span class="fc" id="L692">        this.textRange = textRange;</span>
<span class="fc" id="L693">    }</span>

    public void setRangeHighInclusive(Boolean rangeHighInclusive) {
<span class="fc" id="L696">        this.rangeHighInclusive = rangeHighInclusive;</span>
<span class="fc" id="L697">    }</span>

    public Long getSourceFileId() {
<span class="fc" id="L700">        return sourceFileId;</span>
    }

    public void setSourceFileId(Long sourceFileId) {
<span class="fc" id="L704">        this.sourceFileId = sourceFileId;</span>
<span class="fc" id="L705">    }</span>

    public Long getLoincMappingId() {
<span class="fc" id="L708">        return loincMappingId;</span>
    }

    public void setLoincMappingId(Long loincMappingId) {
<span class="fc" id="L712">        this.loincMappingId = loincMappingId;</span>
<span class="fc" id="L713">    }</span>

    public String getTextValue() {
<span class="fc" id="L716">        return textValue;</span>
    }

    public void setTextValue(String textValue) {
<span class="fc" id="L720">        this.textValue = textValue;</span>
<span class="fc" id="L721">    }</span>

    /* See also: getCommentsAsHTML */
    public String getTextValueAsHTML() {
<span class="fc" id="L725">        String textValue = getTextValue();</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">        if (StringUtils.isBlank(textValue)) {</span>
<span class="fc" id="L727">            return textValue;</span>
        }
        // first escape unwanted HTML in the message (script tags, etc...)
        // because escaping will be disabled in the JSP
<span class="fc" id="L731">        String html = StringEscapeUtils.escapeHtml4(textValue);</span>
        // only support \n for now, because that's all we'll have from the HL7
<span class="fc" id="L733">        return StringUtils.replace(html, &quot;\n&quot;, &quot;&lt;br /&gt;&quot;);</span>
    }

    public String getComments() {
<span class="fc" id="L737">        return comments;</span>
    }

    public void setComments(String comments) {
<span class="fc" id="L741">        this.comments = comments;</span>
<span class="fc" id="L742">    }</span>

    public String getLabOrderId() {
<span class="fc" id="L745">        return labOrderId;</span>
    }

    public void setLabOrderId(String labOrderId) {
<span class="fc" id="L749">        this.labOrderId = labOrderId;</span>
<span class="fc" id="L750">    }</span>

    public Instant getReplacementTimestamp() {
<span class="fc" id="L753">        return replacementTimestamp;</span>
    }

    public void setReplacementTimestamp(Instant replacementTimestamp) {
<span class="fc" id="L757">        this.replacementTimestamp = replacementTimestamp;</span>
<span class="fc" id="L758">    }</span>

    @Override
    @NotNull
    public SourceDetails getSource() {
<span class="fc" id="L763">        return source;</span>
    }

    public CodeableConcept getCoding() {
<span class="fc" id="L767">        return coding;</span>
    }

    public void setCoding(CodeableConcept coding) {
<span class="fc" id="L771">        this.coding = coding;</span>
<span class="fc" id="L772">    }</span>

    public String getTestCodeFromSource() {
<span class="fc" id="L775">        return testCodeFromSource;</span>
    }

    public void setTestCodeFromSource(String testCodeFromSource) {
<span class="fc" id="L779">        this.testCodeFromSource = testCodeFromSource;</span>
<span class="fc" id="L780">    }</span>

    public String getTestCodingSystemFromSource() {
<span class="fc" id="L783">        return testCodingSystemFromSource;</span>
    }

    public void setTestCodingSystemFromSource(String testCodingSystemFromSource) {
<span class="fc" id="L787">        this.testCodingSystemFromSource = testCodingSystemFromSource;</span>
<span class="fc" id="L788">    }</span>

    public String getServiceNameFromSource() {
<span class="fc" id="L791">        return serviceNameFromSource;</span>
    }

    public void setServiceNameFromSource(String serviceNameFromSource) {
<span class="fc" id="L795">        this.serviceNameFromSource = serviceNameFromSource;</span>
<span class="fc" id="L796">    }</span>

    @Override
    public DTOBaseFields getBaseFields() {
<span class="fc" id="L800">        return baseFields;</span>
    }

    public Long getDelayDisplayDays() {
<span class="fc" id="L804">        return delayDisplayDays;</span>
    }

    public void setDelayDisplayDays(Long delayDisplayDays) {
<span class="fc" id="L808">        this.delayDisplayDays = delayDisplayDays;</span>
<span class="fc" id="L809">    }</span>

    public String getObrServiceCode() {
<span class="fc" id="L812">        return obrServiceCode;</span>
    }

    public void setObrServiceCode(String obrServiceCode) {
<span class="fc" id="L816">        this.obrServiceCode = obrServiceCode;</span>
<span class="fc" id="L817">    }</span>

    public GeographicLocation getEntererLocation() {
<span class="fc" id="L820">        return entererLocation;</span>
    }

    public void setEntererLocation(GeographicLocation entererLocation) {
<span class="fc" id="L824">        this.entererLocation = entererLocation;</span>
<span class="fc" id="L825">    }</span>

    public ZonedDateTime getSpecimenReceivedTimestamp() {
<span class="fc" id="L828">        return specimenReceivedTimestamp;</span>
    }

    public void setSpecimenReceivedTimestamp(ZonedDateTime specimenReceivedTimestamp) {
<span class="fc" id="L832">        this.specimenReceivedTimestamp = specimenReceivedTimestamp;</span>
<span class="fc" id="L833">    }</span>

    public String getLabDiscipline() {
<span class="fc" id="L836">        return labDiscipline;</span>
    }

    public void setLabDiscipline(String labDiscipline) {
<span class="fc" id="L840">        this.labDiscipline = labDiscipline;</span>
<span class="fc" id="L841">    }</span>

    public ComparatorOperator getValueComparator() {
<span class="fc" id="L844">        return valueComparator;</span>
    }

    public void setValueComparator(ComparatorOperator valueComparator) {
<span class="fc" id="L848">        this.valueComparator = valueComparator;</span>
<span class="fc" id="L849">    }</span>

    public String getValueWithComparatorStr() {
<span class="fc" id="L852">        return valueComparator.toString() + &quot; &quot; + value.toString();</span>
    }

    public boolean isValueWithComparator() {
<span class="fc bfc" id="L856" title="All 2 branches covered.">        return valueComparator != null;</span>
    }

    public void setSource(SourceDetails source) {
<span class="fc" id="L860">        this.source = source;</span>
<span class="fc" id="L861">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>