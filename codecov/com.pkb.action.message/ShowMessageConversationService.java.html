<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShowMessageConversationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.action.message</a> &gt; <span class="el_source">ShowMessageConversationService.java</span></div><h1>ShowMessageConversationService.java</h1><pre class="source lang-java linenums">package com.pkb.action.message;

import com.google.common.collect.Sets;
import com.google.common.collect.Streams;
import com.pkb.action.message.ConversationActionItemBuilder.ActionItemBuilderInputParams;
import com.pkb.action.message.workflow.ConversationWorkflowFlagService;
import com.pkb.action.message.workflow.ConversationWorkflowFlags;
import com.pkb.api.internal.messaging.MessagingPKBPersonDTO;
import com.pkb.api.internal.messaging.PKBPersonToMessagingPKBPersonDTOConverter;
import com.pkb.app.dto.ParticipantDTO;
import com.pkb.app.entity.AbstractPersonRoles;
import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.app.interfaces.IBaseDTO;
import com.pkb.bean.impl.MessageWebBean;
import com.pkb.common.config.PhrConfig;
import com.pkb.datamodel.ui.ResponseMeta;
import com.pkb.domain.messages.workflow.TrustedConversationWorkflowService;
import com.pkb.dto.DiscussionParticipantsDTO;
import com.pkb.dto.PKBMessageDTO;
import com.pkb.encounter.entity.Encounter;
import com.pkb.encounter.entity.Message;
import com.pkb.encounter.workflow.ArchivedStatus;
import com.pkb.encounter.workflow.ConversationWorkflowDTO;
import com.pkb.institute.entity.Org;
import com.pkb.institute.entity.Team;
import com.pkb.mappers.ImmutableEntityDependency;
import com.pkb.service.datapoint.DataWithEncounterRules;
import com.pkb.service.datapoint.DataWithUIPermissions;
import com.pkb.service.datapoint.impl.DataPointManager;
import com.pkb.service.encounter.impl.tolven.EncounterManager;
import com.pkb.service.encounter.workflow.ConversationWorkflowConverter;
import com.pkb.service.reference.ReferenceDataManager;
import com.pkb.service.team.TeamManager;
import com.pkb.service.team.TeamUserManager;
import com.pkb.service.user.impl.UserManager;
import com.pkb.user.entity.PKBPerson;
import com.pkb.util.DataDelayService;
import com.pkb.util.DateUtil;
import com.pkb.util.Pager;
import com.pkb.util.PrivacyUtil;
import io.vavr.Tuple2;
import io.vavr.control.Either;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.UUID;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.opensymphony.xwork2.Action.SUCCESS;
import static com.pkb.action.message.ShowMessageConversationAction.NOT_FOUND;
import static com.pkb.entities.enums.ReferenceDataType.HOSPITAL_SERVICE;
import static io.vavr.control.Either.left;
import static java.lang.String.format;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonMap;
import static java.util.Comparator.comparing;
import static java.util.Objects.nonNull;
import static java.util.function.Predicate.isEqual;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toCollection;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.collections.CollectionUtils.isNotEmpty;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

public class ShowMessageConversationService {
<span class="fc" id="L92">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    private final EncounterManager encounterManager;
    private final ConversationWorkflowFlagService conversationWorkflowFlagService;
    private final TrustedConversationWorkflowService trustedConversationWorkflowService;
    private final ConversationWorkflowConverter conversationWorkflowConverter;
    private final DataPointManager dataPointManager;
    private final MessageWebBean messageWebBean;
    private final UserManager userManager;
    private final TeamUserManager teamUserManager;
    private final DateUtil dateUtil;
    private final EncounterClassLocalizationHelper encounterClassLocalizationHelper;
    private final MessageSource messageSource;
    private final ReferenceDataManager referenceDataManager;
    private final TeamManager teamManager;
    private final PKBPersonToMessagingPKBPersonDTOConverter personDTOConverter;
    private final PrivacyUtil privacyUtil;
    private final ConversationParticipantBuilder participantBuilder;
    private final ConversationActionItemBuilder conversationActionItemBuilder;
    private final MessageActionItemBuilder messageActionItemBuilder;
    private final ReplyFeasibilityService replyFeasibilityService;
    private final PhrConfig config;

    @Autowired
    private DataDelayService dataDelayService;

    public ShowMessageConversationService(EncounterManager encounterManager, ConversationWorkflowFlagService conversationWorkflowFlagService,
                                          TrustedConversationWorkflowService trustedConversationWorkflowService, ConversationWorkflowConverter conversationWorkflowConverter,
                                          DataPointManager dataPointManager, MessageWebBean messageWebBean, UserManager userManager, TeamUserManager teamUserManager,
                                          DateUtil dateUtil, EncounterClassLocalizationHelper encounterClassLocalizationHelper, ReferenceDataManager referenceDataManager,
                                          TeamManager teamManager, PKBPersonToMessagingPKBPersonDTOConverter personDTOConverter, PrivacyUtil privacyUtil,
                                          ConversationActionItemBuilder conversationActionItemBuilder, MessageActionItemBuilder messageActionItemBuilder,
                                          ConversationParticipantBuilder participantBuilder, MessageSource messageSource, ReplyFeasibilityService replyFeasibilityService,
<span class="fc" id="L125">                                          PhrConfig config) {</span>
<span class="fc" id="L126">        this.encounterManager = encounterManager;</span>
<span class="fc" id="L127">        this.conversationWorkflowFlagService = conversationWorkflowFlagService;</span>
<span class="fc" id="L128">        this.trustedConversationWorkflowService = trustedConversationWorkflowService;</span>
<span class="fc" id="L129">        this.conversationWorkflowConverter = conversationWorkflowConverter;</span>
<span class="fc" id="L130">        this.userManager = userManager;</span>
<span class="fc" id="L131">        this.dataPointManager = dataPointManager;</span>
<span class="fc" id="L132">        this.messageWebBean = messageWebBean;</span>
<span class="fc" id="L133">        this.teamUserManager = teamUserManager;</span>
<span class="fc" id="L134">        this.dateUtil = dateUtil;</span>
<span class="fc" id="L135">        this.encounterClassLocalizationHelper = encounterClassLocalizationHelper;</span>
<span class="fc" id="L136">        this.messageSource = messageSource;</span>
<span class="fc" id="L137">        this.referenceDataManager = referenceDataManager;</span>
<span class="fc" id="L138">        this.teamManager = teamManager;</span>
<span class="fc" id="L139">        this.personDTOConverter = personDTOConverter;</span>
<span class="fc" id="L140">        this.conversationActionItemBuilder = conversationActionItemBuilder;</span>
<span class="fc" id="L141">        this.messageActionItemBuilder = messageActionItemBuilder;</span>
<span class="fc" id="L142">        this.participantBuilder = participantBuilder;</span>
<span class="fc" id="L143">        this.privacyUtil = privacyUtil;</span>
<span class="fc" id="L144">        this.replyFeasibilityService = replyFeasibilityService;</span>
<span class="fc" id="L145">        this.config = config;</span>
<span class="fc" id="L146">    }</span>

    public Either&lt;String, UUID&gt; findConversationIdForDocumentId(@NotNull LoggedInEHRRequestContext requestContext, UUID documentId) {
<span class="pc bpc" id="L149" title="2 of 4 branches missed.">        if (requestContext.isPro() &amp;&amp; teamUserManager.isActiveTeamUser(requestContext.getAccessingUserId())) {</span>
<span class="fc" id="L150">            return encounterManager.findConversationIdForDocumentId(documentId).toEither(NOT_FOUND);</span>
        } else {
<span class="nc" id="L152">            LOGGER.error(&quot;Actor-type=[{}] is not a team pro.&quot;, requestContext.getAccessingUser().getUserType());</span>
<span class="nc" id="L153">            return left(NOT_FOUND);</span>
        }
    }

    public Optional&lt;MessageScreenDto&gt; buildMessageScreenDto(LoggedInEHRRequestContext loggedinContext, UUID conversationId,
                                                            String message, Locale locale,
                                                            @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {

<span class="fc" id="L161">        List&lt;Long&gt; userIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L162">        userIds.add(loggedinContext.getAccessingUserId());</span>

<span class="fc" id="L164">        Long accountOwnerId = loggedinContext.getContextOrAccessingUserId();</span>
<span class="fc" id="L165">        long accountId = userManager.getDefaultAccountId(accountOwnerId);</span>

<span class="fc" id="L167">        var mayBeConversation = encounterManager.getOptionalConversation(loggedinContext.withoutAccessLog(), conversationId, loggedinContext.getAccessingUserId(), accountId);</span>

<span class="fc" id="L169">        Set&lt;Long&gt; participantIds = null;</span>
<span class="fc" id="L170">        List&lt;String&gt; fullParticipants = null;</span>
<span class="fc" id="L171">        Long patientIdLong = null;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (mayBeConversation.isPresent()) {</span>
<span class="fc" id="L173">            var actualConversation = mayBeConversation.get();</span>
<span class="fc" id="L174">            String patientId = actualConversation.getAboutPatientId();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (isNotBlank(patientId)) {</span>
<span class="fc" id="L176">                patientIdLong = Long.parseLong(patientId);</span>
<span class="fc" id="L177">                userIds.add(patientIdLong);</span>
            }

<span class="fc" id="L180">            fullParticipants = actualConversation.getParticipants();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if (fullParticipants != null) {</span>
<span class="fc" id="L182">                participantIds = fullParticipants.stream()</span>
<span class="fc" id="L183">                        .filter(this::isParticipant)</span>
<span class="fc" id="L184">                        .map(Long::parseLong)</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                        .filter(id -&gt; !id.equals(accountOwnerId))</span>
<span class="fc" id="L186">                        .collect(Collectors.toCollection(LinkedHashSet::new));</span>
<span class="fc" id="L187">                userIds.addAll(participantIds);</span>
            }
        }

<span class="fc" id="L191">        loggedinContext.getContextUserId().ifPresent(userIds::add);</span>

        // This will contain accessing user, if conversation was found then maybe patient id, then x participants, then maybe context user
<span class="fc" id="L194">        Map&lt;Long, PKBPerson&gt; pkbPersonMap = userManager.getPKBPersonMapById(userIds, PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>

<span class="fc" id="L196">        PKBPerson accessingUser = Objects.requireNonNull(pkbPersonMap.get(loggedinContext.getAccessingUserId()), &quot;Can't find logged in user&quot;);</span>

<span class="fc" id="L198">        PKBPerson contextUser = loggedinContext.getContextUserId().map(pkbPersonMap::get).orElse(null);</span>

<span class="fc" id="L200">        PKBPerson accountOwner = contextUser;</span>
<span class="fc" id="L201">        boolean accountOwnerIsLoggedIn = true;</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (contextUser == null) {</span>
<span class="fc" id="L204">            accountOwner = accessingUser;</span>
        }

<span class="fc" id="L207">        long loggedInUserId = accessingUser.getId();</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (accountOwnerId != loggedInUserId) {</span>
<span class="fc" id="L210">            accountOwnerIsLoggedIn = false;</span>
        }

<span class="fc" id="L213">        boolean leftDiscussion = false;</span>

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (mayBeConversation.isPresent()) {</span>
<span class="fc" id="L216">            var actualConversation = mayBeConversation.get();</span>
<span class="fc" id="L217">            ImmutableMessageScreenDto.Builder builder = ImmutableMessageScreenDto.builder();</span>
<span class="fc" id="L218">            messageWebBean.expandInlineContents(loggedinContext, loggedInUserId, accountId, actualConversation.getLatestMessage(),</span>
                    true);

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            if (isNotBlank(message)) {</span>
                // message could  come from add participant  screen
                // where the contents will be escaped
<span class="nc" id="L224">                message = StringEscapeUtils.unescapeHtml4(message);</span>
            }

            // clinicianId affects ONLY the prev/next convo references... those are filtered by sender/receiver
            // (but doesn't yet support multiple user convos...)

<span class="fc" id="L230">            List&lt;Message&gt; messages = encounterManager.getMessages(loggedinContext, accountId, Pager.ALL, 0, conversationId, i18nMethod);</span>

<span class="fc" id="L232">            Message draftMessage = null;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            for (Message currentMessage : messages) {</span>
<span class="fc" id="L234">                LOGGER.info(&quot;message isHtmlAllowed{}&quot;, currentMessage.isHtmlAllowed());</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if (currentMessage.isDraft()) {</span>
<span class="fc" id="L236">                    draftMessage = currentMessage;</span>
                }
<span class="fc" id="L238">                messageWebBean.expandInlineContents(loggedinContext, loggedInUserId, accountId, currentMessage, true);</span>

<span class="fc" id="L240">                checkForMissingSubjectAndContent(currentMessage);</span>
<span class="fc" id="L241">            }</span>

<span class="fc" id="L243">            String draftMessageId = null;</span>
            // If the latest message in the conversation is in INDRAFT
            // then preserve the message id
<span class="pc bpc" id="L246" title="1 of 4 branches missed.">            if ((draftMessage != null) &amp;&amp; accountOwnerIsLoggedIn) {</span>
<span class="fc" id="L247">                draftMessageId = &quot;&quot; + draftMessage.getId();</span>
<span class="pc bpc" id="L248" title="3 of 4 branches missed.">                if ((message == null) || message.isEmpty()) {</span>
<span class="fc" id="L249">                    message = StringEscapeUtils.unescapeHtml4(draftMessage.getContent());</span>
                }
            }

<span class="fc" id="L253">            builder.draftMessageId(draftMessageId);</span>

<span class="fc" id="L255">            String initialSubject = extractInitialSubject(messages);</span>
<span class="fc" id="L256">            builder.initialSubject(initialSubject);</span>

            // when we send a reply, it needs to go to the OTHER user
            // (obsolete since multiway messaging?)
<span class="fc" id="L260">            builder.recipientId(getOtherUserId(messages, accountOwnerId));</span>

<span class="fc" id="L262">            List&lt;PKBPerson&gt; participants = emptyList();</span>
<span class="fc" id="L263">            boolean currentParticipant = false;</span>
<span class="fc" id="L264">            boolean disableReply = false;</span>
<span class="fc" id="L265">            boolean disableAddContacts = false;</span>
            // Check if the logged in user is a current participant in the discussion
            // To make sure that user can reply

<span class="fc" id="L269">            Optional&lt;String&gt; leftDiscussionMessage = Optional.empty();</span>
<span class="fc" id="L270">            DiscussionParticipantsDTO participantsDTO = null;</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            if (fullParticipants != null) {</span>
<span class="fc" id="L272">                participants = participantIds.stream().map(pkbPersonMap::get).collect(toList());</span>

<span class="fc" id="L274">                currentParticipant = fullParticipants.stream().anyMatch(isEqual(Long.toString(accountOwnerId)));</span>

                // At this point there participants list contains all but logged in user
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">                if (!currentParticipant &amp;&amp; draftMessage == null) {</span>
                    // so logged in user must have
<span class="fc" id="L279">                    leftDiscussionMessage = Optional.of(getText(locale).apply(&quot;composemessage.removed.user&quot;, null));</span>
<span class="fc" id="L280">                    disableReply = true;</span>
<span class="fc" id="L281">                    leftDiscussion = true;</span>
                }

<span class="pc bpc" id="L284" title="1 of 4 branches missed.">                if (participants.isEmpty() &amp;&amp; draftMessage == null) {</span>
                    // unless the logged in user is drafting a message with no participants, disable reply
                    // leaving a discussion is possible only with atleast one participant still in conversation
                    // so this cannot be a case of leaving discussion
<span class="fc" id="L288">                    leftDiscussion = false;</span>
<span class="fc" id="L289">                    disableReply = true;</span>
                }

<span class="fc bfc" id="L292" title="All 2 branches covered.">                if (!replyFeasibilityService.isFeasibleToBeReplied(conversationId, participantIds)) {</span>
<span class="fc" id="L293">                    disableReply = true;</span>
<span class="fc" id="L294">                    disableAddContacts = true;</span>
                }

<span class="fc" id="L297">                var nonPKBParticipantsWithoutDuplicates = messages.stream()</span>
<span class="fc" id="L298">                        .map(Message::getParticipantsNonPKB)</span>
<span class="fc" id="L299">                        .filter(Objects::nonNull)</span>
<span class="fc" id="L300">                        .flatMap(List::stream)</span>
<span class="fc" id="L301">                        .collect(collectingAndThen(toCollection(() -&gt; new TreeSet&lt;&gt;(comparing(ParticipantDTO::getNonpkbParticipant))),</span>
                                ArrayList::new));
<span class="fc" id="L303">                participantsDTO = participantBuilder.sortParticipants(loggedinContext,</span>
                        participants,
                        nonPKBParticipantsWithoutDuplicates,
                        patientIdLong, locale);
<span class="fc" id="L307">                builder.participants(participantsDTO);</span>
            }
<span class="fc" id="L309">            builder.replyDisabled(disableReply);</span>
            // Non PKB Participants need some null/blank checking
<span class="fc" id="L311">            actualConversation.setParticipantsNonPKB(participantBuilder.filterParticipantsNonPKB(actualConversation.getParticipantsNonPKB()));</span>

<span class="fc" id="L313">            Team team = teamUserManager.findPrimaryTeam(</span>
<span class="fc" id="L314">                    loggedinContext.withConsentNotRequired(),</span>
<span class="fc" id="L315">                    loggedinContext.getAccessingUserId()).orElse(null);</span>

            // Apply rules for showing/hiding the privacy edit links, combine with the existing permission in DataPointManager
            // If thread contains encounterEvents then no edit link in discussion header, display link on each encounter
            // If thread contains messages, then display edit link in discussion header, individual messages not editable
<span class="fc" id="L320">            boolean threadContainsEvents = actualConversation.containsEncounterEvents();</span>
<span class="fc" id="L321">            DataWithUIPermissions&lt;Encounter&gt; dataWithUIPermissions = dataPointManager.getPermission(actualConversation, accessingUser, team);</span>
<span class="pc bpc" id="L322" title="1 of 4 branches missed.">            dataWithUIPermissions.setPrivacyFlagEditable(dataWithUIPermissions.isPrivacyFlagEditable() &amp;&amp; !threadContainsEvents);</span>
<span class="fc" id="L323">            DataWithEncounterRules&lt;DataWithUIPermissions&lt;Encounter&gt;&gt; conversation = new DataWithEncounterRules&lt;&gt;(dataWithUIPermissions);</span>

<span class="fc" id="L325">            List&lt;DataWithUIPermissions&lt;Message&gt;&gt; dataWithPermissions = dataPointManager.getPermissions(messages, accessingUser, team);</span>
<span class="pc bpc" id="L326" title="1 of 4 branches missed.">            dataWithPermissions.forEach(m -&gt; m.setPrivacyFlagEditable(m.isPrivacyFlagEditable() &amp;&amp; threadContainsEvents));</span>

<span class="fc" id="L328">            List&lt;PKBMessageDTO&gt; messageDTOS = buildMessageDTOs(loggedinContext, dataWithPermissions, participants,</span>
<span class="fc" id="L329">                    accessingUser, actualConversation.getAboutPatientId(), locale);</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (accountOwnerIsLoggedIn) {</span>
<span class="fc" id="L332">                markAsReadAllUnreadMessages(loggedinContext, messages, accountId);</span>
            }

<span class="fc" id="L335">            Long longAboutPatientId = null;</span>
<span class="fc" id="L336">            String stringAboutPatientId = dataWithUIPermissions.getData().getAboutPatientId();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            if (isNotBlank(stringAboutPatientId)) {</span>
<span class="fc" id="L338">                longAboutPatientId = Long.parseLong(stringAboutPatientId);</span>
            }
<span class="fc" id="L340">            boolean hidePrivacyLabels = privacyUtil.isConversationPrivacyLabelsHidden(longAboutPatientId, loggedinContext);</span>
<span class="fc" id="L341">            builder.hidePrivacyLabels(hidePrivacyLabels);</span>

<span class="fc" id="L343">            Message firstMessage = dataWithUIPermissions.getData().getFirstMessage();</span>

<span class="fc" id="L345">            setPrivacyFlagsOnFirstMessage(messageDTOS.stream().map(PKBMessageDTO::getMessage).collect(toList()), firstMessage);</span>

<span class="fc" id="L347">            builder.messageDTOS(messageDTOS);</span>
<span class="fc" id="L348">            builder.currentParticipant(currentParticipant);</span>
<span class="fc" id="L349">            builder.message(message);</span>
<span class="fc" id="L350">            builder.conversation(conversation);</span>

<span class="fc" id="L352">            ConversationWorkflowFlags workflowFlags = conversationWorkflowFlagService.getWorkflowFlags(loggedinContext);</span>

<span class="fc" id="L354">            ConversationWorkflowDTO conversationWorkflow = null;</span>
<span class="pc bpc" id="L355" title="1 of 4 branches missed.">            if (workflowFlags.isArchivingEnabled() || workflowFlags.isAssigningEnabled()) {</span>
<span class="fc" id="L356">                conversationWorkflow = loggedinContext.getTeamId()</span>
<span class="fc" id="L357">                        .flatMap(tid -&gt; trustedConversationWorkflowService.findConversationWorkflow(actualConversation.getEncounterUniqueId(), tid))</span>
<span class="fc" id="L358">                        .map(c -&gt; singletonMap(c.getConversationId(), c))</span>
<span class="fc" id="L359">                        .map(c -&gt; new Tuple2&lt;&gt;(c, conversationWorkflowConverter.getAllAssignedPersonIds(c)))</span>
<span class="fc" id="L360">                        .map(t -&gt; new Tuple2&lt;&gt;(t._1, userManager.getPKBPersonMapById(t._2)))</span>
<span class="fc" id="L361">                        .map(t -&gt; conversationWorkflowConverter.convertToDTOs(t._1, t._2).get(actualConversation.getEncounterUniqueId()))</span>
<span class="fc" id="L362">                        .orElse(null);</span>
            }

<span class="fc bfc" id="L365" title="All 4 branches covered.">            boolean conversationAssigned = conversationWorkflow != null &amp;&amp; conversationWorkflow.getAssignedPerson() != null;</span>
<span class="fc bfc" id="L366" title="All 4 branches covered.">            boolean conversationArchived = conversationWorkflow != null &amp;&amp; conversationWorkflow.getArchivedStatus() == ArchivedStatus.ARCHIVED;</span>

<span class="fc" id="L368">            builder.subject(buildMessageSubject(actualConversation, workflowFlags, conversationWorkflow, currentParticipant,</span>
                    conversationArchived, conversationAssigned, initialSubject, locale));

<span class="fc" id="L371">            boolean privateMessage = actualConversation.getLatestMessage().isPrivateMessage();</span>
<span class="fc" id="L372">            builder.privateMessage(privateMessage);</span>

<span class="fc" id="L374">            ActionItemBuilderInputParams inputParams = ImmutableActionItemBuilderInputParams.builder()</span>
<span class="fc" id="L375">                    .disableAddContacts(disableAddContacts)</span>
<span class="fc" id="L376">                    .threadContainsEvents(threadContainsEvents)</span>
<span class="fc" id="L377">                    .conversationAssigned(conversationAssigned)</span>
<span class="fc" id="L378">                    .conversationArchived(conversationArchived)</span>
<span class="fc" id="L379">                    .hidePrivacyLabels(hidePrivacyLabels)</span>
<span class="fc" id="L380">                    .privateMessage(privateMessage)</span>
<span class="fc" id="L381">                    .leftDiscussion(leftDiscussion)</span>
<span class="fc" id="L382">                    .conversationHasMessages(isNotEmpty(messageDTOS))</span>
<span class="fc" id="L383">                    .workflowFlags(workflowFlags)</span>
<span class="fc" id="L384">                    .dataWithUIPermissions(dataWithUIPermissions)</span>
<span class="fc" id="L385">                    .locale(locale)</span>
<span class="fc" id="L386">                    .loggedinContext(loggedinContext)</span>
<span class="fc" id="L387">                    .participantsDTO(Optional.ofNullable(participantsDTO))</span>
<span class="fc" id="L388">                    .optimisticLockVersion(Optional.ofNullable(conversationWorkflow).map(ConversationWorkflowDTO::getOptimisticLockVersion))</span>
<span class="fc" id="L389">                    .build();</span>

<span class="fc" id="L391">            builder.workflowFlags(workflowFlags)</span>
<span class="fc" id="L392">                    .conversationWorkflow(conversationWorkflow)</span>
<span class="fc" id="L393">                    .actionItems(conversationActionItemBuilder.buildActionItems(inputParams));</span>

<span class="fc" id="L395">            MessageScreenDto messageScreenDto = builder.build();</span>
<span class="fc" id="L396">            leftDiscussionMessage.map(ResponseMeta::ofActionWarning).ifPresent(messageScreenDto::setResponseMeta);</span>
<span class="fc" id="L397">            messageScreenDto.setActionResult(SUCCESS);</span>
<span class="fc" id="L398">            return Optional.of(messageScreenDto);</span>
        }
<span class="nc" id="L400">        return Optional.empty();</span>
    }

    private String buildMessageSubject(Encounter actualConversation,
                                       ConversationWorkflowFlags workflowFlags,
                                       ConversationWorkflowDTO conversationWorkflow,
                                       boolean currentParticipant,
                                       boolean conversationArchived,
                                       boolean conversationAssigned,
                                       String initialSubject,
                                       Locale locale) {
<span class="fc" id="L411">        String archivedLabel = null;</span>
<span class="fc" id="L412">        String assignedLabel = null;</span>
<span class="fc" id="L413">        String subject = null;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (actualConversation.getLatestMessage().isDraft()) {</span>
<span class="fc" id="L415">            Long messageCount = actualConversation.getMessageCount();</span>
<span class="pc bpc" id="L416" title="2 of 6 branches missed.">            if ((messageCount != null &amp;&amp; messageCount &gt; 1) || currentParticipant) {</span>
<span class="fc" id="L417">                subject = initialSubject;</span>
            }
<span class="fc" id="L419">        } else {</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (nonNull(initialSubject)) {</span>
<span class="fc bfc" id="L421" title="All 4 branches covered.">                if (workflowFlags.isArchivingEnabled() &amp;&amp; conversationArchived) {</span>
<span class="fc" id="L422">                    archivedLabel = getText(locale).apply(&quot;message.workflow.archived.text&quot;, null);</span>
                }
<span class="fc bfc" id="L424" title="All 4 branches covered.">                if (workflowFlags.isAssigningEnabled() &amp;&amp; conversationAssigned) {</span>
<span class="fc" id="L425">                    String[] nameArgs = new String[]{</span>
<span class="fc" id="L426">                            conversationWorkflow.getAssignedPerson().getTitle().orElse(EMPTY),</span>
<span class="fc" id="L427">                            conversationWorkflow.getAssignedPerson().getFirstName().orElse(EMPTY),</span>
<span class="fc" id="L428">                            conversationWorkflow.getAssignedPerson().getLastName().orElse(EMPTY)</span>
                    };
<span class="fc" id="L430">                    assignedLabel = getText(locale).apply(&quot;message.workflow.assigned.text&quot;, nameArgs);</span>
                }
<span class="fc bfc" id="L432" title="All 4 branches covered.">                if (isNotBlank(archivedLabel) &amp;&amp; isNotBlank(assignedLabel)) {</span>
<span class="fc" id="L433">                    subject = getText(locale).apply(&quot;discussionCenter.txt.archived_label_and_assigned_to_label_and_subject&quot;,</span>
                            new String[]{ archivedLabel, assignedLabel, initialSubject });
                } else {
<span class="fc" id="L436">                    subject = Stream.of(archivedLabel, assignedLabel)</span>
<span class="fc" id="L437">                            .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L438">                            .findFirst()</span>
<span class="fc" id="L439">                            .map(archivedOrAssignedLabel -&gt; getText(locale)</span>
<span class="fc" id="L440">                                    .apply(&quot;discussionCenter.txt.archived_label_or_assigned_to_label_and_subject&quot;,</span>
                                            new String[]{ archivedOrAssignedLabel, initialSubject }))
<span class="fc" id="L442">                            .orElse(initialSubject);</span>
                }
            } else {
<span class="nc" id="L445">                subject = Optional.ofNullable(actualConversation.getEncounterClass())</span>
<span class="nc" id="L446">                        .map(encounterClass -&gt; encounterClassLocalizationHelper</span>
<span class="nc" id="L447">                                .getLocalizedMap(locale, (key, l) -&gt;  messageSource.getMessage(key, null, l))</span>
<span class="nc" id="L448">                                .get(encounterClass))</span>
<span class="nc" id="L449">                        .orElseThrow(() -&gt; new IllegalStateException(format(&quot;Cannot build subject for conversation ID=[{%d}]&quot;, actualConversation.getId())));</span>
            }
        }

<span class="fc" id="L453">        return subject;</span>
    }

    private void checkForMissingSubjectAndContent(Message currentMessage) {
<span class="fc" id="L457">        String subject = currentMessage.getSubject();</span>
<span class="fc" id="L458">        String content = currentMessage.getContent();</span>
<span class="pc bpc" id="L459" title="2 of 4 branches missed.">        boolean subjectOrContentIsMissing = StringUtils.isBlank(subject) || StringUtils.isBlank(content);</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (subjectOrContentIsMissing) {</span>
<span class="nc" id="L461">            String exception = format(&quot;PHR-9900: message with id %s entered %s is missing subject and/or content (subject is null=%b, subject is blank=%b&quot; +</span>
                            &quot;, content is null=%b, content is blank=%b)&quot;,
<span class="nc" id="L463">                    currentMessage.getId(),</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                    currentMessage.getBaseFields().getEnteredDate(),</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                    subject == null,</span>
<span class="nc bnc" id="L466" title="All 4 branches missed.">                    subject != null &amp;&amp; subject.isBlank(),</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                    content == null,</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                    content != null &amp;&amp; content.isBlank());</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (config.isExceptionForMissingSubjectAndContentEnabled()) {</span>
<span class="nc" id="L470">                throw new IllegalStateException(exception);</span>
            } else {
<span class="nc" id="L472">                LOGGER.error(exception);</span>
            }
        }
<span class="fc" id="L475">    }</span>

    /*
     * Sets any privacy flags which are used in any of the DTOs onto the first message in the conversation
     * This is used for the GUI to display the aggregated set of privacy flags in the discussion header
     */
    private void setPrivacyFlagsOnFirstMessage(List&lt;IBaseDTO&gt; baseDTOs, @Nullable Message firstMessage) {
<span class="pc bpc" id="L482" title="1 of 4 branches missed.">        if (firstMessage != null &amp;&amp; firstMessage.shouldPrivacyFlagsRollUp()) {</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            for (IBaseDTO m : baseDTOs) {</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                if (m.getBaseFields().isGeneralHealthConsentRequired()) {</span>
<span class="fc" id="L485">                    firstMessage.getBaseFields().setGeneralHealthConsentRequired(true);</span>
                }
<span class="fc bfc" id="L487" title="All 2 branches covered.">                if (m.getBaseFields().isMentalHealthConsentRequired()) {</span>
<span class="fc" id="L488">                    firstMessage.getBaseFields().setMentalHealthConsentRequired(true);</span>
                }
<span class="fc bfc" id="L490" title="All 2 branches covered.">                if (m.getBaseFields().isSexualHealthConsentRequired()) {</span>
<span class="fc" id="L491">                    firstMessage.getBaseFields().setSexualHealthConsentRequired(true);</span>
                }
<span class="fc bfc" id="L493" title="All 2 branches covered.">                if (m.getBaseFields().isSocialCareConsentRequired()) {</span>
<span class="fc" id="L494">                    firstMessage.getBaseFields().setSocialCareConsentRequired(true);</span>
                }
<span class="fc" id="L496">            }</span>
        }
<span class="fc" id="L498">    }</span>

    private void markAsReadAllUnreadMessages(EHRRequestContext requestContext, List&lt;Message&gt; allMessages, Long accountId) {
        // get only messages that have not been read
<span class="fc" id="L502">        List&lt;Message&gt; allUnreadMessages = allMessages.stream()</span>
<span class="fc" id="L503">                .filter(Message::isUnRead)</span>
<span class="fc" id="L504">                .collect(toList());</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (!allUnreadMessages.isEmpty()) {</span>
<span class="fc" id="L507">            encounterManager.transactional(() -&gt; allUnreadMessages.forEach(message -&gt; {</span>
<span class="fc" id="L508">                encounterManager.saveMessageAsRead(requestContext, accountId, message);</span>
<span class="fc" id="L509">            }));</span>
        }
<span class="fc" id="L511">    }</span>

    private String extractInitialSubject(List&lt;Message&gt; messages) {
<span class="fc" id="L514">        String initialSubject = null;</span>
        // XXX why not use conversation.getLatestMessage() or conversation.getFirstMessage()? Check why not before updating.
<span class="pc bpc" id="L516" title="2 of 4 branches missed.">        if ((messages != null) &amp;&amp; !messages.isEmpty()) {</span>
<span class="fc" id="L517">            Message m = messages.get(messages.size() - 1);</span>
<span class="fc" id="L518">            initialSubject = m.getSubject(); // this is latestMessage subject</span>
<span class="pc bpc" id="L519" title="3 of 4 branches missed.">            if (isBlank(initialSubject) &amp;&amp; (messages.size() &gt; 1)) {</span>
<span class="nc" id="L520">                initialSubject = messages.get(0).getSubject(); // try firstMessage subject</span>
            }
        }
<span class="fc" id="L523">        return initialSubject;</span>
    }

    private String getOtherUserId(List&lt;Message&gt; messages, Long thisUserId) {
<span class="pc bpc" id="L527" title="2 of 4 branches missed.">        if ((messages != null) &amp;&amp; !messages.isEmpty()) {</span>
<span class="fc" id="L528">            Message m = messages.get(0);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            if (thisUserId.toString().equals(m.getReceiverId())) {</span>
<span class="fc" id="L530">                return m.getSenderId();</span>
            } else {
<span class="nc" id="L532">                return m.getReceiverId();</span>
            }
        } else {
<span class="nc" id="L535">            return null;</span>
        }
    }

    private boolean isParticipant(String participantId) {
        // Ugh - somewhere a null String is becoming the String &quot;null&quot;
<span class="pc bpc" id="L541" title="2 of 4 branches missed.">        return isNotBlank(participantId) &amp;&amp; !participantId.equals(&quot;null&quot;);</span>
    }

    private List&lt;PKBMessageDTO&gt; buildMessageDTOs(LoggedInEHRRequestContext loggedInContext, List&lt;DataWithUIPermissions&lt;Message&gt;&gt; messages, List&lt;PKBPerson&gt; participants,
                                                 PKBPerson loggedInUser, String aboutPatientId, Locale locale) {
<span class="fc" id="L546">        Map&lt;DataWithUIPermissions&lt;Message&gt;, ReferenceDataManager.RefDatumOrgAndData&gt; messagesToRefDatumMap = referenceDataManager.getReferenceDatumMap(messages, m -&gt; m.getData(),</span>
<span class="fc" id="L547">                HOSPITAL_SERVICE, i -&gt; i.getData().getBaseFields().getHospitalServiceCode());</span>

<span class="fc" id="L549">        Map&lt;ReferenceDataManager.RefDatumOrgAndData, String&gt; refDatumOrgAndDataStringMap = referenceDataManager.processReferenceDatumBatch(messagesToRefDatumMap,</span>
<span class="fc" id="L550">                Collections.singletonList(HOSPITAL_SERVICE));</span>

<span class="fc" id="L552">        Map&lt;Long, PKBPerson&gt; participantMap = participants.stream()</span>
<span class="pc" id="L553">                .collect(Collectors.toMap(PKBPerson::getId, pkbPerson -&gt; pkbPerson, (pkbPerson, duplicate) -&gt; pkbPerson));</span>

<span class="fc" id="L555">        Set&lt;Long&gt; onBehalfUserIds = messages.stream()</span>
<span class="fc" id="L556">                .map(DataWithUIPermissions::getData)</span>
<span class="fc" id="L557">                .map(Message::getOnBehalfAuthorId)</span>
<span class="fc" id="L558">                .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L559">                .map(Long::parseLong)</span>
<span class="fc" id="L560">                .collect(toSet());</span>

<span class="fc" id="L562">        Map&lt;Long, PKBPerson&gt; onBehalfPersonMap = userManager.getPKBPersonList(onBehalfUserIds).stream()</span>
<span class="pc" id="L563">                .collect(Collectors.toMap(PKBPerson::getId, pkbPerson -&gt; pkbPerson, (pkbPerson, duplicate) -&gt; pkbPerson));</span>

<span class="fc" id="L565">        List&lt;Message&gt; nonDraftMessages = messagesToRefDatumMap.keySet().stream()</span>
<span class="fc" id="L566">                .map(DataWithUIPermissions::getData)</span>
<span class="fc" id="L567">                .filter(this::notDraftMessage)</span>
<span class="fc" id="L568">                .collect(toList());</span>

<span class="fc" id="L570">        Set&lt;Long&gt; nonParticipantSenderIds = nonDraftMessages.stream()</span>
<span class="fc" id="L571">                .map(Message::getSenderId)</span>
<span class="fc" id="L572">                .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L573">                .map(Long::parseLong)</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                .filter(ids -&gt; !participantMap.containsKey(ids))</span>
<span class="fc" id="L575">                .collect(toSet());</span>

<span class="fc" id="L577">        Set&lt;Long&gt; idsForIdentityVerification = Streams.concat(nonParticipantSenderIds.stream(), participants.stream().map(PKBPerson::getId)).collect(toSet());</span>

<span class="fc" id="L579">        Map&lt;Long, PKBPerson&gt; notParticipantSenders = userManager.getPKBPersonList(nonParticipantSenderIds).stream()</span>
<span class="pc" id="L580">                .collect(Collectors.toMap(PKBPerson::getId, pkbPerson -&gt; pkbPerson, (pkbPerson, duplicate) -&gt; pkbPerson));</span>

<span class="fc" id="L582">        Map&lt;Long, Boolean&gt; identityVerifications = teamUserManager.areUsersIdentified(idsForIdentityVerification);</span>

<span class="fc" id="L584">        Set&lt;Long&gt; clinicianIds = Streams.concat(participants.stream(), notParticipantSenders.values().stream())</span>
<span class="fc" id="L585">                .filter(AbstractPersonRoles::isPro)</span>
<span class="fc" id="L586">                .map(PKBPerson::getId)</span>
<span class="fc" id="L587">                .collect(toSet());</span>

        //Does not make sense to apply consent rules to the list of clinician teams here - if the messages are already visible
        //then we should show the details of the sender
<span class="fc" id="L591">        Map&lt;Long, Team&gt; clinicianTeams = teamUserManager.getClinicianTeam(loggedInContext.withConsentNotRequired(), clinicianIds);</span>

<span class="fc" id="L593">        Set&lt;Long&gt; teamIds = Sets.newHashSet();</span>
<span class="fc" id="L594">        Set&lt;Long&gt; orgIds = Sets.newHashSet();</span>
<span class="fc" id="L595">        nonDraftMessages.stream()</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                .filter(m -&gt; m.getSenderId() == null)</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                .filter(m -&gt; m.getSource() != null)</span>
<span class="fc" id="L598">                .forEach(m -&gt; {</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                    if (m.getSource().getTeamId() != null) {</span>
<span class="fc" id="L600">                        teamIds.add(m.getSource().getTeamId());</span>
                    }
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                    if (m.getSource().getOrgId() != null) {</span>
<span class="fc" id="L603">                        orgIds.add(m.getSource().getOrgId());</span>
                    }
<span class="fc" id="L605">                });</span>

<span class="fc" id="L607">        Map&lt;Long, Team&gt; teams = teamManager.getTeams(teamIds).stream().collect(Collectors.toMap(Team::getId, Function.identity()));</span>
<span class="fc" id="L608">        Map&lt;Long, Org&gt; orgMap = teamManager.getOrgs(orgIds).stream().collect(Collectors.toMap(Org::getId, Function.identity()));</span>

<span class="fc" id="L610">        List&lt;PKBMessageDTO&gt; messageDTOs = new ArrayList&lt;&gt;(messagesToRefDatumMap.size());</span>
<span class="fc" id="L611">        Map&lt;String, Long&gt; mostRecentMessageByExternalId = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">        for (Map.Entry&lt;DataWithUIPermissions&lt;Message&gt;, ReferenceDataManager.RefDatumOrgAndData&gt; e : messagesToRefDatumMap.entrySet()) {</span>
<span class="fc" id="L613">            DataWithUIPermissions&lt;Message&gt; dataWithUIPermissions = e.getKey();</span>
<span class="fc" id="L614">            Message m = dataWithUIPermissions.getData();</span>
<span class="fc" id="L615">            String extId = m.getExternalMessageId();</span>
<span class="fc" id="L616">            Long currId = mostRecentMessageByExternalId.get(extId);</span>
<span class="fc bfc" id="L617" title="All 4 branches covered.">            if ((currId == null) || (m.getId() &gt; currId)) {</span>
<span class="fc" id="L618">                mostRecentMessageByExternalId.put(extId, m.getId());</span>
            }

<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (notDraftMessage(m)) {</span>
<span class="fc" id="L622">                PKBMessageDTO messageDTO = new PKBMessageDTO();</span>
<span class="fc" id="L623">                messageDTO.setMessage(m);</span>
<span class="fc" id="L624">                messageDTO.setConsistentUniqueId(m.getConsistentUniqueIdOrNull());</span>
<span class="fc" id="L625">                messageDTO.setVisibleToPatientOn(dataDelayService.findWhenBecomesVisibleForUserType(m, loggedInUser.getUserType()).orElse(null));</span>
<span class="fc" id="L626">                messageDTO.setUnread(m.isUnRead());</span>
<span class="fc" id="L627">                messageDTO.setAttachmentList(m.getAttachments());</span>
<span class="fc" id="L628">                messageDTO.setEditConsentUrl(messageActionItemBuilder.entityToDto(dataWithUIPermissions, ImmutableEntityDependency.&lt;PKBMessageDTO&gt;builder()</span>
<span class="fc" id="L629">                        .locale(locale)</span>
<span class="fc" id="L630">                        .loggedInRequestContext(loggedInContext)</span>
<span class="fc" id="L631">                        .build()));</span>
<span class="fc" id="L632">                PKBPerson sender = null;</span>
<span class="fc" id="L633">                String senderId = m.getSenderId();</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                if (isNotBlank(senderId)) {</span>
<span class="fc" id="L635">                    Long senderIdLong = Long.parseLong(senderId);</span>
<span class="fc" id="L636">                    sender = participantMap.getOrDefault(senderIdLong, notParticipantSenders.get(senderIdLong));</span>
                }

<span class="pc bpc" id="L639" title="1 of 2 branches missed.">                if (isNotBlank(m.getOnBehalfAuthorId())) {</span>
<span class="nc" id="L640">                    messageDTO.setOnBehalfAuthor(personDTOConverter.convert(onBehalfPersonMap.get(Long.parseLong(m.getOnBehalfAuthorId()))));</span>
                }

<span class="fc" id="L643">                messageDTO.setSender(personDTOConverter.convert(sender));</span>
<span class="fc bfc" id="L644" title="All 4 branches covered.">                boolean senderActivated = (sender != null) &amp;&amp; identityVerifications.getOrDefault(sender.getId(), false);</span>
<span class="fc" id="L645">                messageDTO.setSenderActivated(senderActivated);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">                if (sender == null) {</span>
                    // probably an HL7 message ; get the team/org from the source
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">                    if (m.getSource() != null) {</span>
<span class="fc" id="L649">                        Long teamId = m.getSource().getTeamId();</span>
<span class="fc" id="L650">                        Long orgId = m.getSource().getOrgId();</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">                        if (teamId != null) {</span>
<span class="fc" id="L652">                            messageDTO.setSenderTeam(teams.get(m.getSource().getTeamId()));</span>
                        }
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                        if (orgId != null) {</span>
<span class="fc" id="L655">                            messageDTO.setSenderOrg(orgMap.get(orgId));</span>
                        }
                    }

<span class="fc" id="L659">                    String specialtyText = m.getBaseFields().getHospitalServiceCode();</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">                    if (isNotBlank(specialtyText)) {</span>
<span class="fc" id="L661">                        Long orgId = m.getSource().getOrgId();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">                        if (orgId != null) {</span>
<span class="fc" id="L663">                            specialtyText = refDatumOrgAndDataStringMap.getOrDefault(e.getValue(), specialtyText);</span>
                        }
<span class="fc" id="L665">                        messageDTO.setSpecialty(specialtyText);</span>
                    }
<span class="fc" id="L667">                } else {</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">                    if (sender.isPro()) {</span>
<span class="fc" id="L669">                        Team senderTeam = clinicianTeams.get(sender.getId());</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                        if (senderTeam != null) {</span>
<span class="fc" id="L671">                            messageDTO.setSenderTeam(senderTeam);</span>
                        } else {
<span class="fc" id="L673">                            messageDTO.setSenderIsIndividualProfessional(true);</span>
                        }
<span class="fc" id="L675">                    } else {</span>
<span class="pc bpc" id="L676" title="1 of 4 branches missed.">                        boolean senderIsCarer = isNotEmpty(aboutPatientId) &amp;&amp; !aboutPatientId.equals(sender.getId().toString());</span>
<span class="fc" id="L677">                        messageDTO.setSenderIsCarer(senderIsCarer);</span>
                    }
                }

                // filters participantsNonPKB for empty values
<span class="fc" id="L682">                m.setParticipantsNonPKB(participantBuilder.filterParticipantsNonPKB(m.getParticipantsNonPKB()));</span>

<span class="pc" id="L684">                List&lt;MessagingPKBPersonDTO&gt; failedReceivers = findFailedReceiver(m.getFailedReceivers(), participantMap).stream().map(person -&gt; personDTOConverter.convert(person)).collect(Collectors.toList());</span>
<span class="fc" id="L685">                messageDTO.setFailedReceivers(failedReceivers);</span>
<span class="fc" id="L686">                dataWithUIPermissions.copyPermissionsInto(messageDTO);</span>
<span class="fc" id="L687">                messageDTOs.add(messageDTO);</span>
            }
<span class="fc" id="L689">        }</span>

        // XXX This is only for documents that are being displayed in Discussion threads - not compatible with ADT Encounters or normal clinician/patient messages - remove/fix this
<span class="fc bfc" id="L692" title="All 2 branches covered.">        for (PKBMessageDTO m : messageDTOs) {</span>
<span class="fc" id="L693">            String externalId = m.getMessage().getExternalMessageId();</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">            if (isNotBlank(externalId)) {</span>
<span class="fc" id="L695">                Long mId = m.getMessage().getId();</span>
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">                if (!mId.equals(mostRecentMessageByExternalId.get(externalId))) {</span>
<span class="nc" id="L697">                    m.setSuperseded(true);</span>
                }
            }
<span class="fc" id="L700">        }</span>

<span class="fc" id="L702">        return messageDTOs;</span>
    }

    private boolean notDraftMessage(Message m) {
<span class="pc bpc" id="L706" title="1 of 4 branches missed.">        return (m.getMessageStatus() != null) &amp;&amp; !m.isDraft();</span>
    }

    private List&lt;PKBPerson&gt; findFailedReceiver(List&lt;String&gt; failedReceiverIds, Map&lt;Long, PKBPerson&gt; participantMap) {
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        if (CollectionUtils.isEmpty(failedReceiverIds)) {</span>
<span class="fc" id="L711">            return emptyList();</span>
        }
<span class="nc" id="L713">        return failedReceiverIds.stream()</span>
<span class="nc" id="L714">                .map(stringId -&gt; participantMap.get(Long.parseLong(stringId)))</span>
<span class="nc" id="L715">                .filter(Objects::nonNull).collect(toList());</span>
    }

    private BiFunction&lt;String, String[], String&gt; getText(Locale locale) {
<span class="fc" id="L719">        return (key, args) -&gt; messageSource.getMessage(key, args, locale);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>