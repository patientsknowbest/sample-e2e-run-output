<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccountTaskService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.backgroundtasks.service</a> &gt; <span class="el_source">AccountTaskService.kt</span></div><h1>AccountTaskService.kt</h1><pre class="source lang-java linenums">package com.pkb.backgroundtasks.service

import com.google.common.util.concurrent.Striped
import com.pkb.backgroundtasks.AccountPrivateId
import com.pkb.backgroundtasks.AccountPublicId
import com.pkb.backgroundtasks.config.BackgroundTasksProperties
import com.pkb.backgroundtasks.entity.AccountTaskCommon
import com.pkb.backgroundtasks.entity.AccountTaskDetails
import com.pkb.backgroundtasks.entity.AccountTaskPending
import com.pkb.backgroundtasks.projection.TaskStatus
import com.pkb.backgroundtasks.repository.AccountRepository
import com.pkb.backgroundtasks.repository.AccountTaskCompleteRepository
import com.pkb.backgroundtasks.repository.AccountTaskPendingRepository
import com.pkb.backgroundtasks.repository.ReactiveAccountTaskPendingRepository
import com.pkb.backgroundtasks.routing.KeyAvailableRouteBuilder
import com.pkb.backgroundtasks.service.taskexecutors.TaskExecutorRegistry
import com.pkb.backgroundtasks.util.RequestIdUtil
import com.pkb.crypto.dto.AccountKeysDTO
import com.pkb.kms.client.core.Kms
import com.pkb.kms.shared.structures.pubsub.KeyAvailable
import io.micrometer.core.instrument.MeterRegistry
import io.micrometer.core.instrument.Timer
import io.vavr.Tuple
import org.apache.camel.Consume
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.data.domain.Sort
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Service
import reactor.core.publisher.Mono
import java.lang.invoke.MethodHandles
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean

/**
 * This class implements a basic framework for handling tasks to perform on a patient account that require crypto access.
 * It is currently quite naive. This system is only &quot;cluster-safe&quot; on the assumption that there's a single instance
 * of the background tasks application running. If we need to cluster this application - as we may well have to at
 * some point in the future - then we need to move the accountLocks into the database or some other shared storage,
 * which will significantly complicate the implementation.
 */
<span class="fc" id="L42">@Service</span>
<span class="fc" id="L43">class AccountTaskService(</span>
<span class="fc" id="L44">    private val transactionalService: TransactionalAccountTaskService,</span>
<span class="fc" id="L45">    private val pendingRepo: AccountTaskPendingRepository,</span>
<span class="fc" id="L46">    private val reactivePendingRepo: ReactiveAccountTaskPendingRepository,</span>
<span class="fc" id="L47">    private val completeRepo: AccountTaskCompleteRepository,</span>
<span class="fc" id="L48">    private val accountRepo: AccountRepository,</span>
<span class="fc" id="L49">    private val kms: Kms,</span>
<span class="fc" id="L50">    private val taskExecutors: TaskExecutorRegistry,</span>
<span class="fc" id="L51">    private val properties: BackgroundTasksProperties,</span>
<span class="fc" id="L52">    private val meterRegistry: MeterRegistry,</span>
<span class="fc" id="L53">    private val requestIdUtil: RequestIdUtil</span>
) {

<span class="fc" id="L56">    private val accountLocks = Striped.lock(properties.accountTasks.pageSize * 10)</span>

    /**
     * As noted in the class comment, this class currently relies on the assumption that
     * only one instance of the main task loop will be executing at once. This AtomicBoolean
     * is used to enforce that, but obviously this only works on the assumption that
     * there's only one instance of this service running at a time. For the being that seems
     * like a reasonable assumption - it's a lightweight service that delegates most of the real
     * work to other services so there's no real need to parallelise. We may need to revisit this
     * if we need to run multiple instances for reliability or to support rolling releases
     */
<span class="fc" id="L67">    private var mainTaskLoopRunning: AtomicBoolean = AtomicBoolean(false)</span>

<span class="fc" id="L69">    private val log: Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())</span>

    //Run once on startup deleting key-not-available records to ensure
    //we retry all previously unavailable keys
    //Prefering this slightly hacky @Scheduled solution over @PostConstruct because it
    //makes testing a lot easier. Scheduled is fairly easy to disable, PostConstruct isn't
    @Scheduled(fixedDelay = Long.MAX_VALUE, initialDelay = 0)
    fun triggerAllPendingTasks() {
<span class="fc" id="L77">        log.debug(&quot;Being triggered for all tasks&quot;)</span>
<span class="fc" id="L78">        runTaskLoopInternal(true).block()</span>
<span class="fc" id="L79">    }</span>

    //Subsequently only run new tasks, don't retry missing keys. New keys
    //will be notified via pub-sub and will bypass this loop
    @Scheduled(
        fixedRateString = &quot;#{@backgroundTasksProperties.props.accountTasks.loopRateMs}&quot;,
        initialDelayString = &quot;#{@backgroundTasksProperties.props.accountTasks.loopRateMs}&quot;
    )
<span class="nc" id="L87">    fun runTaskLoop() = runTaskLoopInternal(false).block()</span>


    @Consume(KeyAvailableRouteBuilder.INBOUND_ACCOUNT_KEY_AVAILABLE_FOR_ACCOUNT_TASKS)
    fun triggerTasks(keyAvailable: KeyAvailable) {
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (!properties.accountTasks.enabled) {</span>
<span class="fc" id="L93">            return</span>
        }

<span class="fc" id="L96">        val accountPublicId = UUID.fromString(keyAvailable.accountPublicId.toString())</span>
<span class="fc" id="L97">        log.debug(&quot;Account key availability triggering tasks for account $accountPublicId&quot;)</span>
<span class="fc" id="L98">        triggerTasks(listOf(accountPublicId))</span>
<span class="fc" id="L99">    }</span>


    fun &lt;T : AccountTaskDetails&lt;*&gt;&gt; enqueueTask(accountPublicId: AccountPublicId, taskDetails: T): UUID {
<span class="fc" id="L103">        return transactionalService.queueTask(AccountTaskPending(UUID.randomUUID(), accountPublicId, taskDetails)).id</span>
    }

    fun triggerTasks(accountPublicId: AccountPublicId): List&lt;TaskStatus&gt; {
<span class="fc" id="L107">        log.debug(&quot;Direct triggering tasks for account $accountPublicId&quot;)</span>
<span class="fc" id="L108">        transactionalService.deleteAccountWithoutKeyRecordForAccount(accountPublicId)</span>
<span class="fc" id="L109">        triggerTasks(listOf(accountPublicId))</span>
<span class="fc" id="L110">        return getTaskStatuses(accountPublicId)</span>
    }

    /**
     * Warning: does exactly what it says on the tin: don't use this outside of testing
     */
    @Suppress(&quot;FunctionName&quot;)
    fun TEST_ONLY_deleteAllTasks() {
<span class="fc" id="L118">        transactionalService.deleteAllTasks()</span>
<span class="fc" id="L119">    }</span>

    @Suppress(&quot;FunctionName&quot;)
    fun TEST_ONLY_deleteTasksFor(accountPublicId: AccountPublicId) {
<span class="fc" id="L123">        transactionalService.deleteTasksFor(accountPublicId)</span>
<span class="fc" id="L124">    }</span>

    fun getTaskStatuses(accountPublicId: AccountPublicId): List&lt;TaskStatus&gt; =
<span class="fc" id="L127">        (completeRepo.getAllByAccountPublicIdOrderByCreatedDateAscTaskCreatedDateAsc(accountPublicId)</span>
<span class="fc" id="L128">                + pendingRepo.getByAccountPublicIdOrderByCreatedDateAsc(accountPublicId))</span>
<span class="fc" id="L129">            .map(AccountTaskCommon::toTaskStatus)</span>

    @Suppress(&quot;FunctionName&quot;)
    fun TEST_ONLY_getAllTaskStatuses()  =
<span class="fc" id="L133">        (completeRepo.findAll(Sort.by(&quot;createdDate&quot;, &quot;taskCreatedDate&quot;))</span>
<span class="fc" id="L134">                + pendingRepo.findAll(Sort.by(&quot;createdDate&quot;)))</span>
<span class="fc" id="L135">            .groupBy(AccountTaskCommon::accountPublicId, AccountTaskCommon::toTaskStatus)</span>

    private fun runTaskLoopInternal(deleteMissingKeyRecords: Boolean): Mono&lt;Void&gt; {
<span class="pc bpc" id="L138" title="1 of 4 branches missed.">        if (!properties.accountTasks.enabled || !mainTaskLoopRunning.compareAndSet(false, true)) {</span>
<span class="fc" id="L139">            return Mono.empty()</span>
        }

<span class="fc" id="L142">        try {</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (deleteMissingKeyRecords) {</span>
<span class="fc" id="L144">                transactionalService.deleteAllAccountWithoutKeyRecords()</span>
            }

<span class="fc" id="L147">            log.info(&quot;Starting accounts task backlog&quot;)</span>

<span class="fc" id="L149">            return reactivePendingRepo.getAccountsToFix(properties.accountTasks.disabledTasks)</span>
<span class="fc" id="L150">                .buffer(properties.accountTasks.pageSize)</span>
<span class="fc" id="L151">                .map(this::triggerTasks)</span>
<span class="fc" id="L152">                .doOnComplete{</span>
<span class="fc" id="L153">                    log.info(&quot;Accounts task backlog finished&quot;)</span>
<span class="fc" id="L154">                }</span>
<span class="fc" id="L155">                .doFinally{ mainTaskLoopRunning.set(false)}</span>
<span class="fc" id="L156">                .then()</span>


<span class="nc" id="L159">        } catch (err: Exception) {</span>
<span class="nc" id="L160">            mainTaskLoopRunning.set(false)</span>
<span class="nc" id="L161">            throw err</span>
        }
    }



    fun triggerTasks(accountsWithPendingTasks: List&lt;AccountPublicId&gt;) {
<span class="fc" id="L168">        try {</span>
<span class="fc" id="L169">            val requestId = requestIdUtil.getRequestId()</span>
<span class="fc" id="L170">            log.debug(&quot;Account batch for task execution {}&quot;, accountsWithPendingTasks)</span>

<span class="fc" id="L172">            accountsWithPendingTasks.sorted().forEach { accountLocks.get(it).lock() }</span>

<span class="fc" id="L174">            val accountIdLookup =</span>
<span class="fc" id="L175">                accountRepo.getAllByPublicIdIn(accountsWithPendingTasks).associate { it.publicId to it.id }</span>

<span class="fc" id="L177">            val accountSortIndices = accountsWithPendingTasks.withIndex().associate { it.value to it.index }</span>


<span class="fc" id="L180">            val pendingTasks = pendingRepo.getAllByAccountPublicIdIn(accountsWithPendingTasks)</span>
<span class="fc" id="L181">                .filter{</span>
<span class="fc" id="L182">                    val taskExecutor = it.getTaskExecutor(taskExecutors)</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                    if (taskExecutor == null) {</span>
<span class="fc" id="L184">                        log.warn(&quot;No task executor found for task ${it.id} of type ${it.type}, skipping&quot;)</span>
                    }
<span class="fc bfc" id="L186" title="All 2 branches covered.">                    taskExecutor != null</span>
                }
<span class="fc" id="L188">                .sortedBy {</span>
                    Tuple.of(
                        accountSortIndices[it.accountPublicId],
                        it.type,
                        it.createdDate
                    )
                }
<span class="fc bfc" id="L195" title="All 2 branches covered.">                .filter { !properties.accountTasks.disabledTasks.contains(it.type) }</span>

<span class="fc" id="L197">            val deduplicated = pendingTasks</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                .runningReduce { prev, curr -&gt; if (curr.duplicates(prev)) prev else curr }</span>
<span class="fc" id="L199">                .toSet()</span>

<span class="fc" id="L201">            val skippable = deduplicated.groupBy { it.getTaskExecutor(taskExecutors)!! }.flatMapTo(mutableSetOf()) { (taskExecutor, tasks) -&gt;</span>
<span class="fc" id="L202">                taskExecutor.getSkippableTasks(tasks, accountIdLookup)</span>
            }
<span class="fc" id="L204">            log.debug(&quot;Skipping tasks that don't need execution: {}&quot;, skippable)</span>


<span class="fc bfc" id="L207" title="All 2 branches covered.">            val keyMap = getKeys(deduplicated.filter { !skippable.contains(it) }, requestId)</span>
<span class="fc" id="L208">            log.debug(&quot;Obtained keys for account tasks: {}&quot;, keyMap)</span>

<span class="fc" id="L210">            pendingTasks.asSequence()</span>
<span class="fc" id="L211">                .map {</span>
<span class="fc" id="L212">                    it to when {</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                        !deduplicated.contains(it) -&gt; TaskResult.DUPLICATE</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                        skippable.contains(it) -&gt; TaskResult.SKIPPED</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">                        !keyMap.containsKey(it.accountPublicId) -&gt; TaskResult.KEY_NOT_AVAILABLE</span>
<span class="fc" id="L216">                        else -&gt; handleTask(it, keyMap[it.accountPublicId]!!, accountIdLookup[it.accountPublicId]!!)</span>
                    }
                }
<span class="fc" id="L219">                .map {</span>
<span class="fc" id="L220">                    meterRegistry.counter(it.second.counterName, TYPE, it.first.type.toString()).increment()</span>
<span class="fc" id="L221">                    it</span>
                }
<span class="fc" id="L223">                .toList()</span>
<span class="fc" id="L224">                .let { transactionalService.recordCompletion(it, requestId) }</span>

<span class="nc" id="L226">        } catch (e: Exception) {</span>
<span class="nc" id="L227">            log.error(&quot;Exception in control flow for account task execution, killing entire batch&quot;, e)</span>
        } finally {
<span class="fc" id="L229">            accountsWithPendingTasks.sorted().forEach { accountLocks.get(it).unlock() }</span>
        }
<span class="fc" id="L231">    }</span>



    private fun getKeys(pendingTasks: List&lt;AccountTaskPending&gt;, requestId: String): Map&lt;AccountPublicId, AccountKeysDTO&gt; =
<span class="fc" id="L236">        kms.getAccountKeysTrustedIgnoreMissing(requestId, pendingTasks.map { it.accountPublicId }.distinct())</span>
<span class="fc" id="L237">            .map { keys -&gt; keys.associate { it.accountPublicId to it } }</span>
<span class="pc" id="L238">            .getOrElseThrow { error -&gt; RuntimeException(error.toString()) }</span>


    private fun handleTask(pendingTasks: AccountTaskPending, accountKeysDTO: AccountKeysDTO, accountPrivateId: AccountPrivateId): TaskResult {
<span class="fc" id="L242">        return try {</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            if (executeTask(pendingTasks, accountKeysDTO, accountPrivateId)) {</span>
<span class="fc" id="L244">                log.debug(&quot;Account task completed: {}&quot;, pendingTasks)</span>
<span class="fc" id="L245">                TaskResult.SUCCESS</span>
            } else {
<span class="nc" id="L247">                log.error(&quot;Account task failed: {}&quot;, pendingTasks)</span>
<span class="pc" id="L248">                TaskResult.FAILURE</span>
            }
<span class="nc" id="L250">        } catch (e: Exception) {</span>
<span class="nc" id="L251">            log.error(&quot;Error performing task ${pendingTasks.id} for account ${pendingTasks.accountPublicId}, &quot;, e)</span>
<span class="pc" id="L252">            TaskResult.FAILURE</span>
        }
    }


    private fun executeTask(pendingTask: AccountTaskPending, accountKeysDTO: AccountKeysDTO, accountPrivateId: AccountPrivateId): Boolean {
<span class="fc" id="L258">        val callable: () -&gt; Boolean = { pendingTask.trigger(taskExecutors, accountKeysDTO, accountPrivateId) }</span>
<span class="fc" id="L259">        log.debug(&quot;Executing task&quot;, pendingTask)</span>
<span class="fc" id="L260">        return timerFor(pendingTask).record(callable)!!</span>
    }


    private fun timerFor(pendingTask: AccountTaskPending) =
<span class="fc" id="L265">        Timer.builder(TASK_TIMER)</span>
<span class="fc" id="L266">            .publishPercentileHistogram()</span>
<span class="fc" id="L267">            .publishPercentiles(0.5, 0.75, 0.9, 0.95, 0.99, 0.999)</span>
<span class="fc" id="L268">            .tags(TYPE, pendingTask.type.toString())</span>
<span class="fc" id="L269">            .register(meterRegistry)</span>


    companion object {
        const val TASK_TIMER = &quot;account_task_timer&quot;
        const val TYPE = &quot;task_type&quot;
    }
}


<span class="fc" id="L279">enum class TaskResult(internal val counterName: String) {</span>
<span class="fc" id="L280">    SUCCESS(&quot;account_tasks_succeeded&quot;),</span>
<span class="fc" id="L281">    FAILURE(&quot;account_tasks_failed&quot;),</span>
<span class="fc" id="L282">    SKIPPED(&quot;account_tasks_skippable&quot;),</span>
<span class="fc" id="L283">    KEY_NOT_AVAILABLE(&quot;account_tasks_missing_keys&quot;),</span>
<span class="fc" id="L284">    DUPLICATE(&quot;account_tasks_duplicate&quot;)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>