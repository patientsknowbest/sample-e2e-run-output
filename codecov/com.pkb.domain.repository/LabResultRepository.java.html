<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LabResultRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.domain.repository</a> &gt; <span class="el_source">LabResultRepository.java</span></div><h1>LabResultRepository.java</h1><pre class="source lang-java linenums">package com.pkb.domain.repository;

import com.pkb.authz.data.AuthorizationData;
import com.pkb.datamodel.LabResult;
import com.pkb.datamodel.entity.mapper.LabResultMapper;
import com.pkb.domain.criteria.LowerBound;
import com.pkb.domain.criteria.ResultFilter;
import com.pkb.domain.criteria.TemporalRangeRestriction;
import com.pkb.domain.criteria.UpperBound;
import com.pkb.domain.internal.repository.AbstractMenuDataRepository;
import com.pkb.domain.internal.repository.AppMenuDataRepository;
import com.pkb.domain.internal.repository.ReferenceDatumRepository;
import com.pkb.domain.repository.mapper.AccessFilterMapper;
import com.pkb.ehrdata.AccessFilter;
import com.pkb.ehrdata.ImmutableOneResultPerDay;
import com.pkb.ehrdata.ImmutableOrderBy;
import com.pkb.ehrdata.ImmutablePageFilter;
import com.pkb.ehrdata.ImmutableSearchSpec;
import com.pkb.ehrdata.OrderBy;
import com.pkb.ehrdata.SearchSpec;
import com.pkb.entities.enums.MenuDataType;
import io.vavr.Tuple2;
import io.vavr.collection.List;
import io.vavr.control.Option;
import org.jetbrains.annotations.NotNull;

import java.time.LocalDate;
import java.util.Optional;

import static com.pkb.annotation.EHRField.QueryField.date01;
import static com.pkb.domain.criteria.ResultFilter.ONE_PER_DAY;
import static com.pkb.ehrdata.Filter.Operator.GREATER_OR_EQUAL;
import static com.pkb.ehrdata.Filter.Operator.LESS;
import static com.pkb.ehrdata.Filter.filter;
import static com.pkb.ehrdata.LatestFilterFields.defaultLatestFields;
import static io.vavr.API.List;
import static io.vavr.API.Tuple;
import static java.lang.String.format;

public class LabResultRepository extends AbstractMenuDataRepository {
    private final LabResultMapper mapper;
    private final AccessFilterMapper accessFilterMapper;

    public LabResultRepository(LabResultMapper mapper,
                               AccessFilterMapper accessFilterMapper,
                               AppMenuDataRepository menuDataRepository,
                               ReferenceDatumRepository referenceDatumRepository,
                               PersonRepository personRepository) {
<span class="fc" id="L49">        super(menuDataRepository, referenceDatumRepository, personRepository);</span>
<span class="fc" id="L50">        this.mapper = mapper;</span>
<span class="fc" id="L51">        this.accessFilterMapper = accessFilterMapper;</span>
<span class="fc" id="L52">    }</span>

    public List&lt;LabResult&gt; findBy(@NotNull LabResultQuery query, int pageSize) {
<span class="fc" id="L55">        Tuple2&lt;SearchSpec, AccessFilter&gt; accessFilterAndSearchSpec = getSearchSpecAndAccessFilter(query, pageSize);</span>
<span class="fc" id="L56">        List&lt;Long&gt; ids = find(accessFilterAndSearchSpec._1, accessFilterAndSearchSpec._2);</span>

<span class="fc bfc" id="L58" title="All 2 branches covered.">        return ids.isEmpty() ?</span>
<span class="fc" id="L59">                List() :</span>
<span class="fc" id="L60">                mapper.menuDataToLabResults(findMenuDatasByIds(ids));</span>
    }

    public Long count(@NotNull LabResultQuery query) {
<span class="fc" id="L64">        Tuple2&lt;SearchSpec, AccessFilter&gt; accessFilterAndSearchSpec = getSearchSpecAndAccessFilter(query, null);</span>
<span class="fc" id="L65">        return count(accessFilterAndSearchSpec._1, accessFilterAndSearchSpec._2);</span>
    }

    private Tuple2&lt;SearchSpec, AccessFilter&gt; getSearchSpecAndAccessFilter(LabResultQuery query, Integer pageSize) {
<span class="fc" id="L69">        AuthorizationData authzData = query.authData();</span>
<span class="fc" id="L70">        return Tuple(</span>
<span class="fc" id="L71">                populateSearchSpec(authzData.requireSingleTargetData().account().getId(),</span>
<span class="fc" id="L72">                        query.getEffectiveTimestamp(),</span>
<span class="fc" id="L73">                        query.resultFilter(),</span>
<span class="fc" id="L74">                        Option.of(pageSize)),</span>
<span class="fc" id="L75">                accessFilterMapper.buildAccessFilter(authzData)</span>
        );
    }
    private SearchSpec populateSearchSpec(long accountId,
                                          TemporalRangeRestriction&lt;LocalDate&gt; effectiveTimestamp,
                                          ResultFilter resultFilter,
                                          Option&lt;Integer&gt; maybePageSize) {
<span class="fc" id="L82">        ImmutableSearchSpec.Builder searchSpec = ImmutableSearchSpec.builder()</span>
<span class="fc" id="L83">                .addAccountId(accountId)</span>
<span class="fc" id="L84">                .addDataType(MenuDataType.loincTestResult.name())</span>
<span class="fc" id="L85">                .pageFilter(maybePageSize.map(pageSize -&gt; ImmutablePageFilter.builder()</span>
<span class="fc" id="L86">                        .startPosition(0)</span>
<span class="fc" id="L87">                        .count(pageSize)</span>
<span class="fc" id="L88">                        .build()).toJavaOptional())</span>
<span class="fc" id="L89">                .latestFilter(defaultLatestFields())</span>
<span class="fc" id="L90">                .orderBy(ImmutableOrderBy.builder()</span>
<span class="fc" id="L91">                        .direction(OrderBy.Direction.Asc)</span>
<span class="fc" id="L92">                        .field(date01.name())</span>
<span class="fc" id="L93">                        .build())</span>
<span class="fc" id="L94">                .oneResultPerDay(</span>
<span class="fc" id="L95">                        Optional.ofNullable(</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">                                resultFilter == ONE_PER_DAY ? ImmutableOneResultPerDay.builder().fieldName(&quot;date01&quot;).build() : null));</span>
        // example date for the effective timestamp filtering: 08.11.2018

<span class="fc" id="L99">        effectiveTimestamp.getLowerBound().peek(filter -&gt; {</span>
<span class="fc" id="L100">            LocalDate value = filter.getValue();</span>
<span class="fc" id="L101">            LowerBound constraint = filter.getConstraint();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (constraint == LowerBound.GREATER) { // [09.11.2018 00:00, ∞ ]</span>
<span class="fc" id="L103">                searchSpec.addFilter(filter(date01.name(), GREATER_OR_EQUAL, value.plusDays(1).atStartOfDay()));</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">            } else if (constraint == LowerBound.GREATER_OR_EQUAL) { // [08.11.2018 00:00, ∞ ]</span>
<span class="fc" id="L105">                searchSpec.addFilter(filter(date01.name(), GREATER_OR_EQUAL, value.atStartOfDay()));</span>
            } else {
<span class="nc" id="L107">                throw new RuntimeException(format(&quot;Unsupported lower bound constraint [%s]&quot;, constraint.name()));</span>
            }
<span class="fc" id="L109">        });</span>
<span class="fc" id="L110">        effectiveTimestamp.getUpperBound().peek(filter -&gt; {</span>
<span class="fc" id="L111">            LocalDate value = filter.getValue();</span>
<span class="fc" id="L112">            UpperBound constraint = filter.getConstraint();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">            if (constraint == UpperBound.LESS) { // [∞ , 08.11.2018 00:00)</span>
<span class="fc" id="L114">                searchSpec.addFilter(filter(date01.name(), LESS, value.atStartOfDay()));</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            } else if (constraint == UpperBound.LESS_OR_EQUAL) { // [∞ , 09.11.2018 00:00)</span>
<span class="fc" id="L116">                searchSpec.addFilter(filter(date01.name(), LESS, value.plusDays(1).atStartOfDay()));</span>
            } else {
<span class="nc" id="L118">                throw new RuntimeException(format(&quot;Unsupported upper bound constraint [%s]&quot;, constraint.name()));</span>
            }
<span class="fc" id="L120">        });</span>

<span class="fc" id="L122">        return searchSpec.build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>