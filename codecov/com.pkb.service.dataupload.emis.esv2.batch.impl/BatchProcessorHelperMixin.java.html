<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BatchProcessorHelperMixin.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.dataupload.emis.esv2.batch.impl</a> &gt; <span class="el_source">BatchProcessorHelperMixin.java</span></div><h1>BatchProcessorHelperMixin.java</h1><pre class="source lang-java linenums">package com.pkb.service.dataupload.emis.esv2.batch.impl;

import com.pkb.coding.entity.CodeableConcept;
import com.pkb.coding.entity.Coding;
import com.pkb.coding.entity.CodingReceived;
import com.pkb.common.config.PhrConfig;
import com.pkb.entities.enums.OrgExternalIdType;
import com.pkb.entities.enums.Route;
import com.pkb.exception.ConflictingPatientIdentifiersException;
import com.pkb.exception.MultiplePatientSameIdentifierException;
import com.pkb.institute.OrgMergeHelper;
import com.pkb.institute.entity.Org;
import com.pkb.service.dataupload.emis.esv2.CodeSystems;
import com.pkb.service.dataupload.emis.esv2.EmisPersonStatHelper;
import com.pkb.service.dataupload.emis.esv2.batch.EmisRequestContextProvider;
import com.pkb.service.dataupload.emis.esv2.batch.FileProcessor;
import com.pkb.service.dataupload.emis.esv2.model.AdminPatient;
import com.pkb.service.dataupload.emis.esv2.model.AdminUserInRole;
import com.pkb.service.dataupload.emis.esv2.model.BaseEmisEsDomainModel;
import com.pkb.service.dataupload.emis.esv2.model.CodingClinicalCode;
import com.pkb.service.dataupload.emis.esv2.model.CodingDrugCode;
import com.pkb.service.dataupload.emis.esv2.model.CodingWrapper;
import com.pkb.service.dataupload.emis.esv2.model.EmisPatientDataPoint;
import com.pkb.service.dataupload.emis.esv2.model.ImmutableCodingWrapper;
import com.pkb.service.dataupload.emis.esv2.model.PKBPersonInfo;
import com.pkb.service.dataupload.emis.esv2.model.PrescribingDrugRecord;
import com.pkb.service.user.impl.UserManager;
import io.vavr.Function1;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.Tuple3;
import io.vavr.collection.HashMap;
import io.vavr.collection.Map;
import io.vavr.collection.Set;
import io.vavr.collection.Traversable;
import io.vavr.control.Either;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.List;
import java.util.Optional;

import static com.pkb.service.dataupload.emis.esv2.batch.impl.ProcessingError.Severity.FATAL;
import static com.pkb.service.dataupload.emis.esv2.batch.impl.ProcessingError.Severity.NON_FATAL;
import static java.util.stream.Collectors.toSet;

interface BatchProcessorHelperMixin&lt;T extends EmisPatientDataPoint&gt; extends EmisRequestContextProvider, FileProcessor&lt;T&gt; {

<span class="fc" id="L53">    Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    /**
     * Fetch adminUserInRole records for the given drug records
     *
     * @param recordToOrg Records and corresponding PKB org
     * @return Map of drug record to corresponding adminUserInRoles, that could be nulls.
     */
    default Map&lt;T, AdminUserInRole&gt; fetchAdminUserInRolesTimed(Map&lt;T, Org&gt; recordToOrg, Function1&lt;T, Optional&lt;String&gt;&gt; enteredByGuidExtractor) {
<span class="fc" id="L62">        return recordTime(&quot;adminUserInRoles&quot;, () -&gt; fetchAdminUserInRoles(recordToOrg, enteredByGuidExtractor));</span>
    }

    private Map&lt;T, AdminUserInRole&gt; fetchAdminUserInRoles(Map&lt;T, Org&gt; recordToOrg, Function1&lt;T, Optional&lt;String&gt;&gt; enteredByGuidExtractor) {
<span class="fc" id="L66">        var recordLookup = getKeyWithOrgCollection(recordToOrg, enteredByGuidExtractor);</span>
<span class="fc" id="L67">        var adminUserInRoles = getEmisEsManager().lookupAdminUserInRole(recordLookup);</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">        return recordToOrg.map((k, v) -&gt; Tuple.of(k, getAdminUserInRole(adminUserInRoles, k, enteredByGuidExtractor).orElse(null))).filter(t -&gt; t._2 != null);</span>
    }

    private List&lt;Tuple2&lt;String, Org&gt;&gt; getKeyWithOrgCollection(Map&lt;T, Org&gt; recordToOrg, Function1&lt;T, Optional&lt;String&gt;&gt; enteredByGuidExtractor) {
<span class="fc" id="L73">        return recordToOrg.map(r -&gt; Tuple.of(enteredByGuidExtractor.apply(r._1).map(StringUtils::trimToNull).orElse(null), r._2))</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                .filter(t -&gt; t._1 != null)</span>
<span class="fc" id="L75">                .distinct()</span>
<span class="fc" id="L76">                .toJavaList();</span>
    }

    private Optional&lt;AdminUserInRole&gt; getAdminUserInRole(java.util.Map&lt;String, AdminUserInRole&gt; map, T record, Function1&lt;T, Optional&lt;String&gt;&gt; enteredByGuidExtractor) {
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        return enteredByGuidExtractor.apply(record).map(StringUtils::trimToNull).filter(guid -&gt; guid != null).map(guid -&gt; map.get(guid));</span>
    }

    default &lt;I extends BaseEmisEsDomainModel, V&gt; Either&lt;ProcessingError&lt;I&gt;, V&gt; processingError(I t, ProcessingError.Severity severity, String message, Object... parameters) {
<span class="fc" id="L84">        return Either.left(new ProcessingError&lt;&gt;(t, severity, message, parameters));</span>
    }

    /**
     * @return a map from prescribingDrugRecord's drugRecordGuid to
     * - either an adminPatient
     * - or a reason that describes why an adminPatient could not be found
     */
    default Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, AdminPatient&gt;&gt; fetchAdminPatientsTimed(Map&lt;T, OrgMergeHelper&gt; recordToOrg) {
<span class="fc" id="L93">        return recordTime(&quot;adminPatientsOrFailures&quot;, () -&gt; fetchAdminPatients(recordToOrg));</span>
    }

    private Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, AdminPatient&gt;&gt; fetchAdminPatients(Map&lt;T, OrgMergeHelper&gt; recordToOrg) {

<span class="fc" id="L98">        var recordLookup = getKeyWithOrgCollection(recordToOrg.mapValues(OrgMergeHelper::getOrg), t -&gt; Optional.of(t.patientGuid()));</span>
<span class="fc" id="L99">        var adminPatientMap = getEmisEsManager().lookupAdminPatient(recordLookup);</span>
<span class="fc" id="L100">        io.vavr.collection.List&lt;Tuple3&lt;T, Optional&lt;AdminPatient&gt;, OrgMergeHelper&gt;&gt; recordsWithPatientAndOrgMergeHelper = recordToOrg</span>
<span class="fc" id="L101">                .map(r -&gt; Tuple.of(r._1, Optional.ofNullable(adminPatientMap.get(r._1.patientGuid())), r._2)).toList();</span>


<span class="fc" id="L104">        return HashMap.ofEntries(recordsWithPatientAndOrgMergeHelper</span>
<span class="fc" id="L105">                .map(recordWithPatientAndOrgMergeHelper -&gt; {</span>
<span class="fc" id="L106">                    T record = recordWithPatientAndOrgMergeHelper._1;</span>
<span class="fc" id="L107">                    Org survivorOrg = recordWithPatientAndOrgMergeHelper._3.getOrg();</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                    if (recordWithPatientAndOrgMergeHelper._2.isPresent()) {</span>
<span class="fc" id="L109">                        AdminPatient adminPatient = recordWithPatientAndOrgMergeHelper._2.get();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">                        boolean notWhitelisted = !getEmisEsManager().isAllowedPatient(adminPatient, recordWithPatientAndOrgMergeHelper._3);</span>
<span class="fc" id="L111">                        boolean ignoredPatientType = getEmisEsManager().isIgnoredPatientType(adminPatient);</span>
<span class="fc bfc" id="L112" title="All 4 branches covered.">                        if (notWhitelisted || ignoredPatientType) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                            if (notWhitelisted) {</span>
<span class="fc" id="L114">                                return Tuple.of(</span>
                                        record,
<span class="fc" id="L116">                                        processingError(record, NON_FATAL, &quot;Skipping patient not in whitelist. patientGuid=[%s] org Id=[%s] org ods=[%s]&quot;, adminPatient.patientGuid(), survivorOrg.getId(), survivorOrg.getExternalIdByType(OrgExternalIdType.ODS)));</span>
                            }
<span class="fc" id="L118">                            return Tuple.of(</span>
                                    record,
<span class="fc" id="L120">                                    processingError(record, NON_FATAL, &quot;Skipping dummy patient. patientGuid=[%s] org Id=[%s] org ods=[%s]&quot;, adminPatient.patientGuid(), survivorOrg.getId(), survivorOrg.getExternalIdByType(OrgExternalIdType.ODS)));</span>
                        } else {
<span class="fc" id="L122">                            getEmisPersonStatHelper().reportPatient(getProcessorType(), adminPatient);</span>
<span class="fc" id="L123">                            return Tuple.of(record, Either.right(adminPatient));</span>
                        }
                    } else {
<span class="fc bfc" id="L126" title="All 2 branches covered.">                        if (getEmisEsManager().isFilteredByPatientWhitelist(survivorOrg)) {</span>
<span class="fc" id="L127">                            return Tuple.of(</span>
                                    record,
<span class="fc" id="L129">                                    processingError(record, NON_FATAL, &quot;No patient found, likely filtered. patientGuid=[%s] org Id=[%s] org ods=[%s]&quot;, record.patientGuid(), survivorOrg.getId(), survivorOrg.getExternalIdByType(OrgExternalIdType.ODS)));</span>
                        } else {
                            //We're expecting to find a patient, but have no record of them.
                            //This may happen if we start processing delta data for a practice before we process their rebulk.
                            //In that case we'll see their data again when we get round to processing their rebulk, so just continue.
                            //We still need to track this in case there are any unexpected occurences which may require us to request additional rebulks.
<span class="fc" id="L135">                            return Tuple.of(</span>
                                    record,
<span class="fc" id="L137">                                    processingError(record, NON_FATAL,</span>
<span class="fc" id="L138">                                            &quot;No patient found, but org whitelist allows all patients. patientGuid=[%s], org Id=[%s] org ods=[%s]&quot;, record.patientGuid(),</span>
<span class="fc" id="L139">                                            survivorOrg.getId(), survivorOrg.getExternalIdByType(OrgExternalIdType.ODS)));</span>
                        }
                    }
                }));
    }

    /**
     * Fetch pkb persons for the given T.
     *
     * @param records Records and the additional info required to fetch account ids.
     *                The method itself could extract all the required info based
     *                on the records, but because Orgs and AdminPatients are needed
     *                elsewhere, we reuse them.
     * @return Map of records to either the corresponding PKBPersonInfo dto or the error message
     */
    default Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, PKBPersonInfo&gt;&gt; fetchPkbPersonsTimed(Map&lt;T, Tuple2&lt;Org, AdminPatient&gt;&gt; records) {
<span class="fc" id="L155">        return recordTime(&quot;pkbPersonsOrFailures&quot;, () -&gt; fetchPkbPersons(records));</span>
    }

    private Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, PKBPersonInfo&gt;&gt; fetchPkbPersons(
            Map&lt;T, Tuple2&lt;Org, AdminPatient&gt;&gt; records) {

<span class="fc" id="L161">        var keys = records.values().toJavaList();</span>

<span class="fc" id="L163">        var personInfoMap = getEmisEsManager().getPKBPersonInfoCachedOrRetrieve(context, keys);</span>

<span class="fc" id="L165">        return records</span>
<span class="fc" id="L166">                .map((k, v) -&gt; Tuple.of(k, getPKBPersonInfo(k, v, personInfoMap)));</span>
    }

    private Either&lt;ProcessingError&lt;T&gt;, PKBPersonInfo&gt; getPKBPersonInfo(T item, Tuple2&lt;Org, AdminPatient&gt; orgPatient, java.util.Map&lt;Tuple2&lt;Org, AdminPatient&gt;, Either&lt;RuntimeException, Optional&lt;PKBPersonInfo&gt;&gt;&gt; infoMap) {
<span class="fc" id="L170">        var errorOrMaybePersonInfo = infoMap.get(orgPatient);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (errorOrMaybePersonInfo.isLeft()) {</span>
<span class="fc" id="L172">            var exception = errorOrMaybePersonInfo.getLeft();</span>
<span class="pc bpc" id="L173" title="3 of 4 branches missed.">            if (exception instanceof ConflictingPatientIdentifiersException || exception instanceof MultiplePatientSameIdentifierException) {</span>
<span class="fc" id="L174">                LOGGER.warn(&quot;EMIS ES AdminPatient received matches multiple PKBPerson records: Org Code={}&quot;, orgPatient._1.getCode());</span>
<span class="fc" id="L175">                return processingError(item, NON_FATAL,</span>
                        &quot;EMIS ES data received for AdminPatient that matches multiple PKBPerson records. See additional information somewhere before this.&quot;);
            }
<span class="nc" id="L178">            throw exception;</span>
        }

<span class="fc" id="L181">        return errorOrMaybePersonInfo.get()</span>
<span class="fc" id="L182">                .map(personInfo -&gt; {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                    if (!getEmisEsManager().validateNoDummyPatientCrossover(orgPatient._2, personInfo.isDummyPatient())) {</span>
<span class="fc" id="L184">                        return processingErrorForDummyPatientMismatch(item, orgPatient);</span>
                    }
<span class="fc" id="L186">                    getEmisPersonStatHelper().reportPatient(getProcessorType(), personInfo);</span>
<span class="fc" id="L187">                    return Either.&lt;ProcessingError&lt;T&gt;, PKBPersonInfo&gt;right(personInfo);</span>
                })
<span class="fc" id="L189">                .orElseGet(() -&gt; processingErrorForMissingPersonInfo(item, orgPatient));</span>
    }

    private Either&lt;ProcessingError&lt;T&gt;, PKBPersonInfo&gt; processingErrorForDummyPatientMismatch(T item, Tuple2&lt;Org, AdminPatient&gt; orgPatient) {
<span class="fc" id="L193">        return processingError(item, NON_FATAL, &quot;Dummy patient mismatch for patientGuid=[%s], org ID=[%s]&quot;, orgPatient._2.patientGuid(), orgPatient._1.getId());</span>
    }

    @NotNull
    private Either&lt;ProcessingError&lt;T&gt;, PKBPersonInfo&gt; processingErrorForMissingPersonInfo(T item, Tuple2&lt;Org, AdminPatient&gt; orgPatient) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (orgPatient._2.isHandleAsDischargedOrDeleted()) {</span>
<span class="fc" id="L199">            return processingError(item, NON_FATAL, &quot;Unable to find discharged/deleted patient for patientGuid=[%s], org ID=[%s]&quot;, orgPatient._2.patientGuid(), orgPatient._1.getId());</span>
        }

        //active patient, yet unable to find. This was previously FATAL, but we ran into this situation for patients that were hidden via #prod-queries.
        //if a batch starts, gets through admin_patient, but then we hide the patient before processing all data, there's a chance we can hit this.
        //so, this is no longer fatal, and data for this patient will be skipped,  but we do capture the counts of these in metrics so we can alert if we see too many
<span class="fc" id="L205">        getEmisPersonStatHelper().reportMissingPatient(getProcessorType(), orgPatient._2);</span>
<span class="fc" id="L206">        return processingError(item, NON_FATAL, &quot;Unable to find active patient for patientGuid=[%s], org ID=[%s]&quot;, orgPatient._2.patientGuid(), orgPatient._1.getId());</span>
    }

    /**
     * Fetch default account ids for the given T.
     *
     * @param records Records and the additional info required to fetch account ids.
     *                The method itself could extract all the required info based
     *                on the records, but because Orgs and AdminPatients are needed
     *                elsewhere, we reuse them.
     * @return Map of records to either the corresponding account ids or the error message
     */
    default Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, Long&gt;&gt; fetchDefaultAccountIdsTimed(Map&lt;T, PKBPersonInfo&gt; records) {
<span class="fc" id="L219">        return recordTime(&quot;defaultAccountIdsOrFailures&quot;, () -&gt; fetchDefaultAccountIds(records));</span>
    }

    private Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, Long&gt;&gt; fetchDefaultAccountIds(Map&lt;T, PKBPersonInfo&gt; records) {
<span class="fc" id="L223">        Map&lt;T, Long&gt; ids = records.mapValues(PKBPersonInfo::id);</span>
<span class="fc" id="L224">        java.util.Map&lt;Long, Long&gt; defaultAccIds = getUserManager().getDefaultAccountId(ids.values().toJavaList());</span>
<span class="fc" id="L225">        return records.map(</span>
                (k, v) -&gt; {
<span class="fc" id="L227">                    Long id = defaultAccIds.get(v.id());</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                    return id == null ? Tuple.of(k, processingError(k, FATAL, &quot;Cannot find default account id for person id %s&quot;, v.id())) : Tuple.of(k, Either.right(id));</span>
                });

    }

    /**
     * @param successesAndFailures Result of a processing function that maps K to either some TSuccess or a TError
     * @return Map only containing successes.
     */
    default &lt;K, TError, TSuccess&gt; Map&lt;K, TSuccess&gt; extractSuccesses(Map&lt;K, Either&lt;TError, TSuccess&gt;&gt; successesAndFailures) {
<span class="fc" id="L238">        return successesAndFailures.flatMap((k, v) -&gt; v.right().map(s -&gt; Tuple.of(k, s)));</span>
    }

    /**
     * @param successesAndFailures Result of a processing function that maps K to either some TSuccess or a TError
     * @return Map only containing failures.
     */
    default &lt;K, TError, TSuccess&gt; Map&lt;K, TError&gt; extractFailures(Map&lt;K, Either&lt;TError, TSuccess&gt;&gt; successesAndFailures) {
<span class="fc" id="L246">        return successesAndFailures.flatMap((k, v) -&gt; v.left().map(s -&gt; Tuple.of(k, s)));</span>
    }

    default &lt;K extends Serializable&gt; Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, Tuple2&lt;CodingReceived, Function1&lt;CodingReceived, CodeableConcept&gt;&gt;&gt;&gt; constructCodingReceivedOptionalOrg(
            Map&lt;T, Optional&lt;OrgMergeHelper&gt;&gt; observations, Function1&lt;T, K&gt; guidExtractor) {
<span class="fc" id="L251">        var clinicalCodeMap = getCodingMap(observations);</span>

<span class="fc" id="L253">        return observations.map(o -&gt; Tuple.of(o._1, o._2.orElse(null)))</span>
<span class="fc" id="L254">                .map(o -&gt; this.constructCodingReceived(o, guidExtractor, clinicalCodeMap))</span>
<span class="fc" id="L255">                .toMap(kv -&gt; Tuple.of(kv._1, kv._2.map(v -&gt; Tuple.of(v.codingReceived(), v.lazyBuilder()))));</span>
    }

    default &lt;K extends Serializable&gt; Map&lt;T, Either&lt;ProcessingError&lt;T&gt;, CodingWrapper&gt;&gt; constructCodingReceived(
            Map&lt;T, OrgMergeHelper&gt; observations, Function1&lt;T, K&gt; uniqueKeyExtractor) {
<span class="fc" id="L260">        var clinicalCodeMap = getCodingMap(observations);</span>

<span class="fc" id="L262">        return observations.map(o -&gt; this.constructCodingReceived(o, uniqueKeyExtractor, clinicalCodeMap)).toMap(kv -&gt; kv);</span>
    }

    private &lt;U&gt; java.util.Map&lt;BigInteger, CodingClinicalCode&gt; getCodingMap(Map&lt;T, U&gt; observations) {
<span class="fc" id="L266">        var codeIds = observations.map(t -&gt; t._1)</span>
<span class="fc" id="L267">                .filter(epdp -&gt; epdp.codeId().isPresent())</span>
<span class="fc" id="L268">                .map(r -&gt; (BigInteger) r.codeId().orElseThrow())</span>
<span class="fc" id="L269">                .collect(toSet());</span>
<span class="fc" id="L270">        return getEmisEsManager().lookupClinicalCode(codeIds);</span>
    }

    @NotNull
    private &lt;K extends Serializable&gt; Tuple2&lt;T, Either&lt;ProcessingError&lt;T&gt;, CodingWrapper&gt;&gt; constructCodingReceived(
            Tuple2&lt;T, OrgMergeHelper&gt; o, Function1&lt;T, K&gt; uniqueKeyExtractor, java.util.Map&lt;BigInteger, CodingClinicalCode&gt; clinicalCodeMap) {
<span class="fc" id="L276">        T obs = o._1;</span>
<span class="fc" id="L277">        OrgMergeHelper orgMergeHelper = o._2;</span>
<span class="fc" id="L278">        Optional&lt;BigInteger&gt; maybeCodeId = obs.codeId();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (maybeCodeId.isPresent()) {</span>
<span class="fc" id="L280">            CodingClinicalCode maybeCode = clinicalCodeMap.get(maybeCodeId.get());</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (maybeCode != null) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">                if (orgMergeHelper == null) {</span>
<span class="fc" id="L283">                    return Tuple.of(obs, Either.left(new ProcessingError&lt;&gt;(obs, FATAL, &quot;Org is null! uniqueKey: %s&quot;, uniqueKeyExtractor.apply(obs))));</span>
                }
<span class="fc" id="L285">                CodingClinicalCode code = maybeCode;</span>
<span class="fc" id="L286">                CodingReceived codingReceived = new CodingReceived();</span>
<span class="fc" id="L287">                codingReceived.setRoute(Route.EMIS_ES);</span>
<span class="fc" id="L288">                codingReceived.setOrgId(orgMergeHelper.getOrg().getId());</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                if (code.readTermId().isPresent()) {</span>
<span class="fc" id="L290">                    codingReceived.setCode1(code.readTermId().get());</span>
<span class="fc" id="L291">                    codingReceived.setCode2(code.snomedCTConceptId().toString());</span>
<span class="fc" id="L292">                    codingReceived.setCodeSystem2(CodeSystems.SNOMED_CT);</span>
                } else {
<span class="fc" id="L294">                    codingReceived.setCode1(code.snomedCTConceptId().toString());</span>
<span class="fc" id="L295">                    codingReceived.setCodeSystem1(CodeSystems.SNOMED_CT);</span>
                }
                // PHR-5627 - mitigate duplicate coding in CodeableConcept (this is rather ugly)
<span class="fc" id="L298">                Function1&lt;CodingReceived, CodeableConcept&gt; lazyBuilder = cr -&gt; {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                    if (CodeSystems.SNOMED_CT.equals(cr.getCodeSystem1())) {</span>
<span class="fc" id="L300">                        return new CodeableConcept.Builder(code.term())</span>
<span class="fc" id="L301">                                .coding(new Coding.Builder(cr.getCode1(), cr.getCodeSystem1()).build())</span>
<span class="fc" id="L302">                                .build();</span>
                    } else {
<span class="fc" id="L304">                        return new CodeableConcept.Builder(code.term())</span>
<span class="fc" id="L305">                                .coding(new Coding.Builder(String.valueOf(code.snomedCTConceptId()), CodeSystems.SNOMED_CT)</span>
<span class="fc" id="L306">                                        .build())</span>
<span class="fc" id="L307">                                .coding(new Coding.Builder(cr.getCode1(), cr.getCodeSystem1()).build())</span>
<span class="fc" id="L308">                                .build();</span>
                    }
                };
<span class="fc" id="L311">                return Tuple.of(obs, Either.right(ImmutableCodingWrapper.builder()</span>
<span class="fc" id="L312">                                                                    .codingReceived(codingReceived)</span>
<span class="fc" id="L313">                                                                    .codingClinicalCode(code)</span>
<span class="fc" id="L314">                                                                    .org(orgMergeHelper.getOrg())</span>
<span class="fc" id="L315">                                                                    .lazyBuilder(lazyBuilder)</span>
<span class="fc" id="L316">                                                                    .build()));</span>
            } else {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">                if (orgMergeHelper == null) {</span>
<span class="nc" id="L319">                    getEmisEsManager().trackMissingClinicalCode(maybeCodeId.get(), obs.organisationGuid());</span>
<span class="nc" id="L320">                    return Tuple.of(obs, Either.left(new ProcessingError&lt;&gt;(obs, FATAL, &quot;Org %s: No clinical code we know about: %s&quot;, obs.organisationGuid(), maybeCodeId.get())));</span>
                } else {
<span class="fc" id="L322">                    getEmisEsManager().trackMissingClinicalCode(maybeCodeId.get(), orgMergeHelper.getOrg().getExternalIdByType(OrgExternalIdType.ODS));</span>
<span class="fc" id="L323">                    return Tuple.of(obs, Either.left(new ProcessingError&lt;&gt;(obs, FATAL, &quot;Org %s/%s: No clinical code we know about: %s&quot;, orgMergeHelper.getOrg().getId(),</span>
<span class="fc" id="L324">                            orgMergeHelper.getOrg().getExternalIdByType(OrgExternalIdType.ODS), maybeCodeId.get())));</span>
                }
            }
        } else {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">            if (orgMergeHelper == null) {</span>
<span class="nc" id="L329">                return Tuple.of(obs, Either.left(new ProcessingError&lt;&gt;(obs, FATAL, &quot;Org %s: No clinical code provided!&quot;, obs.organisationGuid())));</span>
            } else {
<span class="fc" id="L331">                return Tuple.of(obs, Either.left(new ProcessingError&lt;&gt;(obs, FATAL, &quot;Org %s/%s: No clinical code provided!&quot;,</span>
<span class="fc" id="L332">                        orgMergeHelper.getOrg().getId(), orgMergeHelper.getOrg().getExternalIdByType(OrgExternalIdType.ODS))));</span>
            }
        }
    }

    @NotNull
    default ProcessingError.Severity getUnmatchedCodingErrorSeverity() {
<span class="fc bfc" id="L339" title="All 2 branches covered.">        return getConfig().getEmisEsFatalSeverityForUnmatchedCodingError() ? FATAL : NON_FATAL;</span>
    }

    default &lt;K, V&gt; Map&lt;K, V&gt; restrict(Map&lt;K, V&gt; original, Set&lt;K&gt; restriction) {
<span class="fc" id="L343">        return original.filterKeys(restriction::contains);</span>
    }

    UserManager getUserManager();

    PhrConfig getConfig();

    /**
     * @return list of 2-tuple that maps a prescribingDrugRecord's drugRecordGuid to
     * - either an CodingDrugCode (success)
     * - or a reason that describes why a CodingDrugCode could not be found
     */
    default Map&lt;PrescribingDrugRecord, Either&lt;ProcessingError&lt;PrescribingDrugRecord&gt;, CodingDrugCode&gt;&gt; fetchCodingDrugCodesTimed(
            Traversable&lt;PrescribingDrugRecord&gt; records) {
<span class="fc" id="L357">        return recordTime(&quot;fetchDrugCode&quot;, () -&gt; fetchCodingDrugCodes(records));</span>
    }

    private Map&lt;PrescribingDrugRecord, Either&lt;ProcessingError&lt;PrescribingDrugRecord&gt;, CodingDrugCode&gt;&gt; fetchCodingDrugCodes(
            Traversable&lt;PrescribingDrugRecord&gt; records) {
<span class="fc" id="L362">        var codeIds = records.filter(pdr -&gt; pdr.codeId().isPresent()).map(pdr -&gt; pdr.codeId().orElseThrow()).toJavaSet();</span>
<span class="fc" id="L363">        var drugCodeMap = getEmisEsManager().lookupDrugCodes(codeIds);</span>
<span class="fc" id="L364">        return HashMap.ofEntries(records.map(pdr -&gt; fetchCodingDrugCodes(pdr, drugCodeMap)));</span>
    }

    private Tuple2&lt;PrescribingDrugRecord, Either&lt;ProcessingError&lt;PrescribingDrugRecord&gt;, CodingDrugCode&gt;&gt; fetchCodingDrugCodes(PrescribingDrugRecord input, java.util.Map&lt;BigInteger, CodingDrugCode&gt; drugCodeMap) {
<span class="fc" id="L368">        Optional&lt;BigInteger&gt; maybeCodeId = input.codeId();</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (maybeCodeId.isPresent()) {</span>
<span class="fc" id="L370">            CodingDrugCode maybeDrugCode = drugCodeMap.get(maybeCodeId.get());</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (maybeDrugCode != null) {</span>
<span class="fc" id="L372">                return Tuple.of(input, Either.right(maybeDrugCode));</span>
            } else {
<span class="fc" id="L374">                getEmisEsManager().trackMissingDrugCode(maybeCodeId.get(), input.drugRecordGuid());</span>
<span class="fc" id="L375">                return Tuple.of(input, Either.left(new ProcessingError&lt;&gt;(input, FATAL, &quot;EMIS ES: Coding not found for drug codeId=[%s]&quot;, maybeCodeId.get())));</span>
            }
        } else {
<span class="fc" id="L378">            return Tuple.of(input, Either.left(new ProcessingError&lt;&gt;(input, FATAL, &quot;Drug record %s: No drug code provided!&quot;, input.drugRecordGuid())));</span>
        }
    }

    EmisPersonStatHelper getEmisPersonStatHelper();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>