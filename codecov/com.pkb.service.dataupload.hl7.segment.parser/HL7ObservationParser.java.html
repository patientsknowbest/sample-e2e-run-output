<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HL7ObservationParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.dataupload.hl7.segment.parser</a> &gt; <span class="el_source">HL7ObservationParser.java</span></div><h1>HL7ObservationParser.java</h1><pre class="source lang-java linenums">package com.pkb.service.dataupload.hl7.segment.parser;

import com.pkb.exception.ApiCallMalformedException;
import com.pkb.service.dataupload.hl7.HL7MessageProperties;
import com.pkb.service.dataupload.hl7.HL7XmlDoc;
import com.pkb.service.dataupload.hl7.field.HL7Code;
import com.pkb.service.dataupload.hl7.field.HL7ReferenceRange;
import com.pkb.service.dataupload.hl7.segment.HL7Observation;
import com.pkb.service.dataupload.hl7.segment.HL7StructuredNumber;
import com.pkb.service.dataupload.hl7.value.HL7String;
import io.vavr.control.Try;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;

import java.util.Arrays;
import java.util.Optional;

import static com.pkb.service.dataupload.hl7.segment.HL7ComparatorOperator.NOT_EQUAL;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.function.Function.identity;

public class HL7ObservationParser {

    static class SNDataTypeParser {

        private final HL7Observation observation;

        private final Logger logger;

<span class="fc" id="L35">        boolean messageShouldBeIgnored = false;</span>

<span class="fc" id="L37">        SNDataTypeParser(@NotNull HL7Observation observation, @NotNull Logger logger) {</span>
<span class="fc" id="L38">            this.observation = observation;</span>
<span class="fc" id="L39">            this.logger = logger;</span>
<span class="fc" id="L40">        }</span>

        public void parse(Element obx) {
<span class="fc" id="L43">            String obx53 = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.3&quot;).getString();</span>
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">            boolean obx53Provided = !obx53.isEmpty();</span>
<span class="fc" id="L45">            String obx54 = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.4&quot;).getString();</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">            boolean obx54Provided = !obx54.isEmpty();</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">            if (HL7XmlDoc.tagByNameExists(obx, &quot;OBX.5.2&quot;)) {</span>
<span class="fc" id="L48">                String obx51 = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.1&quot;).getString();</span>
<span class="fc" id="L49">                String obx52 = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.2&quot;).getString();</span>
<span class="fc" id="L50">                HL7StructuredNumber structNumber = HL7StructuredNumber.parseRawSegments(obx51, obx52).getOrElseThrow(identity());</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">                if (obx53Provided) {</span>
<span class="nc" id="L52">                    boolean isOBX53Valid = Arrays.stream(HL7Observation.SNArithmeticOperator.values()).map(Object::toString).anyMatch(obx53::equals);</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">                    if (!isOBX53Valid) {</span>
<span class="nc" id="L54">                        logger.warn(&quot;[PHR-3973] invalid OBX.5.3 segment: [{}]&quot;, obx53);</span>
                    }
                }
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">                if (obx54Provided) {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">                    if (obx53.isEmpty()) {</span>
<span class="nc" id="L59">                        logger.warn(&quot;[PHR-3973] missing OBX.5.3 segment while OBX.5.2 and OBX.5.4 are provided&quot;);</span>
                    }
<span class="nc" id="L61">                    Try.of(() -&gt; Double.parseDouble(obx54)).onFailure(exc -&gt; logger.warn(&quot;[PHR-3973] invalid OBX.5.4 segment: [{}]&quot;, obx54));</span>
                }
<span class="pc bpc" id="L63" title="2 of 6 branches missed.">                if (!obx53Provided &amp;&amp; !obx54Provided &amp;&amp; NOT_EQUAL != structNumber.comparator()) {</span>
<span class="fc" id="L64">                    observation.setValueComparator(structNumber.comparator());</span>
<span class="fc" id="L65">                    observation.setValueNumeric(structNumber.value());</span>
                } else {
<span class="fc" id="L67">                    messageShouldBeIgnored = true;</span>
                }
<span class="fc" id="L69">            } else {</span>
<span class="nc" id="L70">                logger.warn(&quot;[PHR-3973] OBX SN data received without OBX.5.2 segment&quot;);</span>
<span class="nc" id="L71">                observation.setValueText(HL7String.of(HL7XmlDoc.joinTextContentOfTags(obx, &quot;OBX.5.1&quot;, false)));</span>
            }
<span class="fc" id="L73">        }</span>
    }

<span class="fc" id="L76">    private static final Logger DEFAULT_LOGGER = LoggerFactory.getLogger(HL7ObservationParser.class);</span>

    private final Logger logger;

    public HL7ObservationParser() {
<span class="fc" id="L81">        this(DEFAULT_LOGGER);</span>
<span class="fc" id="L82">    }</span>

<span class="fc" id="L84">    public HL7ObservationParser(Logger logger) {</span>
<span class="fc" id="L85">        this.logger = logger;</span>
<span class="fc" id="L86">    }</span>

    private static byte[] decodeEncapsulatedData(String value, String encoding, String obxTrace)
            throws ApiCallMalformedException {
        try {
<span class="fc bfc" id="L91" title="All 2 branches covered.">            if (&quot;Base64&quot;.equals(encoding)) {</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">                if (!Base64.isBase64(value)) {</span>
<span class="nc" id="L93">                    throw new ApiCallMalformedException(obxTrace + &quot;: ED encoding is Base64 but content is not Base64 encoded&quot;);</span>
                }
<span class="fc" id="L95">                return Base64.decodeBase64(value.getBytes(UTF_8));</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">            } else if (&quot;A&quot;.equals(encoding)) {</span>
<span class="fc" id="L97">                return HL7XmlDoc.hl7Unescape(value).getBytes(UTF_8);</span>
            } else {
<span class="nc" id="L99">                throw new ApiCallMalformedException(obxTrace + &quot;: ED encoding &quot; + encoding + &quot; not yet supported; only Base64 or A&quot;);</span>
            }
<span class="nc" id="L101">        } catch (Exception e) {</span>
<span class="nc" id="L102">            throw new ApiCallMalformedException(obxTrace + &quot;: failed to parse ED content&quot;, e);</span>
        }
    }

    public Optional&lt;HL7Observation&gt; parse(HL7MessageProperties props, Element obx) {
<span class="nc" id="L107">        return parse(props, obx, &quot;&quot;);</span>
    }

    public Optional&lt;HL7Observation&gt; parse(HL7MessageProperties props, Element obx, String obrSetId) {
<span class="fc" id="L111">        HL7Observation result = new HL7Observation(props);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (populate(result, obx, obrSetId)) {</span>
<span class="fc" id="L113">            return Optional.of(result);</span>
        }
<span class="fc" id="L115">        return Optional.empty();</span>
    }

    public boolean populate(HL7Observation observation, Element obx, String obrSetId) {
<span class="fc" id="L119">        HL7String obxSetId = HL7XmlDoc.getHl7Text(obx, &quot;OBX.1.1&quot;);</span>
<span class="fc" id="L120">        observation.setObxSetId(obxSetId);</span>

<span class="fc" id="L122">        String obxTrace = &quot;OBR[&quot; + obrSetId + &quot;].OBX[&quot; + obxSetId.getString() + &quot;]&quot;;</span>

<span class="fc" id="L124">        HL7String valueType = HL7XmlDoc.getHl7Text(obx, &quot;OBX.2.1&quot;);</span>
<span class="fc" id="L125">        observation.setValueType(valueType);</span>
<span class="fc" id="L126">        observation.setResultStatus(HL7XmlDoc.getHl7Text(obx, &quot;OBX.11.1&quot;));</span>

<span class="fc" id="L128">        observation.getTestCode().parseCe(obx, &quot;OBX&quot;, 3);</span>

<span class="fc" id="L130">        HL7String valueText = new HL7String();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (&quot;ED&quot;.equals(valueType.getString())) {</span>
<span class="fc" id="L132">            HL7String edApplication = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.1&quot;);</span>
<span class="fc" id="L133">            HL7String edDataType = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.2&quot;);</span>
<span class="fc" id="L134">            HL7String edSubDataType = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.3&quot;);</span>
<span class="fc" id="L135">            HL7String edEncoding = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.4&quot;);</span>

            // Apply some helpful defaults before trying to decode data
<span class="pc bpc" id="L138" title="1 of 4 branches missed.">            if (&quot;RTF&quot;.equals(edSubDataType.getString()) &amp;&amp; edDataType.isBlank()) {</span>
<span class="nc" id="L139">                edDataType = new HL7String(&quot;TEXT&quot;);</span>
            }
<span class="pc bpc" id="L141" title="1 of 4 branches missed.">            if (&quot;HTML&quot;.equals(edSubDataType.getString()) &amp;&amp; edDataType.isBlank()) {</span>
<span class="nc" id="L142">                edDataType = new HL7String(&quot;TEXT&quot;);</span>
            }
<span class="pc bpc" id="L144" title="1 of 4 branches missed.">            if (&quot;PDF&quot;.equals(edSubDataType.getString()) || &quot;MSWORD&quot;.equals(edSubDataType.getString())) {</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">                if (!&quot;Base64&quot;.equals(edEncoding.getString())) {</span>
<span class="fc" id="L147">                    throw new ApiCallMalformedException(obxTrace + &quot;: ED encoding &quot; + edEncoding.getString() + &quot; is not supported; only Base64&quot;);</span>
                }
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">                if (edDataType.isBlank()) {</span>
<span class="nc" id="L150">                    edDataType = new HL7String(&quot;APPLICATION&quot;);</span>
                }
            }
<span class="pc bpc" id="L153" title="1 of 4 branches missed.">            if (&quot;TEXT&quot;.equals(edDataType.getString()) &amp;&amp; edEncoding.isBlank()) {</span>
<span class="nc" id="L154">                edEncoding = new HL7String(&quot;A&quot;);</span>
            }

<span class="fc" id="L157">            HL7String content = HL7XmlDoc.getHl7Text(obx, &quot;OBX.5.5&quot;);</span>
<span class="fc" id="L158">            byte[] edValue = decodeEncapsulatedData(content.getString(), edEncoding.getString(), obxTrace);</span>
<span class="fc" id="L159">            observation.setEdApplication(edApplication);</span>
<span class="fc" id="L160">            observation.setEdDataType(edDataType);</span>
<span class="fc" id="L161">            observation.setEdSubDataType(edSubDataType);</span>
<span class="fc" id="L162">            observation.setEdEncoding(edEncoding);</span>
<span class="fc" id="L163">            observation.setEdValue(edValue);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        } else if (&quot;SN&quot;.equals(valueType.getString())) {</span>
<span class="fc" id="L165">            SNDataTypeParser snParser = new SNDataTypeParser(observation, logger);</span>
<span class="fc" id="L166">            snParser.parse(obx);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (snParser.messageShouldBeIgnored) {</span>
<span class="fc" id="L168">                return false;</span>
            }
<span class="fc" id="L170">        } else {</span>
            // get usual value text (may be a repeating field)
<span class="fc" id="L172">            valueText = HL7String.of(HL7XmlDoc.joinTextContentOfTags(obx, &quot;OBX.5.1&quot;, false));</span>
<span class="fc" id="L173">            observation.setValueText(valueText);</span>
        }

<span class="fc" id="L176">        HL7Code unitCode = observation.getUnitCode();</span>
<span class="fc" id="L177">        unitCode.parseCe(obx, &quot;OBX&quot;, 6);</span>

<span class="fc" id="L179">        HL7String referenceRangeText = HL7XmlDoc.getHl7Text(obx, &quot;OBX.7.1&quot;);</span>

<span class="fc" id="L181">        observation.setAccessChecks(HL7XmlDoc.getHl7Text(obx, &quot;OBX.13.1&quot;));</span>

<span class="fc" id="L183">        observation.setTimestamp(HL7XmlDoc.parseDateOrTimestamp(HL7XmlDoc.getHl7Text(obx, &quot;OBX.14.1&quot;), obxTrace + &quot;.14.1&quot;, observation.getMessageProperties()));</span>

        // Value handling!  It might be numeric... it might not be.  We might be expecting either,
        // and we might be able to fix it (if we have a matching fix pattern)

        // try parsing to a number (outside code can decide whether to trust the value type)
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (NumberUtils.isCreatable(StringUtils.trim(valueText.getString()))) {</span>
            try {
<span class="fc" id="L191">                observation.setValueNumeric(Double.valueOf(StringUtils.trim(valueText.getString())));</span>
<span class="nc" id="L192">            } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L193">                DEFAULT_LOGGER.error(&quot;NumberFormatException caught, but skipping logging the string because it might be sensitive&quot;);</span>
<span class="fc" id="L194">            }</span>
        }

<span class="fc" id="L197">        HL7ReferenceRange referenceRange = HL7ReferenceRange.parse(referenceRangeText.getString());</span>
<span class="fc" id="L198">        referenceRange.getRangeLow().ifPresent(observation::setRangeLow);</span>
<span class="fc" id="L199">        observation.setRangeLowInclusive(referenceRange.getRangeLowInclusive());</span>
<span class="fc" id="L200">        referenceRange.getRangeHigh().ifPresent(observation::setRangeHigh);</span>
<span class="fc" id="L201">        observation.setRangeHighInclusive(referenceRange.getRangeHighInclusive());</span>
<span class="fc" id="L202">        observation.setTextRange(referenceRange.getRangeText());</span>

<span class="fc" id="L204">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>