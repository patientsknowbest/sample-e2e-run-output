<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConsentService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.domain.consent</a> &gt; <span class="el_source">ConsentService.java</span></div><h1>ConsentService.java</h1><pre class="source lang-java linenums">package com.pkb.domain.consent;

import com.google.common.collect.ArrayTable;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.datamodel.consent.ConsentExpiryDecision;
import com.pkb.datamodel.consent.ConsentExpiryDecisionExisting;
import com.pkb.datamodel.consent.ImmutableSourceDTO;
import com.pkb.datamodel.consent.ImmutableTeamAdditionalConsent;
import com.pkb.datamodel.consent.PatientAdditionalConsent;
import com.pkb.datamodel.consent.PatientAdditionalConsentExisting;
import com.pkb.datamodel.consent.PatientConsentDTO;
import com.pkb.datamodel.consent.PatientConsentUpdateDTO;
import com.pkb.datamodel.consent.TeamAdditionalConsent;
import com.pkb.datamodel.entity.mapper.ConsentExpiryDecisionMapper;
import com.pkb.datamodel.entity.mapper.PatientAdditionalConsentMapper;
import com.pkb.datamodel.entity.mapper.PatientConsentDTOMapper;
import com.pkb.datamodel.entity.mapper.TeamAdditionalConsentMapper;
import com.pkb.entities.enums.AccessingEntityType;
import com.pkb.entities.enums.AdditionalConsentId;
import com.pkb.entities.enums.CarerRemovalAge;
import com.pkb.entities.enums.ConsentReason;
import com.pkb.entities.enums.Route;
import com.pkb.entities.pub.PublicConsentExpiryDecision;
import com.pkb.entities.pub.PublicPKBPerson;
import com.pkb.entities.pub.PublicPatientConsent;
import com.pkb.repository.ConsentExpiryDecisionRepository;
import com.pkb.repository.PatientAdditionalConsentRepository;
import com.pkb.repository.PatientConsentRepository;
import com.pkb.repository.PersonRepository;
import com.pkb.repository.TeamAdditionalConsentRepository;
import com.pkb.util.DbUtil;
import io.vavr.Tuple;
import io.vavr.Tuple3;
import org.jetbrains.annotations.NotNull;

import javax.transaction.Transactional;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import static io.vavr.API.$;
import static io.vavr.API.Case;
import static io.vavr.API.Match;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;

public class ConsentService {

    private final PatientConsentRepository patientConsentRepository;
    private final DateTimeService dateTimeService;
    private final PersonRepository personRepository;
    private final PatientConsentDTOMapper patientConsentDTOMapper;
    private final TeamAdditionalConsentRepository teamAdditionalConsentRepository;
    private final PatientAdditionalConsentRepository patientAdditionalConsentRepository;
    private final ConsentExpiryDecisionRepository consentExpiryDecisionRepository;
    private final TeamAdditionalConsentMapper teamAdditionalConsentMapper;
    private final PatientAdditionalConsentMapper patientAdditionalConsentMapper;
    private final ConsentExpiryDecisionMapper consentExpiryDecisionMapper;

    private final PhrConfig configuration;


    public ConsentService(PatientConsentRepository patientConsentRepository,
                          DateTimeService dateTimeService, PersonRepository personRepository,
                          PatientConsentDTOMapper patientConsentDTOMapper,
                          TeamAdditionalConsentRepository teamAdditionalConsentRepository,
                          PatientAdditionalConsentRepository patientAdditionalConsentRepository,
                          ConsentExpiryDecisionRepository consentExpiryDecisionRepository,
                          TeamAdditionalConsentMapper teamAdditionalConsentMapper,
                          PatientAdditionalConsentMapper patientAdditionalConsentMapper,
<span class="fc" id="L83">                          ConsentExpiryDecisionMapper consentExpiryDecisionMapper, PhrConfig configuration) {</span>
<span class="fc" id="L84">        this.patientConsentRepository = patientConsentRepository;</span>
<span class="fc" id="L85">        this.dateTimeService = dateTimeService;</span>
<span class="fc" id="L86">        this.personRepository = personRepository;</span>
<span class="fc" id="L87">        this.patientConsentDTOMapper = patientConsentDTOMapper;</span>
<span class="fc" id="L88">        this.teamAdditionalConsentRepository = teamAdditionalConsentRepository;</span>
<span class="fc" id="L89">        this.patientAdditionalConsentRepository = patientAdditionalConsentRepository;</span>
<span class="fc" id="L90">        this.consentExpiryDecisionRepository = consentExpiryDecisionRepository;</span>
<span class="fc" id="L91">        this.teamAdditionalConsentMapper = teamAdditionalConsentMapper;</span>
<span class="fc" id="L92">        this.patientAdditionalConsentMapper = patientAdditionalConsentMapper;</span>
<span class="fc" id="L93">        this.consentExpiryDecisionMapper = consentExpiryDecisionMapper;</span>
<span class="fc" id="L94">        this.configuration = configuration;</span>
<span class="fc" id="L95">    }</span>

    @NotNull
    public Optional&lt;PatientConsentDTO&gt; findPatientConsent(long patientId, long accessingTeamOrPersonId, AccessingEntityType accessingEntityType) {
<span class="fc" id="L99">        return patientConsentRepository.findPatientConsentForEntityTypeAndPatientId(accessingEntityType, accessingTeamOrPersonId, patientId)</span>
<span class="fc" id="L100">                .map(patientConsentDTOMapper::map);</span>
    }


    @NotNull
    public Optional&lt;PatientConsentDTO&gt; findActivePatientConsentForPerson(long patientId, long accessingPersonId) {
<span class="fc" id="L106">        return patientConsentRepository.findActivePatientConsentForPerson(accessingPersonId, patientId)</span>
<span class="fc" id="L107">                .map(patientConsentDTOMapper::map);</span>
    }


    @NotNull
    public &lt;R&gt; Table&lt;Long, Long, R&gt; findPatientConsent(Set&lt;Long&gt; patientIds, Set&lt;Long&gt; accessingTeamOrPersonIds, AccessingEntityType accessingEntityType, Function&lt;PatientConsentDTO, R&gt; resultMapper) {
<span class="fc" id="L113">        BiFunction&lt;Collection&lt;Long&gt;, Collection&lt;Long&gt;, List&lt;PublicPatientConsent&gt;&gt; query = (patientIdBatch, accessingTeamOrPersonBatch) -&gt; patientConsentRepository.findPatientConsentForEntityTypeAndPatientId(accessingEntityType, accessingTeamOrPersonBatch, patientIdBatch);</span>
        //return DbUtil.getInBatches(patientIds, accessingTeamOrPersonIds, query, PatientConsentDTO::patientPersonId, PatientConsentDTO::getAccessingTeamOrPersonId, patientConsentDTOMapper::map, resultMapper);
        //java.lang.LinkageError: loader constraint violation: when resolving method 'com.google.common.collect.Table, once we're off of EJBs the code below can be deleted and the above line can be used
<span class="pc bpc" id="L116" title="1 of 4 branches missed.">        if (isEmpty(patientIds) || isEmpty(accessingTeamOrPersonIds)) {</span>
<span class="fc" id="L117">            return ImmutableTable.of();</span>
        }
<span class="fc" id="L119">        Table&lt;Long, Long, R&gt; result = ArrayTable.create(patientIds, accessingTeamOrPersonIds);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (patientIds.size() &lt; accessingTeamOrPersonIds.size()) {</span>
<span class="fc" id="L121">            DbUtil.getInStreamOfBatches(accessingTeamOrPersonIds, keys2Batch -&gt; query.apply(patientIds, keys2Batch))</span>
<span class="fc" id="L122">                    .forEach(ir -&gt; {</span>
<span class="fc" id="L123">                        PatientConsentDTO r = patientConsentDTOMapper.map(ir);</span>
<span class="fc" id="L124">                        result.put(r.patientPersonId(), r.getAccessingTeamOrPersonId(), resultMapper.apply(r));</span>
<span class="fc" id="L125">                    });</span>
        } else {
<span class="fc" id="L127">            DbUtil.getInStreamOfBatches(patientIds, keys1Batch -&gt; query.apply(keys1Batch, accessingTeamOrPersonIds))</span>
<span class="fc" id="L128">                    .forEach(ir -&gt; {</span>
<span class="fc" id="L129">                        PatientConsentDTO r = patientConsentDTOMapper.map(ir);</span>
<span class="fc" id="L130">                        result.put(r.patientPersonId(), r.getAccessingTeamOrPersonId(), resultMapper.apply(r));</span>
<span class="fc" id="L131">                    });</span>
        }
<span class="fc" id="L133">        return result;</span>
    }

    /**
     * Consent for children can expire at specific ages. This method handles marking
     * the consent as revoked + recording the consent expiry record for it.
     */
    public void expireConsent(PatientConsentDTO existingConsent) {
<span class="fc" id="L141">        PublicConsentExpiryDecision consentExpiry = getExpiryByPersonIds(existingConsent.getAccessingTeamOrPersonId(), existingConsent.patientPersonId())</span>
<span class="fc" id="L142">                .orElseGet(() -&gt; createNewExpiryDecision(existingConsent.id(), existingConsent.patientPersonId()));</span>
<span class="fc" id="L143">        consentExpiry.setConsentDeletedAt(dateTimeService.now());</span>
<span class="fc" id="L144">        createOrUpdateConsentExpiry(consentExpiry);</span>
<span class="fc" id="L145">        updatePatientConsent(existingConsent.patientPersonId(), existingConsent.getAccessingTeamOrPersonId(), existingConsent.accessingEntityType(), PatientConsentUpdateDTO.revocationOf(existingConsent, ImmutableSourceDTO.builder().route(Route.SCHED_TASK).personId(existingConsent.patientPersonId()).sourceText(&quot;Consent expiry&quot;).build(), ConsentReason.EXPIRED));</span>
<span class="fc" id="L146">    }</span>

    private PublicConsentExpiryDecision createNewExpiryDecision(long consentId, long revokerId) {
<span class="fc" id="L149">        PublicConsentExpiryDecision consentExpiryDecision = new PublicConsentExpiryDecision();</span>
<span class="fc" id="L150">        consentExpiryDecision.setConsentId(consentId);</span>
<span class="fc" id="L151">        consentExpiryDecision.setReason(&quot;Access Revoked, Expired Consent&quot;);</span>
<span class="fc" id="L152">        consentExpiryDecision.setExpires(false);</span>
<span class="fc" id="L153">        consentExpiryDecision.setEnteredBy(revokerId);</span>
<span class="fc" id="L154">        consentExpiryDecision.setEnteredDate(dateTimeService.now());</span>
<span class="fc" id="L155">        return consentExpiryDecision;</span>
    }

    private void createOrUpdateConsentExpiry(PublicConsentExpiryDecision expiry) {
<span class="fc" id="L159">        consentExpiryDecisionRepository.saveAndFlush(expiry);</span>
<span class="fc" id="L160">    }</span>

    private Optional&lt;PublicConsentExpiryDecision&gt; getExpiryByPersonIds(long accessorId, long patientId) {
<span class="fc" id="L163">        return consentExpiryDecisionRepository.getByConsentAccessorAndPatient(accessorId, patientId);</span>
    }

    @Transactional
    @NotNull
    public UUID updatePatientConsent(long patientId, long accessingTeamOrPersonId, AccessingEntityType accessingEntityType,
                                     PatientConsentUpdateDTO update) {

<span class="fc" id="L171">        PublicPatientConsent entity = patientConsentRepository.findPatientConsentForEntityTypeAndPatientId(accessingEntityType, accessingTeamOrPersonId, patientId)</span>
<span class="fc" id="L172">                .orElseGet(() -&gt; {</span>
<span class="fc" id="L173">                    var pc = new PublicPatientConsent();</span>
<span class="fc" id="L174">                    pc.setAdded(dateTimeService.now());</span>
<span class="fc" id="L175">                    return pc;</span>
                });

<span class="fc" id="L178">        PublicPKBPerson person = personRepository.findById(update.patientPersonId())</span>
<span class="pc" id="L179">                .orElseThrow(() -&gt; new RuntimeException(&quot;Trying to update PatientConsent without valid patient id [&quot; + patientId + &quot;]&quot;));</span>

        // Apply the changes
<span class="fc" id="L182">        entity.setProEditOnlyForChild(update.proEditOnlyForChild());</span>
<span class="fc" id="L183">        entity.setDischarged(update.discharged());</span>
<span class="fc" id="L184">        entity.setPatient(person);</span>
<span class="fc" id="L185">        entity.setUpdated(dateTimeService.now());</span>
<span class="fc" id="L186">        entity.setAccessingEntityType(update.accessingEntityType());</span>
<span class="fc" id="L187">        entity.setAccessingTeamSlashPersonId(Match(update.accessingEntityType()).of(</span>
<span class="fc" id="L188">                Case($(AccessingEntityType.INDIVIDUAL), update::requireAccessingPersonId),</span>
<span class="fc" id="L189">                Case($(AccessingEntityType.CARER), update::requireAccessingPersonId),</span>
<span class="fc" id="L190">                Case($(AccessingEntityType.TEAM), update::requireAccessingTeamId)</span>
        ));
<span class="fc" id="L192">        entity.setGeneralHealthConsentGranted(update.generalHealthConsentGranted());</span>
<span class="fc" id="L193">        entity.setMentalHealthConsentGranted(update.mentalHealthConsentGranted());</span>
<span class="fc" id="L194">        entity.setSocialCareConsentGranted(update.socialCareConsentGranted());</span>
<span class="fc" id="L195">        entity.setSexualHealthConsentGranted(update.sexualHealthConsentGranted());</span>

<span class="fc bfc" id="L197" title="All 4 branches covered.">        if (accessingEntityType == AccessingEntityType.CARER</span>
                || accessingEntityType == AccessingEntityType.INDIVIDUAL) {
<span class="fc bfc" id="L199" title="All 2 branches covered.">            entity.setDischarged(!update.anyConsentGranted());</span>
        }

<span class="fc" id="L202">        patientConsentRepository.saveAndFlush(entity);</span>
<span class="fc" id="L203">        return entity.getUniqueId();</span>
    }

    @NotNull
    public List&lt;PatientConsentDTO&gt; findAllActivePatientConsents(long patientId) {
<span class="fc" id="L208">        return patientConsentRepository.findAllActivePatientConsents(patientId)</span>
<span class="fc" id="L209">                .stream()</span>
<span class="fc" id="L210">                .map(patientConsentDTOMapper::map)</span>
<span class="fc" id="L211">                .collect(toList());</span>
    }

    public List&lt;PatientConsentDTO&gt; getConsentsForPatient(long patientId, Set&lt;AccessingEntityType&gt; entityTypes, boolean includeDischarged) {

<span class="fc" id="L216">        List&lt;PublicPatientConsent&gt; resultList = null;</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (isNotEmpty(entityTypes)) {</span>
<span class="fc" id="L219">            resultList = patientConsentRepository.findByPatientIdAndAccessingEntityTypeIn(patientId, entityTypes);</span>
        } else {
<span class="fc" id="L221">            resultList = patientConsentRepository.findByPatientId(patientId);</span>
        }

<span class="fc bfc" id="L224" title="All 4 branches covered.">        return resultList.stream().filter(consent -&gt; includeDischarged || !consent.isDischarged()).map(patientConsentDTOMapper::map).collect(Collectors.toUnmodifiableList());</span>
    }

    public List&lt;PatientConsentDTO&gt; findAllPatientConsentsForIndividual(long accessingPersonId, AccessingEntityType accessingEntityType) {
<span class="fc" id="L228">        return patientConsentRepository.findByAccessingTeamSlashPersonIdAndAccessingEntityTypeOrderById(accessingPersonId, accessingEntityType)</span>
<span class="fc" id="L229">                .stream()</span>
<span class="fc" id="L230">                .map(patientConsentDTOMapper::map)</span>
<span class="fc" id="L231">                .collect(Collectors.toUnmodifiableList());</span>
    }

    @NotNull
    public List&lt;PatientConsentDTO&gt; getExpiredConsents(CarerRemovalAge age) {
<span class="fc" id="L236">        return patientConsentRepository.getExpiredConsents(age.getReminderPropertyName(), age.getRemovalPropertyName())</span>
<span class="fc" id="L237">                .stream()</span>
<span class="fc" id="L238">                .map(entities -&gt; Tuple.of((PublicPatientConsent) entities[0], (PublicConsentExpiryDecision) entities[1], (PublicPKBPerson) entities[2]))</span>
<span class="fc" id="L239">                .filter(consentData -&gt; isInAgeRestriction(consentData, age))</span>
<span class="fc" id="L240">                .map(Tuple3::_1)</span>
<span class="fc" id="L241">                .map(patientConsentDTOMapper::map)</span>
<span class="fc" id="L242">                .collect(Collectors.toUnmodifiableList());</span>
    }

    private boolean isInAgeRestriction(Tuple3&lt;PublicPatientConsent, PublicConsentExpiryDecision, PublicPKBPerson&gt; consentData, CarerRemovalAge age) {
<span class="fc" id="L246">        int patientAgeCriterion = Optional.ofNullable(consentData._2)</span>
<span class="fc" id="L247">                        .map(PublicConsentExpiryDecision::getPatientAgeCriterion) //Either because there is no CED or because it has a null age criterion - which means it's a processed record applying to a previous milestone</span>
<span class="fc" id="L248">                        .orElseGet(age::getValue);</span>

<span class="fc" id="L250">        return  consentData._3.findDateOfBirth()</span>
<span class="fc" id="L251">                .map(dob -&gt; dob.plus(patientAgeCriterion, ChronoUnit.YEARS))</span>
<span class="fc" id="L252">                .map(dob -&gt; dob.atStartOfDay(ZoneOffset.UTC).toInstant())</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                .map(milestoneBirthday -&gt; !milestoneBirthday.isAfter(dateTimeService.now()))</span>
<span class="fc" id="L254">                .orElse(false);</span>
    }

    @NotNull
    public List&lt;TeamAdditionalConsent&gt; findTeamAdditionalConsents(long teamId) {
<span class="fc" id="L259">        return teamAdditionalConsentRepository.findTeamAdditionalConsents(teamId)</span>
<span class="fc" id="L260">                .stream()</span>
<span class="fc" id="L261">                .map(teamAdditionalConsentMapper::entityToDataModel)</span>
<span class="fc" id="L262">                .collect(toList());</span>
    }

    @Transactional
    public void updateTeamAdditionalConsents(long teamId, List&lt;TeamAdditionalConsent&gt; consents) {
<span class="fc" id="L267">        teamAdditionalConsentRepository.deleteTeamAdditionalConsents(teamId);</span>
<span class="fc" id="L268">        teamAdditionalConsentRepository.saveAll(consents.stream().map(teamAdditionalConsentMapper::dataModelToEntity).collect(toList()));</span>
<span class="fc" id="L269">    }</span>

    @NotNull
    public List&lt;TeamAdditionalConsent&gt; getTeamAdditionalConsentDefaults(long teamId) {
<span class="fc" id="L273">        List&lt;TeamAdditionalConsent&gt; consents = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (AdditionalConsentId consent : AdditionalConsentId.values()) {</span>
<span class="fc" id="L275">            consents.add(ImmutableTeamAdditionalConsent.builder().additionalConsent(consent).teamId(teamId).build());</span>
        }
<span class="fc" id="L277">        return consents;</span>
    }

    @NotNull
    public List&lt;PatientAdditionalConsentExisting&gt; findPatientAdditionalConsentForTeam(long patientId, long teamId) {
<span class="fc" id="L282">        return patientAdditionalConsentRepository.findPatientAdditionalConsentForTeam(patientId, teamId)</span>
<span class="fc" id="L283">                .stream()</span>
<span class="fc" id="L284">                .map(patientAdditionalConsentMapper::entityToDataModel)</span>
<span class="fc" id="L285">                .collect(toList());</span>
    }

    @Transactional
    public void updatePatientAdditionalConsentsForTeam(long userId, long teamId, List&lt;PatientAdditionalConsent&gt; consents) {
<span class="fc" id="L290">        patientAdditionalConsentRepository.updatePatientAdditionalConsentsForTeam(userId, teamId);</span>
<span class="fc" id="L291">        patientAdditionalConsentRepository.saveAll(consents.stream().map(patientAdditionalConsentMapper::dataModelToEntity).collect(toList()));</span>
<span class="fc" id="L292">    }</span>

    @NotNull
    public List&lt;ConsentExpiryDecisionExisting&gt; findConsentExpiryDecisionsByConsentId(long consentId) {
<span class="fc" id="L296">        return consentExpiryDecisionRepository.findConsentExpiryDecisionsByConsentId(consentId)</span>
<span class="fc" id="L297">                .stream()</span>
<span class="fc" id="L298">                .map(consentExpiryDecisionMapper::entityToDataModel)</span>
<span class="fc" id="L299">                .collect(toList());</span>
    }

    @Transactional
    public void saveConsentExpiryDecision(ConsentExpiryDecision consentExpiryDecision) {
<span class="fc" id="L304">        consentExpiryDecisionRepository.save(consentExpiryDecisionMapper.dataModelToEntity(consentExpiryDecision));</span>
<span class="fc" id="L305">    }</span>

    @Transactional
    public void updateConsentExpiryDecision(ConsentExpiryDecisionExisting consentExpiryDecision) {
<span class="fc" id="L309">        consentExpiryDecisionRepository.save(consentExpiryDecisionMapper.dataModelToEntity(consentExpiryDecision));</span>
<span class="fc" id="L310">    }</span>


    public List&lt;Long&gt; getPatientIdsForConsentsInTeam(long teamId, List&lt;Long&gt; limitingSetOfPatientIds) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (limitingSetOfPatientIds.isEmpty()) {</span>
            // We don't have a limiting set; do what we did before and get everyone in the team
<span class="fc" id="L316">            return findConsentingPatientIdsForEntity(teamId, AccessingEntityType.TEAM);</span>

        } else {
            //We have a limiting set of patient ids that this can be. The batching is overkill, this will realistically
            // be a tiny number. But better safe than sorry.
<span class="fc" id="L321">            return DbUtil.getInBatches(limitingSetOfPatientIds, configuration.getPKBPersonListFetchSize(),</span>
                    batchOfIds -&gt;
<span class="fc" id="L323">                            patientConsentRepository.findActivePatientIdsForEntityTypeAndPatientId(AccessingEntityType.TEAM, List.of(teamId), batchOfIds));</span>
        }
    }

    public List&lt;Long&gt; getPatientIdsForConsentsForIndividual(long professionalId, List&lt;Long&gt; limitingSetOfPatientIds) {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (limitingSetOfPatientIds.isEmpty()) {</span>
            // We don't have a limiting set; get  all the individual's patients
<span class="fc" id="L330">            return findConsentingPatientIdsForEntity(professionalId, AccessingEntityType.INDIVIDUAL);</span>

        } else {
            //We have a limiting set of patient ids that this can be. The batching is overkill, this will realistically
            // be a tiny number. But better safe than sorry.
<span class="fc" id="L335">            return DbUtil.getInBatches(limitingSetOfPatientIds, configuration.getPKBPersonListFetchSize(),</span>
                            batchOfIds -&gt;
<span class="fc" id="L337">                                    patientConsentRepository.findActivePatientIdsForEntityTypeAndPatientId(AccessingEntityType.INDIVIDUAL, List.of(professionalId), batchOfIds));</span>
        }
    }


    public List&lt;Long&gt; findConsentingPatientIdsForEntity(long entityId, AccessingEntityType entityType) {
<span class="fc" id="L343">        return patientConsentRepository.findActivePatientConsentForEntityType(entityType, entityId)</span>
<span class="fc" id="L344">                .stream().map(it -&gt; it.getPatient().getId()).collect(Collectors.toUnmodifiableList());</span>
    }

    public List&lt;Long&gt; findPastConsentingPatientIdsForEntity(long entityId, AccessingEntityType entityType) {
<span class="fc" id="L348">        return patientConsentRepository.findPastConsentingPatientIdsForEntity(entityId, entityType);</span>
    }

    public boolean consentExistsInOrgNetwork(long patientId, long teamId) {
<span class="fc bfc" id="L352" title="All 2 branches covered.">        return patientConsentRepository.countOrgNetworkConsents(patientId, teamId) &gt; 0;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>