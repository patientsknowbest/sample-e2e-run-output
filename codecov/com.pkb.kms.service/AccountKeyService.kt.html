<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccountKeyService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.kms.service</a> &gt; <span class="el_source">AccountKeyService.kt</span></div><h1>AccountKeyService.kt</h1><pre class="source lang-java linenums">package com.pkb.kms.service

import com.pkb.crypto.UserPrivateKey
import com.pkb.crypto.dto.AccountKeysDTO
import com.pkb.crypto.dto.AccountPrivateKeyDTO
import com.pkb.kms.service.cache.AccountSymmetricKeysCacheService
import com.pkb.kms.service.cache.OrgAccessibleAccountPrivateKeyCacheService
import com.pkb.kms.service.cache.OrgAccountKeyCacheService
import com.pkb.kms.service.cache.UnauthenticatedAccountSymmetricKeyCacheService
import com.pkb.kms.service.cache.UserAccessibleAccountPrivateKeyCacheService
import com.pkb.kms.service.extension.recover
import com.pkb.kms.service.projection.OrgIds
import com.pkb.kms.shared.representation.AccountPublicId
import com.pkb.kms.shared.representation.KmsError
import io.vavr.control.Either
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import java.lang.invoke.MethodHandles
import javax.transaction.Transactional

<span class="fc" id="L22">@Service</span>
<span class="fc" id="L23">class AccountKeyService(private val orgAccessCache: OrgAccessibleAccountPrivateKeyCacheService,</span>
<span class="fc" id="L24">                        private val userAccessCache: UserAccessibleAccountPrivateKeyCacheService,</span>
<span class="fc" id="L25">                        private val accountSymmetricKeysCache: AccountSymmetricKeysCacheService,</span>
<span class="fc" id="L26">                        private val unauthenticatedAccountSymmetricKeyCache: UnauthenticatedAccountSymmetricKeyCacheService,</span>
<span class="fc" id="L27">                        private val keyBuilder: AccountKeysDTOBuilder,</span>
<span class="fc" id="L28">                        private val orgAccountKeyCacheService: OrgAccountKeyCacheService) {</span>

<span class="fc" id="L30">    private val log: Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())</span>

    /**
     * Returns a collection of plaintext keys for an account.
     *
     * If the keys are not cached, attempts to find any cached org account key that can be used to access the account
     * keys and loads/decrypts as necessary
     */
    @Transactional
    fun getAccountKeys(accountPublicId: AccountPublicId) =
<span class="fc" id="L40">        orgAccessCache.getAccountPrivateKeyViaAnyOrgKey(accountPublicId)</span>
<span class="fc" id="L41">            .map { keyBuilder.makeAccountKeys(accountPublicId, it) }</span>
<span class="fc" id="L42">            .recover {</span>
                // TODO: When we implement pipelining we can check this cache in the same roundtrip as the org cache
<span class="fc" id="L44">                userAccessCache.getCachedAccountPrivateKey(accountPublicId)</span>
<span class="fc" id="L45">                    .map { keyBuilder.makeAccountKeys(accountPublicId, it) }</span>
<span class="fc" id="L46">            }</span>

<span class="fc" id="L48">    fun getAccountKeys(accountPublicIds: Collection&lt;AccountPublicId&gt;, skipSymmetricKeys: Boolean = false): List&lt;AccountKeysDTO&gt; =</span>
<span class="fc" id="L49">        accountPublicIds.toSet()</span>
<span class="fc" id="L50">            .map { Either.left&lt;AccountPublicId, AccountKeysDTO&gt;(it) }</span>
<span class="fc" id="L51">            .let { tryNextMultiLoadStep(it, orgAccessCache::getAccountPrivateKeysViaAnyOrgKey, skipSymmetricKeys) }</span>
<span class="fc" id="L52">            .let { tryNextMultiLoadStep(it, userAccessCache::getCachedAccountPrivateKeys, skipSymmetricKeys) }</span>
<span class="fc" id="L53">            .let { results -&gt;</span>
<span class="fc" id="L54">                results</span>
<span class="fc" id="L55">                    .partition { it.isRight }</span>
<span class="fc" id="L56">                    .let { (loaded, notLoaded) -&gt;</span>
<span class="fc" id="L57">                        log.info(&quot;The following account keys were not available in batch load: {}&quot;, notLoaded.map { it.left })</span>
<span class="fc" id="L58">                        loaded.map { it.get() }</span>
                    }
<span class="fc" id="L60">            }</span>

    private fun tryNextMultiLoadStep(
        priorLoadResults: List&lt;Either&lt;AccountPublicId, AccountKeysDTO&gt;&gt;,
        loader: (accountPublicIds: List&lt;AccountPublicId&gt;) -&gt; Map&lt;AccountPublicId, AccountPrivateKeyDTO&gt;,
        skipSymmetryKeys: Boolean
    ): List&lt;Either&lt;AccountPublicId, AccountKeysDTO&gt;&gt; =
<span class="fc" id="L67">        priorLoadResults</span>
<span class="fc" id="L68">            .partition { it.isRight }</span>
<span class="fc" id="L69">            .let { (alreadyLoaded, toLoad) -&gt;</span>
<span class="fc" id="L70">                val newlyLoaded = loader(toLoad.map { it.left })</span>
<span class="fc" id="L71">                alreadyLoaded +</span>
<span class="fc" id="L72">                        newlyLoaded.map { (accountPublicId, accountPrivateKeyDTO) -&gt; Either.right(keyBuilder.makeAccountKeys(accountPublicId, accountPrivateKeyDTO, skipSymmetryKeys)) } +</span>
<span class="fc" id="L73">                        toLoad.filterNot { newlyLoaded.containsKey(it.left) }</span>
<span class="fc" id="L74">            }</span>

    /**
     * Returns a collection of plaintext keys for an account, using [userPrivateKey] to decrypt the keys in [accountPath].
     *
     * Will return cached keys if available. An org account key will be used if necessary.
     */
    @Transactional
    fun getAccountKeysInPath(userPrivateKey: UserPrivateKey, accountPath: AccountPath): Either&lt;KmsError, AccountKeysDTO&gt; {
            // Load key from org or user cache based on presence of org key
<span class="fc bfc" id="L84" title="All 2 branches covered.">            val key = if (accountPath.orgAccountKey != null) {</span>
<span class="fc" id="L85">                orgAccessCache.getAccountPrivateKeyInPath(userPrivateKey, accountPath)</span>
            } else {
<span class="fc" id="L87">                userAccessCache.getAccountPrivateKeyInPath(userPrivateKey, accountPath)</span>
            }

<span class="fc" id="L90">            return key.map { keyBuilder.makeAccountKeys(accountPath.accountPublicId, it) }</span>
    }

    /**
     * Returns a collection of plaintext keys for an account.
     *
     * If the keys are not cached, looks in the cache for the relevant org account key and decrypts as necessary
     *
     * Similar in function to [getAccountKeys] but does not have to query the database for any usable org key, it just
     * uses the one specified in the path
     */
    @Transactional
    fun getAccountKeysInPathNoUser(accountPath: AccountPath): Either&lt;KmsError, AccountKeysDTO&gt; =
<span class="fc" id="L103">            orgAccessCache.getAccountPrivateKeyInPathNoUser(accountPath)</span>
<span class="fc" id="L104">                .map { keyBuilder.makeAccountKeys(accountPath.accountPublicId, it) }</span>


    /**
     * Returns a collection of plaintext keys for an account, using [userPrivateKey] to decrypt the keys in [accountPath].
     *
     * Will ignore cached keys, but will cache the result. An org account key will be used if necessary.
     */
    @Transactional
    fun getAccountKeysInPathNoCache(userPrivateKey: UserPrivateKey,
                                    accountPath: AccountPath): Either&lt;KmsError, AccountKeysDTO&gt; =
<span class="fc" id="L115">            keyBuilder.makeAccountKeysFromPathNoCache(userPrivateKey, accountPath)</span>
<span class="fc" id="L116">                    .peek {</span>
<span class="fc" id="L117">                        storeInCache(it, accountPath)</span>
<span class="fc" id="L118">                    }</span>

    fun getOrgAccountKeys(org: OrgIds): Either&lt;KmsError, AccountKeysDTO&gt; =
<span class="nc" id="L121">            orgAccountKeyCacheService.getCachedOrgAccountKey(org.id).map { keyBuilder.makeAccountKeys(org.orgAccountIds.publicId, AccountPrivateKeyDTO.accountPrivateKeyDTO(it.accountPrivateKey)) }</span>

    /**
     * Returns a collection of plaintext keys for an account, using the org key in the path if and only if that org
     * key is currently cached.
     */
    @Transactional
    fun getAccountKeysInPathNoUserNoCache(accountPath: AccountPath): Either&lt;KmsError, AccountKeysDTO&gt; =
<span class="nc" id="L129">            keyBuilder.makeAccountKeysFromPathNoUserNoCache(accountPath)</span>
<span class="nc" id="L130">                    .peek {</span>
<span class="nc" id="L131">                        storeInCache(it, accountPath)</span>
<span class="nc" id="L132">                }</span>

<span class="nc" id="L134">    fun evictAll(includeUnauthenticatedSymmetricKey: Boolean = false) {</span>
<span class="fc" id="L135">        accountSymmetricKeysCache.clearState()</span>
<span class="fc" id="L136">        orgAccessCache.clearState()</span>
<span class="fc" id="L137">        userAccessCache.clearState()</span>

<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (includeUnauthenticatedSymmetricKey) {</span>
<span class="fc" id="L140">            unauthenticatedAccountSymmetricKeyCache.clearState()</span>
        }
<span class="fc" id="L142">    }</span>

<span class="nc" id="L144">    fun evictKeysForAccount(accountPublicId: AccountPublicId, includeUnauthenticatedSymmetricKey: Boolean = false) {</span>
<span class="nc" id="L145">        accountSymmetricKeysCache.evictKeysForAccount(accountPublicId)</span>
<span class="nc" id="L146">        orgAccessCache.evictKeysForAccount(accountPublicId)</span>
<span class="nc" id="L147">        userAccessCache.evictKeysForAccount(accountPublicId)</span>

<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (includeUnauthenticatedSymmetricKey) {</span>
<span class="nc" id="L150">            unauthenticatedAccountSymmetricKeyCache.evictKeyForAccount(accountPublicId)</span>
        }
<span class="nc" id="L152">    }</span>

    private fun storeInCache(accountKeysDTO: AccountKeysDTO, accountPath: AccountPath?) {
        // We always use the org key if present, so it's safe to assume that if there's an org key in the path then
        // it is cached and we can safely put the account private key in an expiring cache. This is safe against race
        // conditions because the account key never changes - worst case is we write it to the new cache again
<span class="pc bpc" id="L158" title="1 of 4 branches missed.">        if (accountPath?.orgAccountKey != null) {</span>
<span class="fc" id="L159">            orgAccessCache.addToCache(accountKeysDTO)</span>
        } else {
<span class="fc" id="L161">            userAccessCache.addToCache(accountKeysDTO)</span>
        }

        // We don't bother caching the symmetric keys at this point; the next request will load them fresh. This avoids
        // any nasty race conditions if two instances of the kms try to migrate keys at the same time
<span class="fc" id="L166">    }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>