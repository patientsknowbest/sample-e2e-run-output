<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExternalPasswordRecoveryService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.kms.service</a> &gt; <span class="el_source">ExternalPasswordRecoveryService.kt</span></div><h1>ExternalPasswordRecoveryService.kt</h1><pre class="source lang-java linenums">package com.pkb.kms.service

import com.pkb.common.datetime.DateTimeService
import com.pkb.crypto.EncryptedSymmetricKey
import com.pkb.crypto.EncryptedSymmetricKey.encryptedSymmetricKey
import com.pkb.crypto.EncryptedUserPrivateKey
import com.pkb.crypto.EncryptedUserPrivateKey.encryptedUserPrivateKey
import com.pkb.crypto.SymmetricKey
import com.pkb.crypto.SymmetricKey.symmetricKey
import com.pkb.crypto.UserPrivateKey
import com.pkb.kms.service.cache.UserPrivateKeyCacheService
import com.pkb.kms.service.entity.KmsExternalPasswordRecovery
import com.pkb.kms.service.entity.KmsExternalPasswordRecoveryChangeHistory
import com.pkb.kms.service.entity.KmsExternalPasswordRecoveryCurrent
import com.pkb.kms.service.extension.decrypt
import com.pkb.kms.service.extension.encrypt
import com.pkb.kms.service.external.ExternalEncryptionService
import com.pkb.kms.service.repository.ExternalPasswordRecoveryChangeHistoryRepository
import com.pkb.kms.service.repository.ExternalPasswordRecoveryCurrentRepository
import com.pkb.kms.service.repository.ExternalPasswordRecoveryRepository
import com.pkb.kms.shared.representation.KmsError
import com.pkb.kms.shared.representation.PersonPublicId
import io.vavr.control.Either
import io.vavr.control.Either.right
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import java.lang.invoke.MethodHandles
import java.time.Instant
import javax.transaction.Transactional

<span class="fc" id="L32">@Service</span>
<span class="fc" id="L33">class ExternalPasswordRecoveryService(</span>
<span class="fc" id="L34">        private val userPrivateKeyCacheService: UserPrivateKeyCacheService,</span>
<span class="fc" id="L35">        private val externalEncryptionService: ExternalEncryptionService,</span>
<span class="fc" id="L36">        private val passwordRecoveryRepository: ExternalPasswordRecoveryRepository,</span>
<span class="fc" id="L37">        private val passwordRecoveryCurrentRepository: ExternalPasswordRecoveryCurrentRepository,</span>
<span class="fc" id="L38">        private val passwordRecoveryChangeHistoryRepository: ExternalPasswordRecoveryChangeHistoryRepository,</span>
<span class="fc" id="L39">        private val dateTimeService: DateTimeService) {</span>

<span class="fc" id="L41">    private val log: Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())</span>

    fun findRecoveryRecord(personPublicId: PersonPublicId): Either&lt;KmsError, UserPrivateKey&gt; =
<span class="fc" id="L44">            passwordRecoveryRepository.findCurrentForPerson(personPublicId)</span>
<span class="fc" id="L45">                    .map { recoveryRecord -&gt;</span>

                        // Decrypt symmetric key and prepare user private key
<span class="fc" id="L48">                        val symmetricKeyBytes = externalEncryptionService.decrypt(recoveryRecord.encryptedSymmetricKey)</span>
<span class="fc" id="L49">                        val symmetricKey = symmetricKey(symmetricKeyBytes, recoveryRecord.secretKeyAlgorithm)</span>
<span class="fc" id="L50">                        val encryptedUserPrivateKey = encryptedUserPrivateKey(</span>
<span class="fc" id="L51">                                recoveryRecord.encryptedUserPrivateKey, recoveryRecord.privateKeyAlgorithm)</span>

                        // Recover the user private key
<span class="fc" id="L54">                        symmetricKey.decrypt(encryptedUserPrivateKey, recoveryRecord.nonce)</span>
<span class="fc" id="L55">                                .also { log.info(&quot;Recovered user private key for {}&quot;, personPublicId) }</span>
<span class="pc" id="L56">                    }.toEither { KmsError.recoveryRecordNotFound(personPublicId) }</span>

    fun encryptUserPrivateKey(personPublicId: PersonPublicId) =
<span class="fc" id="L59">            encryptUserPrivateKey(personPublicId, SymmetricKeyAndNonce.newInstance())</span>

    fun encryptUserPrivateKey(personPublicId: PersonPublicId, symmetricKeyAndNonce: SymmetricKeyAndNonce): Either&lt;KmsError, RecoveryData&gt; =
<span class="fc" id="L62">            userPrivateKeyCacheService.getCachedUserPrivateKey(personPublicId)</span>
<span class="fc" id="L63">                    .flatMap { userPrivateKey -&gt;</span>

<span class="fc" id="L65">                        val (symmetricKey, nonce) = symmetricKeyAndNonce</span>

                        // Encrypt user key with symmetric key
<span class="fc" id="L68">                        val encryptedUserPrivateKey = symmetricKey.encrypt(userPrivateKey, nonce)</span>

                        // Externally-encrypt symmetric key
<span class="fc" id="L71">                        val encryptedSymmetricKeyBytes = externalEncryptionService.encrypt(symmetricKey.keyBytes)</span>
<span class="fc" id="L72">                        val encryptedSymmetricKey = encryptedSymmetricKey(encryptedSymmetricKeyBytes, symmetricKey.algorithm)</span>

<span class="fc" id="L74">                        right(RecoveryData(encryptedUserPrivateKey, nonce, encryptedSymmetricKey))</span>
<span class="fc" id="L75">                    }</span>

    @Transactional
    fun createNewRecoveryRecord(personPublicId: PersonPublicId, recoveryData: RecoveryData): Either&lt;KmsError, KmsExternalPasswordRecoveryCurrent&gt; {

        // Use consistent timestamp for all database operations
<span class="fc" id="L81">        val now = dateTimeService.now()</span>

        // Create new recovery record
<span class="fc" id="L84">        val recoveryRecord = passwordRecoveryRepository.save(createRecoveryRecord(recoveryData, now))</span>

        // Find or create pointer record and update it to point to the new recovery record
<span class="fc" id="L87">        val current = findOrCreateCurrentPointer(personPublicId, recoveryRecord, now)</span>
<span class="fc" id="L88">                .apply {</span>
<span class="fc" id="L89">                    externalPasswordRecovery = recoveryRecord</span>
<span class="fc" id="L90">                    updated = now</span>
<span class="fc" id="L91">                }</span>

        // Save and return
<span class="fc" id="L94">        return passwordRecoveryCurrentRepository.save(current)</span>
<span class="fc" id="L95">                .also { log.info(&quot;Created external password recovery record for person {}&quot;, personPublicId) }</span>
<span class="fc" id="L96">                .let { right(it) }</span>
    }

    @Transactional
    fun expireRecoveryRecord(personPublicId: PersonPublicId) {
<span class="nc" id="L101">        val now = dateTimeService.now()</span>
<span class="nc" id="L102">        passwordRecoveryCurrentRepository.findByPersonPublicId(personPublicId)</span>
<span class="nc" id="L103">                .peek {</span>
                    // We're going to delete this pointer, so write a history entry
<span class="nc" id="L105">                    passwordRecoveryChangeHistoryRepository.save(KmsExternalPasswordRecoveryChangeHistory(</span>
<span class="nc" id="L106">                            personPublicId = personPublicId,</span>
<span class="nc" id="L107">                            externalPasswordRecovery = it.externalPasswordRecovery,</span>
<span class="nc" id="L108">                            from = it.updated,</span>
<span class="nc" id="L109">                            until = now))</span>

<span class="nc" id="L111">                    passwordRecoveryCurrentRepository.delete(it)</span>
<span class="nc" id="L112">                    log.info(&quot;Deleted external password recovery record for person {}&quot;, personPublicId)</span>
<span class="nc" id="L113">                }</span>
<span class="nc" id="L114">    }</span>

    private fun createRecoveryRecord(recoveryData: RecoveryData, now: Instant) =
<span class="fc" id="L117">            KmsExternalPasswordRecovery(</span>
<span class="fc" id="L118">                    encryptedUserPrivateKey = recoveryData.encryptedPrivateKey.encryptedKeyBytes,</span>
<span class="fc" id="L119">                    privateKeyAlgorithm = recoveryData.encryptedPrivateKey.algorithm,</span>
<span class="fc" id="L120">                    encryptedSymmetricKey = recoveryData.encryptedSymmetricKey.encryptedKeyBytes,</span>
<span class="fc" id="L121">                    secretKeyAlgorithm = recoveryData.encryptedSymmetricKey.algorithm,</span>
<span class="fc" id="L122">                    nonce = recoveryData.nonce,</span>
<span class="fc" id="L123">                    created = now</span>
<span class="fc" id="L124">            )</span>

    private fun findOrCreateCurrentPointer(personPublicId: PersonPublicId, recoveryRecord: KmsExternalPasswordRecovery, now: Instant) =
<span class="fc" id="L127">            passwordRecoveryCurrentRepository.findByPersonPublicId(personPublicId)</span>
<span class="pc" id="L128">                    .peek {</span>
                        // We're going to modify this pointer, so write a history entry
<span class="nc" id="L130">                        passwordRecoveryChangeHistoryRepository.save(KmsExternalPasswordRecoveryChangeHistory(</span>
<span class="nc" id="L131">                                personPublicId = personPublicId,</span>
<span class="nc" id="L132">                                externalPasswordRecovery = it.externalPasswordRecovery,</span>
<span class="nc" id="L133">                                from = it.updated,</span>
<span class="nc" id="L134">                                until = now))</span>
<span class="nc" id="L135">                    }</span>
<span class="fc" id="L136">                    .getOrElse {</span>
                        // If there's no current pointer record, create one
<span class="fc" id="L138">                        KmsExternalPasswordRecoveryCurrent(</span>
<span class="fc" id="L139">                                personPublicId = personPublicId,</span>
<span class="fc" id="L140">                                externalPasswordRecovery = recoveryRecord,</span>
<span class="fc" id="L141">                                updated = now)</span>
<span class="fc" id="L142">                    }</span>

    private fun KmsError.Companion.recoveryRecordNotFound(personPublicId: PersonPublicId) =
<span class="nc" id="L145">            KmsError(&quot;recovery.record.not.found&quot;,</span>
<span class="nc" id="L146">                    &quot;Person $personPublicId does not have an external password recovery record&quot;,</span>
<span class="nc" id="L147">                    KmsError.Type.NOT_FOUND)</span>

<span class="pc" id="L149">    data class SymmetricKeyAndNonce(val symmetricKey: SymmetricKey, val nonce: ByteArray) {</span>
        override fun equals(other: Any?): Boolean {
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (this === other) return true</span>
<span class="nc bnc" id="L152" title="All 4 branches missed.">            if (javaClass != other?.javaClass) return false</span>

<span class="nc" id="L154">            other as SymmetricKeyAndNonce</span>

<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (symmetricKey != other.symmetricKey) return false</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (!nonce.contentEquals(other.nonce)) return false</span>

<span class="nc" id="L159">            return true</span>
        }

        override fun hashCode(): Int {
<span class="nc" id="L163">            var result = symmetricKey.hashCode()</span>
<span class="nc" id="L164">            result = 31 * result + nonce.contentHashCode()</span>
<span class="nc" id="L165">            return result</span>
        }

        companion object {
            fun newInstance(): SymmetricKeyAndNonce {
<span class="fc" id="L170">                val symmetricKey = SymmetricKey.newInstance()</span>
<span class="fc" id="L171">                val nonce = symmetricKey.generateNonce(SymmetricKey.DEFAULT_RANDOM_SOURCE)</span>
<span class="fc" id="L172">                return SymmetricKeyAndNonce(symmetricKey, nonce)</span>
            }
        }
    }

<span class="fc" id="L177">    data class RecoveryData(val encryptedPrivateKey: EncryptedUserPrivateKey,</span>
<span class="fc" id="L178">                            val nonce: ByteArray,</span>
<span class="fc" id="L179">                            val encryptedSymmetricKey: EncryptedSymmetricKey) {</span>

        override fun equals(other: Any?): Boolean {
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (this === other) return true</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">            if (javaClass != other?.javaClass) return false</span>

<span class="nc" id="L185">            other as RecoveryData</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (encryptedPrivateKey != other.encryptedPrivateKey) return false</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (!nonce.contentEquals(other.nonce)) return false</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (encryptedSymmetricKey != other.encryptedSymmetricKey) return false</span>

<span class="nc" id="L191">            return true</span>
        }

        override fun hashCode(): Int {
<span class="nc" id="L195">            var result = encryptedPrivateKey.hashCode()</span>
<span class="nc" id="L196">            result = 31 * result + nonce.contentHashCode()</span>
<span class="nc" id="L197">            result = 31 * result + encryptedSymmetricKey.hashCode()</span>
<span class="nc" id="L198">            return result</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>