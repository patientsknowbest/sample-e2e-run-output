<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuestionnaireResponseService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.domain.questionnaire</a> &gt; <span class="el_source">QuestionnaireResponseService.java</span></div><h1>QuestionnaireResponseService.java</h1><pre class="source lang-java linenums">package com.pkb.domain.questionnaire;

import com.google.common.annotations.VisibleForTesting;
import com.pkb.authentication.principal.user.AuthenticatedSystemUser;
import com.pkb.authz.AuthorizationService;
import com.pkb.authz.data.AuthorizationData;
import com.pkb.datamodel.team.Team;
import com.pkb.domain.criteria.CriteriaResult;
import com.pkb.domain.criteria.ImmutableCriteriaResult;
import com.pkb.domain.criteria.TemporalRangeRestriction;
import com.pkb.questionnaireservice.client.QuestionnaireServiceClient;
import com.pkb.questionnaireservice.modelv2.QuestionnaireResponse;
import com.pkb.util.CorrelationIdUtil;
import io.vavr.collection.List;
import io.vavr.control.Either;
import io.vavr.control.Option;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.UUID;
import java.util.function.Function;

import static com.pkb.domain.criteria.LowerBound.GREATER;
import static com.pkb.domain.criteria.LowerBound.GREATER_OR_EQUAL;
import static com.pkb.domain.criteria.UpperBound.LESS;
import static com.pkb.domain.criteria.UpperBound.LESS_OR_EQUAL;
import static io.vavr.API.$;
import static io.vavr.API.Case;
import static io.vavr.API.Match;
import static java.lang.invoke.MethodHandles.lookup;
import static org.slf4j.LoggerFactory.getLogger;

public class QuestionnaireResponseService {

    private final AuthorizationService authorizationService;

    private final QuestionnaireServiceClient questionnaireServiceClient;

    private final CorrelationIdUtil correlationIdUtil;

<span class="fc" id="L44">    private static final Logger LOGGER = getLogger(lookup().lookupClass());</span>

    public QuestionnaireResponseService(AuthorizationService authorizationService,
<span class="fc" id="L47">            QuestionnaireServiceClient questionnaireServiceClient, CorrelationIdUtil correlationIdUtil) {</span>
<span class="fc" id="L48">        this.authorizationService = authorizationService;</span>
<span class="fc" id="L49">        this.questionnaireServiceClient = questionnaireServiceClient;</span>
<span class="fc" id="L50">        this.correlationIdUtil = correlationIdUtil;</span>
<span class="fc" id="L51">    }</span>

    public Either&lt;RuntimeException, CriteriaResult&lt;QuestionnaireResponse&gt;&gt; findQuestionnaireResponses(AuthorizationData authData,
            QuestionnaireResponseSearchCriteria criteria) {
<span class="fc" id="L55">        return authorizationService.authorize(authData)</span>
<span class="fc" id="L56">                .checkFilteredSingleResult(tm -&gt; </span>
                        // TODO: MFA - If we're searching for a patient who is e.g. access frozen, we 
                        // _aren't_ filtering those here. We'll need to resolve this before allowing 
                        // patients access to this API (currently they aren't supported)
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">                        tm.targetType() == QuestionnaireResponse.class</span>
                        , () -&gt; {
                    // Only supported for system user right now
<span class="fc" id="L63">                    AuthenticatedSystemUser systemUser = authData.inputs().requireAuthenticatedSystemUser();</span>
<span class="fc" id="L64">                    var teamIds = systemUser.getTeamsWithOrg().map(Team::getPublicId);</span>
<span class="fc" id="L65">                    return questionnaireServiceClient.getQuestionnaireResponsesWithinOrg(</span>
<span class="fc" id="L66">                            correlationIdUtil.get(),</span>
<span class="fc" id="L67">                            systemUser.getOrgPublicId(),</span>
<span class="fc" id="L68">                            teamIds.asJava(),</span>
<span class="fc" id="L69">                            criteria.patientId().toJavaList(),</span>
<span class="fc" id="L70">                            criteria.questionnaireId().getOrElse((UUID) null),</span>
<span class="fc" id="L71">                            ltInstant(criteria.authored()),</span>
                            null, // See comment for ltInstant
                            null, // See comment for ltInstant
<span class="fc" id="L74">                            geInstant(criteria.authored()),</span>
<span class="fc" id="L75">                            criteria.getPageSize())</span>
<span class="fc" id="L76">                            .map(responses -&gt; (CriteriaResult&lt;QuestionnaireResponse&gt;) ImmutableCriteriaResult.&lt;QuestionnaireResponse&gt; builder()</span>
<span class="fc" id="L77">                                    .page(List.ofAll(responses.getResultsPage()))</span>
<span class="fc" id="L78">                                    .total(responses.getTotalResults())</span>
<span class="fc" id="L79">                                    .build())</span>
<span class="pc" id="L80">                            .fold(qsError -&gt; Either.&lt;RuntimeException, CriteriaResult&lt;QuestionnaireResponse&gt;&gt;left(new RuntimeException(qsError.getMessage())),</span>
<span class="fc" id="L81">                                    qrs -&gt; Either.&lt;RuntimeException, CriteriaResult&lt;QuestionnaireResponse&gt;&gt;right(qrs));</span>
                    //we will ignore auth errors for search operations and just return empty results.
<span class="fc" id="L83">                }).fold(</span>
                        ignored -&gt; {
<span class="fc" id="L85">                            LOGGER.error(&quot;User not authorised for questionnaire response search. Returning empty results. Error was: &quot;, ignored);</span>
<span class="fc" id="L86">                            return Either.&lt;RuntimeException, CriteriaResult&lt;QuestionnaireResponse&gt;&gt; right(CriteriaResult.emptyCriteriaResult());</span>
<span class="fc" id="L87">                        }, Function.identity());</span>

    }

    /**
     * Convert TemporalRangeRestriction&lt;LocalDate&gt; to a series of Instants which the questionnaire
     * service client expects to receive.
     * 
     * Compare with BoundedDateRangeRestrictions class which does the same but transforming to a database
     * query. 
     * 
     * Note that because we're translating from a discrete series (LocalDate) to a continuous series (Instant), upper 
     * bounds always become `&lt;` and lower bounds always become `&gt;=`, see examples:
     * 
     * &lt; '01/02/2020' should match '31/01/2020 23:59:59.999' and not '01/02/2020 00:00:00.000', this bound translates 
     * to &lt; '01/02/2020 00:00:00.000'
     * 
     * &lt;= '01/02/2020' should match '01/02/2020 23:59:59.999' and not '02/02/2020 00:00:00.999', this bound translates
     * to &lt; '02/02/2020 00:00:00.000'
     * 
     * &gt; '01/02/2020' should match '02/02/2020 00:00:00.000' and not '01/02/2020 23:59:59.999', this bound translates 
     * to &gt;= '02/02/2020 00:00:00.000''
     * 
     * &gt;= '01/02/2020' should match '01/02/2020 00:00:00.000' and not '31/01/2020 23:59:59.999' this bound translates 
     * to &gt;= '01/02/2020 00:00:00.000'
     * 
     * = '01/02/2020' should match '01/02/2020 00:00:00.000' and '01/02/2020 23:59:59.999', and it should not match
     * '31/01/2020 23:59:59.999' or '02/02/2020 00:00:00.000', this bound translates to
     * &gt;= '01/02/2020 00:00:00.000' &amp;&amp; &lt; '02/02/2020 00:00:00.000'
     */
    
    @VisibleForTesting
    @Nullable Instant ltInstant(Option&lt;TemporalRangeRestriction&lt;LocalDate&gt;&gt; authored) {
<span class="fc" id="L120">        return authored.flatMap(TemporalRangeRestriction::getEquality)</span>
<span class="pc" id="L121">                .map(eq -&gt; eq.atStartOfDay().plusDays(1).toInstant(ZoneOffset.UTC))</span>
<span class="fc" id="L122">                .orElse(() -&gt; authored.flatMap(TemporalRangeRestriction::getUpperBound)</span>
<span class="fc" id="L123">                        .map(ub -&gt; Match(ub.getConstraint()).of(</span>
<span class="fc" id="L124">                                Case($(LESS_OR_EQUAL), () -&gt; ub.getValue().atStartOfDay().plusDays(1).toInstant(ZoneOffset.UTC)),</span>
<span class="fc" id="L125">                                Case($(LESS), () -&gt; ub.getValue().atStartOfDay().toInstant(ZoneOffset.UTC))</span>
                        )))
<span class="fc" id="L127">                .getOrElse((Instant) null);</span>
    }
    
    @VisibleForTesting
    @Nullable Instant geInstant(Option&lt;TemporalRangeRestriction&lt;LocalDate&gt;&gt; authored) {
<span class="fc" id="L132">        return authored</span>
<span class="fc" id="L133">                .flatMap(TemporalRangeRestriction::getEquality)</span>
<span class="pc" id="L134">                .map(eq -&gt; eq.atStartOfDay().toInstant(ZoneOffset.UTC))</span>
<span class="fc" id="L135">                .orElse(() -&gt; authored</span>
<span class="fc" id="L136">                        .flatMap(TemporalRangeRestriction::getLowerBound)</span>
<span class="fc" id="L137">                        .map(lb -&gt; Match(lb.getConstraint()).of(</span>
<span class="fc" id="L138">                                Case($(GREATER_OR_EQUAL), () -&gt; lb.getValue().atStartOfDay().toInstant(ZoneOffset.UTC)),</span>
<span class="fc" id="L139">                                Case($(GREATER), () -&gt; lb.getValue().atStartOfDay().plusDays(1).toInstant(ZoneOffset.UTC))</span>
                        )))
<span class="fc" id="L141">                .getOrElse((Instant) null); </span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>