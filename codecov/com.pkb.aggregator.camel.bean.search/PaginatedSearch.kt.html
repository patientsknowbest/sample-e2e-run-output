<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PaginatedSearch.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.aggregator.camel.bean.search</a> &gt; <span class="el_source">PaginatedSearch.kt</span></div><h1>PaginatedSearch.kt</h1><pre class="source lang-java linenums">package com.pkb.aggregator.camel.bean.search

import com.pkb.aggregator.camel.CAMELFHIR_URL_HEADER
import com.pkb.aggregator.service.paginate.PaginatedBundleProcessingResult
import org.apache.camel.Body
import org.apache.camel.Exchange
import org.apache.camel.ExchangeProperties
import org.apache.camel.ExchangeProperty
import org.apache.camel.Headers
import org.hl7.fhir.instance.model.api.IAnyResource
import org.hl7.fhir.instance.model.api.IBaseBundle

/**
 * Provides default behaviour for fhir searches that might return more resources than fit in a single response and
 * thus need paginating.
 *
 * The pagination process checks for a populated `next` link in the bundle and pushes it to a queue of links still to
 * be processed, then pops the head off that list and sets it as the next link to retrieve
 */
interface PaginatedSearch {

    /**
     * Processes the bundle in the current exchange, then if there's another page it sets the link in the CamelFhir.url
     * message property and returns the same fhir endpoint that the current bundle came from (since the next page is
     * going to come from the same upstream fhir store).
     *
     * It is intended you call this from Camel's Dynamic Router component, which will automatically make the next
     * request in a sort of tail-recursive sequence (which we ultimately terminate by returning null)
     */
    fun paginate(
        exchange: Exchange,
        @Body bundles: Iterable&lt;IBaseBundle&gt;,
        @Headers headers: MutableMap&lt;String, Any&gt;,
        @ExchangeProperties properties: MutableMap&lt;String, Any&gt;,
        // We need to request this parameter separate from [properties] because it's an internal value not exposed in
        // the normal properties map (but we do need it, to correctly route the next request if there is one)
        @ExchangeProperty(Exchange.RECIPIENT_LIST_ENDPOINT) endpoint: String?,
    ): String? {

<span class="nc" id="L40">        val resources = getAccumulatedResources(properties)</span>
<span class="nc" id="L41">        val links = getAccumulatedPageLinks(properties)</span>

<span class="nc" id="L43">        bundles</span>
<span class="nc" id="L44">            .map {</span>
<span class="nc" id="L45">                processBundle(it)</span>
<span class="nc" id="L46">            }.forEach {</span>
<span class="nc" id="L47">                resources.addAll(it.pageResources)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">                it.nextLink?.apply {</span>
<span class="nc" id="L49">                    links.add(this)</span>
<span class="nc" id="L50">                }</span>
<span class="nc" id="L51">            }</span>

<span class="nc" id="L53">        val next = links.removeFirstOrNull()</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">        return if (next != null) {</span>
<span class="nc" id="L55">            headers[CAMELFHIR_URL_HEADER] = next</span>
<span class="nc" id="L56">            endpoint</span>
        } else {
            // Return null to indicate there's no more pages to retrieve
<span class="nc" id="L59">            null</span>
        }
    }

    fun getAccumulatedResources(properties: Map&lt;String, Any&gt;): MutableList&lt;IAnyResource&gt;

    fun getAccumulatedPageLinks(properties: Map&lt;String, Any&gt;): MutableList&lt;String&gt;

    fun processBundle(bundle: IBaseBundle): PaginatedBundleProcessingResult
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>