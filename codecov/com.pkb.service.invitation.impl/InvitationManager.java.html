<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InvitationManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.invitation.impl</a> &gt; <span class="el_source">InvitationManager.java</span></div><h1>InvitationManager.java</h1><pre class="source lang-java linenums">package com.pkb.service.invitation.impl;

import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.EHRSearch;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.app.entity.PKBFilter;
import com.pkb.app.entity.SourceDetails;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.crypto.util.RandomUtil;
import com.pkb.datamodel.Email;
import com.pkb.datamodel.consent.ImmutablePatientConsentUpdateDTO;
import com.pkb.datamodel.consent.ImmutableSourceDTO;
import com.pkb.datamodel.consent.PatientConsentUpdateDTO;
import com.pkb.datamodel.consent.SourceDTO;
import com.pkb.datamodel.team.TeamWithOrg;
import com.pkb.domain.InvitationService;
import com.pkb.domain.duplicate.TeamDomainService;
import com.pkb.encounter.entity.PKBInvitation;
import com.pkb.encounter.entity.PKBInvitationDetail;
import com.pkb.entities.doc.DocInvitation;
import com.pkb.entities.embeddables.EncodedEncryptedPrivateKeyInfoWithSecretDeriv;
import com.pkb.entities.enums.AccessingEntityType;
import com.pkb.entities.enums.ContactType;
import com.pkb.entities.enums.InvitationStatus;
import com.pkb.entities.enums.InvitationType;
import com.pkb.entities.enums.MenuDataType;
import com.pkb.entities.enums.PrivacyFlag;
import com.pkb.entities.enums.SponsorshipStatus;
import com.pkb.entities.enums.UserType;
import com.pkb.exception.MailException;
import com.pkb.exception.PKBException;
import com.pkb.institute.entity.InstituteUser;
import com.pkb.institute.entity.Team;
import com.pkb.mappers.AccountPrivateKeyMapper;
import com.pkb.mappers.PKBInvitationMapper;
import com.pkb.model.PKBPersonDTO;
import com.pkb.service.document.DocumentManager;
import com.pkb.service.emailmessage.impl.PKBEmailMessageManager;
import com.pkb.service.instituteuser.InstituteUserManager;
import com.pkb.service.patientconsent.PatientConsentManager;
import com.pkb.service.team.TeamManager;
import com.pkb.service.team.TeamUserManager;
import com.pkb.service.user.impl.PersonContactManager;
import com.pkb.service.user.impl.UserManager;
import com.pkb.service.uuid.UUIDProvider;
import com.pkb.user.entity.PKBPerson;
import com.pkb.user.entity.PersonContact;
import com.pkb.util.PersonAmbiguityHandler;
import com.pkb.util.tolven.ConvertUtil;
import com.pkb.util.tolven.TolvenBeanFactory;
import com.pkb.util.tolven.TransactionManager;
import io.vavr.control.Either;
import io.vavr.control.Option;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tolven.core.entity.Account;

import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import static com.pkb.entities.enums.ConsentReason.EXPLICIT_CONSENT;
import static com.pkb.entities.enums.InvitationStatus.ACCEPTED;
import static com.pkb.entities.enums.InvitationStatus.NEW;
import static com.pkb.entities.enums.UserStatus.EMAIL_CONFIRMED;
import static com.pkb.entities.enums.UserStatus.INVITED;
import static com.pkb.user.entity.PKBPerson.Lazy.CONTACTS;
import static java.lang.String.format;
import static java.util.stream.Collectors.toList;

public class InvitationManager extends TransactionManager {

<span class="fc" id="L83">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    private final PKBEmailMessageManager messagingManager;
    private final TeamUserManager teamUserManager;
    private final UserManager userManager;
    private final PersonContactManager personContactManager;
    private final ConvertUtil convertUtil;
    private final PatientConsentManager consentManager;
    private final LetterInvitationService letterInvitationService;
    private final TeamManager teamManager;
    private final InvitationService invitationService;
    private final PKBInvitationMapper pkbInvitationMapper;
    private final InvitationOperationManager invitationOperationManager;
    private final InvitationManagerHelper invitationManagerHelper;
    private final TeamDomainService teamDomainService;
    private final DocumentManager documentManager;
    private final InstituteUserManager instituteUserManager;

    public InvitationManager(PhrConfig config, TolvenBeanFactory beanFactory, DateTimeService dateTimeService, UUIDProvider uuidProvider, PKBEmailMessageManager messagingManager,
                             TeamUserManager teamUserManager, UserManager userManager, PersonContactManager personContactManager, ConvertUtil convertUtil,
                             LetterInvitationService letterInvitationService, InvitationService invitationService, TeamManager teamManager,
                             PKBInvitationMapper pkbInvitationMapper, InvitationOperationManager invitationOperationManager, InvitationManagerHelper invitationManagerHelper,
                             TeamDomainService teamDomainService, DocumentManager documentManager, InstituteUserManager instituteUserManager, PatientConsentManager consentManager) {
<span class="fc" id="L106">        super(config, beanFactory, dateTimeService, uuidProvider);</span>
<span class="fc" id="L107">        this.messagingManager = messagingManager;</span>
<span class="fc" id="L108">        this.teamUserManager = teamUserManager;</span>
<span class="fc" id="L109">        this.userManager = userManager;</span>
<span class="fc" id="L110">        this.personContactManager = personContactManager;</span>
<span class="fc" id="L111">        this.convertUtil = convertUtil;</span>
<span class="fc" id="L112">        this.letterInvitationService = letterInvitationService;</span>
<span class="fc" id="L113">        this.teamManager = teamManager;</span>
<span class="fc" id="L114">        this.invitationService = invitationService;</span>
<span class="fc" id="L115">        this.pkbInvitationMapper = pkbInvitationMapper;</span>
<span class="fc" id="L116">        this.invitationOperationManager = invitationOperationManager;</span>
<span class="fc" id="L117">        this.invitationManagerHelper = invitationManagerHelper;</span>
<span class="fc" id="L118">        this.teamDomainService = teamDomainService;</span>
<span class="fc" id="L119">        this.documentManager = documentManager;</span>
<span class="fc" id="L120">        this.instituteUserManager = instituteUserManager;</span>
<span class="fc" id="L121">        this.consentManager = consentManager;</span>
<span class="fc" id="L122">    }</span>

    // First of new-fangled (May 2015) invitation manager calls
    // which *only* deal with invitations, and return acceptance strings to UserWebBean


    public PKBInvitation inviteClinicianForPatient(@NotNull LoggedInEHRRequestContext requestContext, Long patientAccountId,
                                                   PKBPerson author,
                                                   @NotNull PKBPerson clinician, boolean accountKeyRequired, String message, EnumSet&lt;PrivacyFlag&gt; consentSettings) {

        try {
<span class="fc" id="L133">            PKBInvitation invitation = new PKBInvitation();</span>
<span class="fc" id="L134">            invitation.setAccountKeyRequired(accountKeyRequired);</span>
<span class="fc" id="L135">            invitation.setAccountId(patientAccountId);</span>
<span class="fc" id="L136">            invitation.setAuthorUserId(author.getId());</span>
<span class="fc" id="L137">            invitation.setTargetUser(clinician);</span>
<span class="fc" id="L138">            invitation.setCreated(dateTimeService.now());</span>
<span class="fc" id="L139">            invitation.setInvitationType(InvitationType.CLINICIAN_INVITATION);</span>
<span class="fc" id="L140">            invitation.setGrantedConsents(consentSettings);</span>

<span class="fc" id="L142">            PKBInvitationDetail invitationDetail = new PKBInvitationDetail(new SourceDetails(requestContext));</span>

<span class="fc" id="L144">            invitationDetail.setContent(message);</span>
<span class="fc" id="L145">            invitation.setInvitationDetail(invitationDetail);</span>

<span class="fc" id="L147">            invitation = invitationOperationManager.createInvitation(requestContext, invitation);</span>

<span class="fc" id="L149">            sendClinicianInviteMessageForPatient(requestContext, invitation);</span>
<span class="fc" id="L150">            return invitation;</span>

<span class="nc" id="L152">        } catch (Exception e) {</span>
<span class="nc" id="L153">            throw new RuntimeException(&quot;Error inviting clinician-&quot; + clinician.getId() + &quot; for patientAccount-&quot; + patientAccountId, e);</span>
        }

    }

    private void sendClinicianInviteMessageForPatient(EHRRequestContext requestContext, PKBInvitation invitation) {

<span class="fc" id="L160">        PKBPerson patient = userManager.getAccountOwner(invitation.getAccountId(), PKBPerson.Lazy.CONTACTS);</span>
<span class="fc" id="L161">        PKBPerson author = userManager.getPKBPerson(invitation.getAuthorUserId(), PKBPerson.Lazy.CONTACTS);</span>
<span class="fc" id="L162">        PKBPerson clinician = invitation.getTargetUser();</span>
<span class="fc" id="L163">        String encodedSecretKey = invitation.getAccountKeyAccessToken();</span>
<span class="pc" id="L164">        TeamWithOrg teamWithOrg = findPatientIdentityVerification(patient, author).getOrElseThrow(e -&gt; e);</span>

<span class="fc bfc" id="L166" title="All 4 branches covered.">        if (author.isTeamCoordinator() || author.isPro()) {</span>
<span class="fc" id="L167">            Team authorTeam = teamUserManager.getPrimaryTeam(requestContext, author.getId(), false/*activeOnly*/);</span>
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">            if ((clinician.getId() != null) &amp;&amp; teamUserManager.isActiveTeamUser(clinician.getId())) {</span>
<span class="fc" id="L169">                messagingManager.proInvitesClinicianForPatient(patient, author, authorTeam, clinician, teamWithOrg,</span>
                        invitation, encodedSecretKey);
            } else {
<span class="fc" id="L172">                messagingManager.proInvitesNonTeamClinicianForPatient(patient, author, authorTeam, clinician, teamWithOrg,</span>
                        invitation, encodedSecretKey);
            }
<span class="fc bfc" id="L175" title="All 2 branches covered.">        } else if (author.getId().equals(patient.getId())) {</span>
<span class="fc" id="L176">            messagingManager.patientInvitesClinician(patient, clinician, teamWithOrg, invitation, encodedSecretKey);</span>
        } else {// Author must be a carer
<span class="fc" id="L178">            messagingManager.carerInvitesClinicianForPatient(patient, author, clinician, teamWithOrg, invitation,</span>
                    encodedSecretKey);
        }
<span class="fc" id="L181">    }</span>

    private Either&lt;RuntimeException, TeamWithOrg&gt; findPatientIdentityVerification(@NotNull PKBPerson patient, @NotNull PKBPerson author) {
<span class="fc" id="L184">        var teamWithOrg = teamDomainService.findVerifyingTeamForPersonId(patient.getId());</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        var isCarer = !personContactManager.findContactsThatHaveTheRefPerson(author.getId()).isEmpty();</span>
<span class="pc bpc" id="L186" title="3 of 8 branches missed.">        if (teamWithOrg.isPresent() || (!isCarer &amp;&amp; author.getId().equals(patient.getId()) &amp;&amp; author.isPatient())) {</span>
            // It is valid that there is no verifying team for a self-registered patient who is not a carer
<span class="fc" id="L188">            return Either.right(teamWithOrg.orElse(null));</span>
        }
<span class="nc" id="L190">        return Either.left(new RuntimeException(format(&quot;Unable to find identity verification for patient (id=%d)&quot;, patient.getId())));</span>
    }

    public PKBInvitation inviteCarerForPatient(@NotNull LoggedInEHRRequestContext requestContext, Long patientAccountId, PKBPerson author,
                                               PKBPerson carer, String message, EnumSet&lt;PrivacyFlag&gt; grantedConsents, UUID tempPasswordDocId) {
        try {
<span class="fc" id="L196">            return transactional(() -&gt; {</span>
<span class="fc" id="L197">                PKBInvitation invitation = new PKBInvitation();</span>
<span class="fc" id="L198">                invitation.setInvitationType(InvitationType.PATIENT_INVITATION);</span>
<span class="fc" id="L199">                invitation.setAccountId(patientAccountId);</span>
<span class="fc" id="L200">                invitation.setCreated(dateTimeService.now());</span>
<span class="fc" id="L201">                invitation.setAuthorUserId(author.getId());</span>
<span class="fc" id="L202">                invitation.setTargetUser(carer);</span>
<span class="fc" id="L203">                invitation.setGrantedConsents(grantedConsents);</span>
<span class="fc" id="L204">                invitation.setInvitationStatus(NEW);</span>

<span class="fc" id="L206">                PKBInvitationDetail invitationDetail = new PKBInvitationDetail(new SourceDetails(requestContext));</span>
<span class="fc" id="L207">                invitationDetail.setContent(message);</span>
<span class="fc" id="L208">                invitationDetail.setAddUserId(carer.getIdString());</span>
<span class="fc" id="L209">                invitationDetail.setPwdAccessDocumentMetadataId(tempPasswordDocId);</span>
<span class="fc" id="L210">                invitationDetail.getBaseFields().setPrivacyFlag(PrivacyFlag.GENERAL);</span>
<span class="fc" id="L211">                invitation.setInvitationDetail(invitationDetail);</span>

<span class="fc" id="L213">                PKBInvitation createdInvite = invitationOperationManager.createInvitation(requestContext, invitation);</span>
<span class="fc" id="L214">                invitation.setId(createdInvite.getId());</span>
<span class="fc" id="L215">                invitation.setPublicId(createdInvite.getPublicId());</span>

<span class="fc" id="L217">                sendCarerInviteMessage(requestContext, invitation);</span>

<span class="fc" id="L219">                return createdInvite;</span>
            });
<span class="nc" id="L221">        } catch (Exception e) {</span>
<span class="nc" id="L222">            throw new RuntimeException(</span>
<span class="nc" id="L223">                    &quot;Error in author-&quot; + author.getId() + &quot; inviting carer-&quot; + carer.getId() + &quot; for patientAccount-&quot; + patientAccountId,</span>
                    e);
        }
    }

    private void sendCarerInviteMessage(@NotNull LoggedInEHRRequestContext requestContext, PKBInvitation invitation) {
<span class="fc" id="L229">        String message = invitation.getInvitationDetail().getContent();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        boolean carerIsNewlyCreated = invitation.getInvitationDetail().getPwdAccessDocumentMetadataId() != null;</span>
<span class="fc" id="L231">        PKBPerson author = userManager.getPKBPerson(invitation.getAuthorUserId());</span>
<span class="fc" id="L232">        PKBPerson carer = invitation.getTargetUser();</span>
<span class="fc" id="L233">        PKBPerson patient = userManager.getAccountOwner(invitation.getAccountId(), PKBPerson.Lazy.CONTACTS);</span>
<span class="fc bfc" id="L234" title="All 4 branches covered.">        if (carer.getPassword() == null &amp;&amp; carerIsNewlyCreated) {</span>
<span class="fc" id="L235">            UUID docId = invitation.getInvitationDetail().getPwdAccessDocumentMetadataId();</span>
<span class="fc" id="L236">            String tempPassword = documentManager.getDocument(docId, requestContext.fillMissingContextUser(patient.getId()));</span>
            // this is used in building the email link
<span class="fc" id="L238">            carer.setPassword(tempPassword);</span>
        }

<span class="pc bpc" id="L241" title="1 of 6 branches missed.">        if (carerIsNewlyCreated || ((carer.getStatus() == INVITED) &amp;&amp; (carer.getPassword() != null))) {</span>
            // Invite/remind as non-team carer
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (patient.getId().equals(author.getId())) {</span>
<span class="fc" id="L244">                messagingManager.patientInvitesNonTeamCarerForSelf(patient, carer, message);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">            } else if (author.isPatient()) {</span>
<span class="nc" id="L246">                messagingManager.carerInvitesNonTeamCarerForPatient(patient, author, carer, message);</span>
            } else {
<span class="fc" id="L248">                Team team = teamManager.getTeam(requestContext.getTeamId().orElse(null));</span>
<span class="fc" id="L249">                messagingManager.proInvitesNonTeamCarerForPatient(patient, author, carer, message, team);</span>
<span class="fc" id="L250">            }</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        } else if (carer.getStatus() == EMAIL_CONFIRMED) {</span>
            // Carer can login - send an invitation that she can accept immediately
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (patient.getId().equals(author.getId())) {</span>
<span class="fc" id="L254">                messagingManager.patientInvitesTeamCarerForSelf(patient, carer, invitation);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">            } else if (author.isPatient()) {</span>
<span class="nc" id="L256">                messagingManager.carerInvitesTeamCarerForPatient(patient, author, carer, invitation);</span>
            } else {
<span class="fc" id="L258">                Team team = teamManager.getTeam(requestContext.getTeamId().orElse(null));</span>
<span class="fc" id="L259">                messagingManager.proInvitesTeamCarerForPatient(patient, author, carer, invitation, team);</span>
<span class="fc" id="L260">            }</span>
        } else {
            // but patient needs to complete existing registration before accepting
<span class="fc" id="L263">            List&lt;Team&gt; carerRegisteringTeams = teamUserManager.getUserTeams(requestContext, carer.getId(), false/*activeOnly*/);</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            Team carerRegisteringTeam = carerRegisteringTeams.isEmpty() ? null : carerRegisteringTeams.get(0);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (patient.getId().equals(author.getId())) {</span>
<span class="nc" id="L266">                messagingManager.patientInvitesRegisteringCarerForSelf(patient, carer, message);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            } else if (author.isPatient()) {</span>
<span class="nc" id="L268">                messagingManager.carerInvitesRegisteringCarerForPatient(patient, author, carer, message, carerRegisteringTeam);</span>
            } else {
<span class="fc" id="L270">                messagingManager.proInvitesRegisteringCarerForPatient(patient, author, carer, message, carerRegisteringTeam);</span>
            }
        }
<span class="fc" id="L273">    }</span>

    public PKBInvitation resendInvitation(@NotNull LoggedInEHRRequestContext requestContext, UUID invitationId) {
<span class="fc" id="L276">        return transactional(() -&gt; {</span>
<span class="fc" id="L277">            PKBInvitation invitation = getInvitation(requestContext, invitationId);</span>
<span class="fc" id="L278">            PKBPerson inviter = this.userManager.getPKBPerson(invitation.getAuthorUserId());</span>

<span class="pc bpc" id="L280" title="1 of 3 branches missed.">            switch (invitation.getTargetUser().getUserType()) {</span>
                case PATIENT:
<span class="fc" id="L282">                    resendInvitationToPatient(requestContext, invitation, inviter);</span>
<span class="fc" id="L283">                    break;</span>
                case REG_CLINICIAN:
<span class="fc bfc" id="L285" title="All 2 branches covered.">                    if (INVITED.compareTo(invitation.getTargetUser().getStatus()) == 0) {</span>
<span class="fc" id="L286">                        invitation = invitationOperationManager.createInvitation(requestContext, invitation);</span>
                    }
<span class="fc" id="L288">                    resendInvitationToProfessional(invitation, inviter);</span>
<span class="fc" id="L289">                    break;</span>
                default:
<span class="nc" id="L291">                    throw new RuntimeException(&quot;Asked to resend invitation to user that wasn't a Patient or Clinician&quot;);</span>
            }
<span class="fc" id="L293">            return invitation;</span>
        });
    }

    private void resendInvitationToPatient(@NotNull LoggedInEHRRequestContext requestContext, PKBInvitation invitation, PKBPerson inviter) {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (invitation.getAccountId() == null) {</span>
            //Asked for access as a carer
<span class="nc" id="L300">            messagingManager.sendInvitePatientMessage(requestContext, inviter, invitation, invitation.getTargetUser(), false);</span>
        } else {
            //Invited a carer
<span class="fc" id="L303">            sendCarerInviteMessage(requestContext, invitation);</span>
        }

        //Theoretically there's another option here: we also create invitations when a co-ordinator invites a patient from another org. But:
        // (1) I don't know how to identify these after the fact
        // (2) There does not seem to be anywhere in the UI that displays these invitations, let alone allows you to resend them. For the time being I'm going to ignore them.
<span class="fc" id="L309">    }</span>

    private void resendInvitationToProfessional(PKBInvitation invitation, PKBPerson inviter) {
        try {
<span class="fc" id="L313">            Optional&lt;TeamWithOrg&gt; targetUserVerifyingTeam = teamManager.findVerifyingTeamForPersonId(invitation.getTargetUser().getId());</span>

<span class="fc" id="L315">            TeamWithOrg inviterVerifyingTeam = teamManager.findVerifyingTeamForPersonId(inviter.getId())</span>
<span class="pc" id="L316">                    .orElseThrow(() -&gt; new RuntimeException(format(&quot;Unable to find verifying team for inviter (id=%d)&quot;, inviter.getId())));</span>

<span class="pc bpc" id="L318" title="2 of 3 branches missed.">            switch (invitation.getInvitationType()) {</span>
                case CLINICIAN_INVITATION_TO_UPGRADE_ACCOUNT:
<span class="nc" id="L320">                    messagingManager.inviteClinicianToUpgradeWithTeamWithOrg(inviterVerifyingTeam, inviter, invitation.getTargetUser(), invitation.getPublicId());</span>
<span class="nc" id="L321">                    break;</span>
                case CLINICIAN_INVITATION:
<span class="fc" id="L323">                    PKBPerson patient = userManager.getAccountOwner(invitation.getAccountId(), PKBPerson.Lazy.CONTACTS);</span>
<span class="fc" id="L324">                    targetUserVerifyingTeam.ifPresentOrElse(verifyingTeam -&gt; messagingManager.sendInviteClinicianMessage(patient, invitation, verifyingTeam),</span>
<span class="fc" id="L325">                            () -&gt; messagingManager.sendInviteClinicianMessage(patient, invitation, inviterVerifyingTeam));</span>
<span class="fc" id="L326">                    break;</span>
                default:
<span class="nc" id="L328">                    LOGGER.error(&quot;Unknown invitation subject for Professional {}&quot;, invitation.getInvitationType().description);</span>
                    break;
            }
<span class="nc" id="L331">        } catch (MailException e) {</span>
<span class="nc" id="L332">            throw new RuntimeException(e);</span>
<span class="fc" id="L333">        }</span>
<span class="fc" id="L334">    }</span>

    public void resendInvitationToEmployee(@NotNull LoggedInEHRRequestContext ctx, UUID invitationId) {
        try {
<span class="nc" id="L338">            PKBInvitation invitation = getInvitation(ctx, invitationId);</span>
<span class="nc" id="L339">            PKBPerson inviter = this.userManager.getPKBPerson(invitation.getAuthorUserId());</span>
            // Resend invitation to employee
<span class="nc" id="L341">            UUID docId = invitation.getInvitationDetail().getPwdAccessDocumentMetadataId();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (docId != null) {</span>
                // the temporary password is saved in a document
<span class="nc" id="L344">                String tempPassword = documentManager.getDocument(docId, ctx);</span>
                // this is used in building the email link
<span class="nc" id="L346">                invitation.getTargetUser().setPassword(tempPassword);</span>
            }
<span class="nc" id="L348">            messagingManager.inviteEmployee(invitation.getTargetUser(), inviter, invitation);</span>
<span class="nc" id="L349">        } catch (Exception e) {</span>
<span class="nc" id="L350">            throw new PKBException(e);</span>
<span class="nc" id="L351">        }</span>
<span class="nc" id="L352">    }</span>

    public List&lt;PKBInvitation&gt; getInvitations(long userId) {
        try {
<span class="fc" id="L356">            List&lt;DocInvitation&gt; invitations = invitationService.getInvitationsByAuthorOrTargetUserId(userId);</span>
<span class="fc" id="L357">            Set&lt;Long&gt; targetPersonIds = invitations.stream().map(DocInvitation::getTargetPersonId).collect(Collectors.toSet());</span>
            // Add the author user as well
<span class="fc" id="L359">            targetPersonIds.add(userId);</span>
<span class="fc" id="L360">            Map&lt;Long, PKBPerson&gt; targetUserMap = new HashMap&lt;&gt;(beanFactory.getPKBPersonBean().findPKBPersonMap(targetPersonIds, PKBPerson.Lazy.CONTACTS));</span>
<span class="fc" id="L361">            return invitations.stream()</span>
<span class="fc" id="L362">                    .map(i -&gt; pkbInvitationMapper.map(i, targetUserMap))</span>
<span class="fc" id="L363">                    .collect(toList());</span>
<span class="nc" id="L364">        } catch (Exception e) {</span>
<span class="nc" id="L365">            throw new RuntimeException(&quot;Exception while getting invitations for user-&quot; + userId, e);</span>
        }
    }

    public boolean acceptInvitation(EHRRequestContext requestContext, UUID invitationId, PKBPerson acceptorOnBehalfOfTarget, String invitationKey) {
       try {
<span class="fc" id="L371">            DocInvitation invitation = invitationService.getInvitation(invitationId);</span>
<span class="fc" id="L372">            InvitationType invitationType = pkbInvitationMapper.map(invitation).getInvitationType();</span>

<span class="pc bpc" id="L374" title="1 of 4 branches missed.">            if(invitationKey != null &amp;&amp; !validateInvitationKey(invitation, invitationKey)) {</span>
<span class="nc" id="L375">                return false;</span>
            }

<span class="fc" id="L378">            PKBPerson author = userManager.getPKBPerson(invitation.getAuthorPersonId(), PKBPerson.Lazy.CONTACTS);</span>
            // assume: target is current user
<span class="fc" id="L380">            PKBPerson target =  userManager.getPKBPerson(invitation.getTargetPersonId(), CONTACTS);</span>
<span class="fc" id="L381">            PKBPerson accountOwner = userManager.getAccountOwner(invitation.getAccountId(), PKBPerson.Lazy.CONTACTS);</span>

            // normal invitation: ensure active account_user link
<span class="fc" id="L384">            boolean targetIsPatient = target.isPatient();</span>

<span class="fc" id="L386">           Long patientUserId = userManager.getAccountOwner(invitation.getAccountId()).getId();</span>

<span class="fc bfc" id="L388" title="All 4 branches covered.">            boolean inviteeIsCarer = targetIsPatient &amp;&amp; !target.getId().equals(patientUserId);</span>



<span class="fc" id="L392">            long accessingPersonId = target.getId();</span>
            //Temporary handling for old invitations that didn't have consent flags included. In these cases
            //consent will already have been added anyway.
<span class="fc" id="L395">            invitation.getGrantedConsents().ifPresent(grantedConsents -&gt; {</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">                String reasonText = targetIsPatient ? &quot;invited carer&quot; : &quot;invited clinician&quot;;</span>

<span class="fc" id="L398">                SourceDTO source = ImmutableSourceDTO.builder().route(requestContext.getAccessRoute()).personId(author.getId()).build();</span>

                // Set consent
<span class="fc" id="L401">                PatientConsentUpdateDTO consentUpdateDTO = ImmutablePatientConsentUpdateDTO.builder()</span>
<span class="fc" id="L402">                        .generalHealthConsentGranted(grantedConsents.contains(PrivacyFlag.GENERAL))</span>
<span class="fc" id="L403">                        .sexualHealthConsentGranted(grantedConsents.contains(PrivacyFlag.SEXUAL_HEALTH))</span>
<span class="fc" id="L404">                        .mentalHealthConsentGranted(grantedConsents.contains(PrivacyFlag.MENTAL_HEALTH))</span>
<span class="fc" id="L405">                        .socialCareConsentGranted(grantedConsents.contains(PrivacyFlag.SOCIAL_CARE))</span>
<span class="fc" id="L406">                        .proEditOnlyForChild(false)</span>
<span class="fc" id="L407">                        .discharged(false)</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                        .accessingEntityType(targetIsPatient ? AccessingEntityType.CARER : AccessingEntityType.INDIVIDUAL)</span>
<span class="fc" id="L409">                        .patientPersonId(patientUserId)</span>
<span class="fc" id="L410">                        .source(source)</span>
<span class="fc" id="L411">                        .generalHealthConsentGrantedReason(EXPLICIT_CONSENT)</span>
<span class="fc" id="L412">                        .sexualHealthConsentGrantedReason(EXPLICIT_CONSENT)</span>
<span class="fc" id="L413">                        .mentalHealthConsentGrantedReason(EXPLICIT_CONSENT)</span>
<span class="fc" id="L414">                        .socialCareConsentGrantedReason(EXPLICIT_CONSENT)</span>
<span class="fc" id="L415">                        .generalHealthConsentGrantedReasonText(reasonText)</span>
<span class="fc" id="L416">                        .sexualHealthConsentGrantedReasonText(reasonText)</span>
<span class="fc" id="L417">                        .mentalHealthConsentGrantedReasonText(reasonText)</span>
<span class="fc" id="L418">                        .socialCareConsentGrantedReasonText(reasonText)</span>
<span class="fc" id="L419">                        .accessingPersonId(accessingPersonId)</span>
<span class="fc" id="L420">                        .build();</span>
<span class="fc" id="L421">                consentManager.ensureTeamLinkAndUpdatePatientConsent(requestContext, consentUpdateDTO);</span>
<span class="fc" id="L422">            });</span>


<span class="fc" id="L425">            updateInvitationStatus(invitation.getPublicId(), ACCEPTED);</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">            if (inviteeIsCarer) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (author.equals(accountOwner)) {</span>
<span class="fc" id="L429">                    messagingManager.carerAcceptsInvitationFromPatient(accountOwner, target);</span>
                } else {
                    //This notifies the professional
<span class="fc" id="L432">                    messagingManager.carerAcceptsInvitationFromPro(accountOwner, author, target);</span>
                    //This notifies the patient
<span class="fc" id="L434">                    messagingManager.carerAcceptsInvitationFromOtherUserNotifyPatient(accountOwner, author, target);</span>
                }
<span class="fc bfc" id="L436" title="All 2 branches covered.">            } else if (target.isPro()) { //Individual professional invited....</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">                if (author.equals(accountOwner)) { //... by the patient themselves</span>
<span class="fc" id="L438">                    messagingManager.sendNotificationClinicianAcceptedInvitation(target, accountOwner);</span>
                }
<span class="fc bfc" id="L440" title="All 2 branches covered.">                else if(invitationType != InvitationType.CLINICIAN_INVITATION_TO_UPGRADE_ACCOUNT) { //... by someone else (but don't confuse with invitation to upgrade for indiv pro)</span>
<span class="fc" id="L441">                    messagingManager.sendNotificationClinicianAcceptedInvitation(target, author, accountOwner);</span>
                }
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">            }  else if (author.isPatient() || author.isPro()) {</span>
<span class="pc bpc" id="L444" title="2 of 4 branches missed.">                if ((acceptorOnBehalfOfTarget != null) &amp;&amp; !acceptorOnBehalfOfTarget.getId().equals(target.getId())) { //someone else accepted a request for access on behalf of the patient</span>
<span class="nc" id="L445">                    messagingManager.sendNotificationOfferedCareAcceptedOnBehalfOfPatient(target, author, acceptorOnBehalfOfTarget);</span>
                }
                else  {  //Invite to a patient who is not a carer, acceptor is the same as target -&gt; must be patient accepting offer of care
<span class="fc" id="L448">                    messagingManager.sendNotificationPatientAcceptedOfferedCare(target, author);</span>
                }
            }

<span class="fc" id="L452">            return true;</span>
<span class="nc" id="L453">        } catch (Exception e) {</span>
<span class="nc" id="L454">            throw new RuntimeException(&quot;Exception while accepting invitation-&quot; + invitationId, e);</span>
        }
    }

    public void updateInvitationStatus(UUID invitationId, InvitationStatus status) {
<span class="fc" id="L459">        invitationService.updateInvitationStatus(invitationId, status);</span>
<span class="fc" id="L460">    }</span>

    public boolean invitedAlready(Option&lt;Email&gt; targetEmail, Long accountId) {
<span class="fc bfc" id="L463" title="All 2 branches covered.">        return !invitationService.getOpenInvitationsForTargetEmail(targetEmail, accountId).isEmpty();</span>
    }

    @NotNull
    public Optional&lt;UUID&gt; getOpenInvitationId(Email clinicianEmailId, long userId) {
<span class="fc" id="L468">        return invitationService.getActiveInvitationsForAuthorIdsAndTargetEmail(List.of(userId), clinicianEmailId)</span>
<span class="fc" id="L469">                .stream()</span>
<span class="fc" id="L470">                .findFirst()</span>
<span class="fc" id="L471">                .map(DocInvitation::getPublicId);</span>
    }

    /**
     * Finds active invitations sent to the target email by any of the given authors
     *
     * @param authorLdapIds  The collection of authors to search
     * @param requestContext
     * @param targetEmail    The email address of the invitee
     * @param authors
     * @return A list of all {@link PKBInvitation}s from any of the authors to the invitee
     */
    List&lt;PKBInvitation&gt; findActiveInvitationsForTargetEmailFromAuthors(@NotNull EHRRequestContext requestContext,
                                                                       @NotNull Email targetEmail,
                                                                       @NotNull Collection&lt;PKBPerson&gt; authors) {

<span class="fc" id="L487">        List&lt;Long&gt; authorLdapIds = authors.stream()</span>
<span class="fc" id="L488">                .map(PKBPerson::getId)</span>
<span class="fc" id="L489">                .collect(toList());</span>

<span class="fc" id="L491">        List&lt;DocInvitation&gt; invitations = invitationService.getActiveInvitationsForAuthorIdsAndTargetEmail(authorLdapIds, targetEmail);</span>
<span class="fc" id="L492">        Map&lt;Long, PKBPerson&gt; targetPersonMap = getInvitationTargetPersonMap(invitations);</span>
<span class="fc" id="L493">        return invitations.stream()</span>
<span class="pc" id="L494">                .map(invitation -&gt; pkbInvitationMapper.map(invitation, targetPersonMap))</span>
<span class="fc" id="L495">                .collect(toList());</span>
    }

    private Map&lt;Long, PKBPerson&gt; getInvitationTargetPersonMap(List&lt;DocInvitation&gt; resultList) {
<span class="fc" id="L499">        return beanFactory.getPKBPersonBean().findPKBPersonMap(resultList.stream().map(DocInvitation::getTargetPersonId).collect(toList()));</span>
    }

    public PKBInvitation getInvitation(@NotNull EHRRequestContext requestContext, UUID invitationPublicId) {
        try {
<span class="fc" id="L504">            return populatePKBInvitation(requestContext, invitationService.getInvitation(invitationPublicId));</span>
<span class="nc" id="L505">        } catch (Exception e) {</span>
<span class="nc" id="L506">            throw new RuntimeException(&quot;Exception while getting invitations object for id-&quot;</span>
                    + invitationPublicId, e);
        }
    }

    /**
     *
     * @deprecated To be removed when there are no more old-style open invitations using privateId
     */
    @Deprecated
    public UUID getInvitationIdByString(String invitationId) {
        try {
<span class="fc" id="L518">            return invitationService.getInvitationIdByString(invitationId);</span>
<span class="nc" id="L519">        } catch (Exception e) {</span>
<span class="nc" id="L520">            throw new RuntimeException(&quot;Exception while getting invitations object for invitationId-&quot;</span>
                    + invitationId, e);
        }
    }

    public UUID invitePatient(@NotNull LoggedInEHRRequestContext requestContext, PKBPerson patient, PKBInvitation invitation,
                              long inviterUserId, boolean inviteAsCaregiver) {
        try {
<span class="fc" id="L528">            Long inviterAccountId = userManager.getDefaultAccountId(inviterUserId);</span>
<span class="fc" id="L529">            PKBPerson patientUser = personContactManager.getPersonForConfirmedOrPrimaryPatientContact(patient.getEmail()).getOrNull();</span>
<span class="fc" id="L530">            boolean isUserExist = userManager.pkbPersonUsernameExists(patient.getUserName());</span>

            // If the patient does not exists in the system
            // register the user with the information available
<span class="pc bpc" id="L534" title="1 of 4 branches missed.">            if (!isUserExist &amp;&amp; (patientUser == null)) {</span>
<span class="fc" id="L535">                patient.setUserType(UserType.PATIENT);</span>
<span class="fc" id="L536">                patient.setStatus(INVITED, dateTimeService.now());</span>
<span class="fc" id="L537">                PKBPersonDTO newPatient = convertUtil.getPKBPersonFromPlugin(patient);</span>
<span class="fc" id="L538">                String password = RandomUtil.randomPassword(10);</span>
<span class="fc" id="L539">                newPatient.setPassword(password);</span>

<span class="pc" id="L541">                Team invitingTeam = getActiveInvitingTeam(requestContext, inviterUserId).orElseThrow(() -&gt; new RuntimeException(&quot;Unable to get the inviting team&quot;));</span>
<span class="fc" id="L542">                newPatient.setLanguageCode(invitingTeam.getLocale().getLanguage());</span>

                //let's try to create the user -
<span class="fc" id="L545">                userManager.registerNewUser(requestContext, newPatient, dateTimeService.now());</span>
                //we re-assign the earlier variable

<span class="fc" id="L548">                patientUser = userManager.getPKBPerson(newPatient.getId(), CONTACTS);</span>

<span class="fc" id="L550">                patientUser.setPassword(password);</span>

                // save the temporary password in a document (for the patient to retrieve for resending the invitation)
<span class="fc" id="L553">                UUID passwordDocId = documentManager.saveDocument(requestContext, inviterUserId, inviterAccountId, password);</span>
<span class="fc" id="L554">                invitation.getInvitationDetail().setPwdAccessDocumentMetadataId(passwordDocId);</span>
            }

            //if patient is still null at this point then we have a problem
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            if (patientUser == null) {</span>
                //noinspection ThrowCaughtLocally
<span class="nc" id="L560">                throw new IllegalStateException(&quot;unable to invite/find the patient using the specified contact information&quot;);</span>
            } else {

<span class="fc bfc" id="L563" title="All 2 branches covered.">                if (inviteAsCaregiver) {</span>
<span class="fc" id="L564">                    invitation.getInvitationDetail().setAddUserId(patientUser.getId().toString());</span>
                } else {
                    // Store the user to be added into invitation
<span class="fc" id="L567">                    invitation.getInvitationDetail().setAddUserId(Long.toString(inviterUserId));</span>
                }
<span class="fc" id="L569">                invitation.setTargetUser(patientUser);</span>
<span class="fc" id="L570">                invitation.setInvitationStatus(NEW);</span>
<span class="fc" id="L571">                PKBInvitation createdInvite = invitationOperationManager.createInvitation(requestContext, invitation);</span>
<span class="fc" id="L572">                invitation.setId(createdInvite.getId());</span>
                //Send invitation to the patient
<span class="fc" id="L574">                PKBPerson inviterUser = userManager.getPKBPerson(inviterUserId);</span>
<span class="fc" id="L575">                messagingManager.sendInvitePatientMessage(requestContext, inviterUser, invitation, patientUser, inviteAsCaregiver);</span>

<span class="fc" id="L577">                return createdInvite.getPublicId();</span>
            }
<span class="nc" id="L579">        } catch (Exception exception) {</span>
<span class="nc" id="L580">            throw new RuntimeException(&quot;Error while inviting patient&quot;, exception);</span>
        }
    }

    public PKBInvitation getPKBInvitation(@NotNull LoggedInEHRRequestContext requestContext, long authorUserId, long targetUserId,
                                          @NotNull InvitationType invitationType) {
        try {
<span class="fc" id="L587">            return invitationService.getPKBInvitation(authorUserId, targetUserId, invitationType)</span>
<span class="fc" id="L588">                    .map(invitation -&gt; populatePKBInvitation(requestContext, invitation))</span>
<span class="pc" id="L589">                    .orElseThrow(() -&gt; new RuntimeException(&quot;Failed to find invitation for authorUserId &quot; + authorUserId</span>
                            + &quot;, targetUserId &quot; + targetUserId + &quot; and subject &quot; + invitationType.description));
<span class="nc" id="L591">        } catch (Exception exception) {</span>
<span class="nc" id="L592">            throw new RuntimeException(&quot;Error while getting invitation&quot;, exception);</span>
        }
    }

    public List&lt;PKBInvitation&gt; getInvitationsByUserAndAccountId(long authorUserId, Long accountId,
                                                                long targetUserId, InvitationStatus status) {
        try {
<span class="fc" id="L599">            return invitationService.getInvitationsByUserAndAccountId(authorUserId, accountId, targetUserId, status)</span>
<span class="fc" id="L600">                    .stream()</span>
<span class="pc" id="L601">                    .map(i -&gt; invitationManagerHelper.mapToPKBInvitation(i, null))</span>
<span class="fc" id="L602">                    .collect(toList());</span>
<span class="nc" id="L603">        } catch (Exception exception) {</span>
<span class="nc" id="L604">            throw new RuntimeException(&quot;Error while getting invitations with author, target &amp; status&quot;, exception);</span>
        }
    }

    public List&lt;PKBInvitation&gt; getInvitationsByTargetUserIds(Set&lt;Long&gt; targetUserIds, InvitationStatus invitationStatus) {
        try {
<span class="fc" id="L610">            Map&lt;Long, PKBPerson&gt; pkbPersonMap = beanFactory.getPKBPersonBean().findPKBPersonMap(targetUserIds);</span>
<span class="fc" id="L611">            return invitationService.getInvitationsByTargetUserIds(targetUserIds, invitationStatus)</span>
<span class="fc" id="L612">                    .map(i -&gt; invitationManagerHelper.mapToPKBInvitation(i, pkbPersonMap.get(i.getTargetPersonId())))</span>
<span class="fc" id="L613">                    .collect(toList());</span>
<span class="nc" id="L614">        } catch (Exception exception) {</span>
<span class="nc" id="L615">            throw new RuntimeException(&quot;Error while getting invitations by target users&quot;, exception);</span>
        }
    }

    public Long inviteEmployee(@NotNull LoggedInEHRRequestContext requestContext, PKBPersonDTO employeeDTO, PKBInvitation invitation,
                               long inviterUserId) {
<span class="fc" id="L621">        return transactional(() -&gt; {</span>
<span class="fc" id="L622">            PKBPerson employee = userManager.getSinglePersonByEmail(employeeDTO.getEmailId());</span>
<span class="fc" id="L623">            Long inviterAccountId = userManager.getDefaultAccountId(inviterUserId);</span>
<span class="fc" id="L624">            boolean isUserExist = userManager.pkbPersonUsernameExists(employeeDTO.getUserName());</span>

            // If the employee does not exists in the system
            // Send an invitation to the employee to register
<span class="pc bpc" id="L628" title="2 of 4 branches missed.">            if (!isUserExist &amp;&amp; (employee == null)) {</span>
<span class="fc" id="L629">                employeeDTO.setUserType(UserType.EMPLOYEE);</span>
<span class="fc" id="L630">                employeeDTO.setStatus(INVITED);</span>
<span class="fc" id="L631">                employeeDTO.setPassword(RandomUtil.randomPassword(10));</span>
<span class="fc" id="L632">                userManager.registerNewUser(requestContext, employeeDTO, dateTimeService.now());</span>
                // Should now be safely able to retrieve the single user with this email address
<span class="fc" id="L634">                employee = userManager.getPKBPerson(employeeDTO.getId(), CONTACTS);</span>
<span class="fc" id="L635">                employee.setPassword(employeeDTO.getPassword());</span>

                // save the temporary password in a document
<span class="fc" id="L638">                UUID passwordDocId = documentManager.saveDocument(requestContext, inviterUserId, inviterAccountId, employee.getPassword());</span>
<span class="fc" id="L639">                invitation.getInvitationDetail().setPwdAccessDocumentMetadataId(passwordDocId);</span>
            }

<span class="fc" id="L642">            invitation.setTargetUser(employee);</span>

<span class="fc" id="L644">            PKBInvitation createdInvite = invitationOperationManager.createInvitation(requestContext, invitation);</span>
<span class="fc" id="L645">            invitation.setId(createdInvite.getId());</span>
<span class="fc" id="L646">            PKBPerson inviterUser = userManager.getPKBPerson(inviterUserId);</span>
<span class="fc" id="L647">            messagingManager.inviteEmployee(employee, inviterUser, invitation);</span>
<span class="fc" id="L648">            return createdInvite.getId();</span>
        });
    }

    public String activatePatient(long patientId, UUID patientPublicId) {
<span class="fc" id="L653">        return letterInvitationService.activatePatient(patientId, patientPublicId);</span>
    }

    public void sendInvitation(Team team, Long personId) throws MailException {
<span class="fc" id="L657">        PKBPerson patient = userManager.getPKBPerson(personId, CONTACTS);</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        if (patient == null) {</span>
<span class="nc" id="L659">            throw new RuntimeException(&quot;Patient not found by id: &quot; + personId);</span>
        }

        // Generate new private user key
<span class="fc" id="L663">        String password = activatePatient(patient.getId(), patient.getPublicId());</span>
<span class="fc" id="L664">        patient.setPassword(password);</span>

<span class="fc" id="L666">        userManager.updateUserStatus(personId, INVITED);</span>
<span class="fc" id="L667">        InstituteUser instituteUser = teamUserManager.getInstituteUser(team.getId(), personId);</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        if (instituteUser == null) {</span>
<span class="fc" id="L669">            teamUserManager.createInstituteUser(personId, team.getId());</span>
<span class="fc" id="L670">            teamUserManager.updateStatus(team.getId(), personId, SponsorshipStatus.ACTIVE);</span>
        }

<span class="fc" id="L673">        messagingManager.notifyPatientOfCreatedAccount(null, patient, team, null);</span>
<span class="fc" id="L674">    }</span>

    private @NotNull Optional&lt;Team&gt; getActiveInvitingTeam(@NotNull EHRRequestContext requestContext, long inviterUserId) {
<span class="fc" id="L677">        return Optional.ofNullable(teamUserManager.getUserTeams(requestContext, inviterUserId, true).get(0));</span>
    }

    //WARNING: calling this on a list of results from a db query can cause performance issues - see PHR-5553.
    private PKBInvitation populatePKBInvitation(@NotNull EHRRequestContext requestContext, @NotNull DocInvitation invitation) {
<span class="fc" id="L682">        PKBInvitation pkbInvitation = pkbInvitationMapper.map(invitation);</span>

<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (invitation.getTargetPersonId() != null) {</span>
<span class="fc" id="L685">            pkbInvitation.setTargetUser(beanFactory.getPKBPersonBean().findPKBPerson(invitation.getTargetPersonId(), PKBPerson.Lazy.CONTACTS).getOrNull());</span>
        } else { // When the user has not yet registered
<span class="nc" id="L687">            var personsByEmail = personContactManager.findPKBPersonByConfirmedOrPrimaryEmail(invitation.getTargetEmail(), PersonContact.Lazy.PERSON_W_CONTACTS);</span>
<span class="nc" id="L688">            PersonAmbiguityHandler.getMaybePersonOrNone(personsByEmail, &quot;email&quot;).peek(pkbInvitation::setTargetUser);</span>
        }

<span class="fc" id="L691">        Account authorAccount = beanFactory.getPKBPersonBean().getDefaultAccount(pkbInvitation.getAuthorUserId());</span>

        //This method still gets called from pre-registration contexts in which the user is not yet fully configured. We
        // need to have some clearer rules on what must be populated in which circumstances and  possibly enforce this at compile
        //team in some form.
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (authorAccount != null) {</span>
<span class="fc" id="L697">            requestContext.getLoggedInContext().ifPresent(loggedInContext -&gt; {</span>
                // TODO should be updated to support AccountOrg flow, *not* just indiv links.  ALT: get rid of InvitationDetail
                //   what flows still use it (and can we get rid of those?)

<span class="fc" id="L701">                PKBInvitationDetail invitationDetail = null;</span>
                try {
<span class="fc" id="L703">                    invitationDetail = getOtherInvitationDetail(loggedInContext, invitation.getId(), authorAccount.getId());</span>
<span class="nc" id="L704">                } catch (Exception e) {</span>
                    // normally invalid key exception
                    // not stored with the key we expected -- who's key is used here, actually?  this needs more untangling
<span class="nc" id="L707">                    LOGGER.warn(&quot;failed getting InvitationDetail for id {}, acctId {}&quot;,</span>
<span class="nc" id="L708">                            invitation.getId(), authorAccount.getId(), e);</span>
<span class="fc" id="L709">                }</span>

<span class="fc bfc" id="L711" title="All 2 branches covered.">                if (invitationDetail != null) {</span>
<span class="fc" id="L712">                    invitationDetail.setInvitationPublicId(pkbInvitation.getPublicId());</span>
<span class="fc" id="L713">                    invitationDetail.setInvitationPrivateId(pkbInvitation.getId());</span>
<span class="fc" id="L714">                    pkbInvitation.setInvitationDetail(invitationDetail);</span>
                }
<span class="fc" id="L716">            });</span>
        }

<span class="fc" id="L719">        return pkbInvitation;</span>
    }

    private PKBInvitationDetail getOtherInvitationDetail(LoggedInEHRRequestContext requestContext, Long invitationId, long accountId) {

<span class="fc" id="L724">        EHRSearch&lt;PKBInvitationDetail&gt; search = new EHRSearch&lt;&gt;(accountId, PKBInvitationDetail.class,</span>
                MenuDataType.invitationDetail);
<span class="fc" id="L726">        search.addFilter(</span>
                new PKBFilter(PKBInvitationDetail.PH_FIELD_INVITATION_ID, PKBFilter.Operator.EQUAL, invitationId));
<span class="fc" id="L728">        List&lt;PKBInvitationDetail&gt; result = beanFactory.getEhrRemote().queryAndDecryptTypedData(search, requestContext);</span>
        // this is stupid but i'm just following the pre-migration code for now :(
<span class="fc bfc" id="L730" title="All 2 branches covered.">        return !result.isEmpty() ? result.get(0) : null;</span>
    }

    public List&lt;PKBInvitation&gt; getInvitationsForInstitute(long teamId, InvitationStatus status, UserType userType) {
        try {
<span class="fc" id="L735">            Set&lt;Long&gt; personIdsInTeam = new HashSet&lt;&gt;(instituteUserManager.getPersonIdsInTeam(teamId));</span>
<span class="fc" id="L736">            List&lt;Long&gt; targetPersonIds = beanFactory.getPKBPersonBean().findPKBPersonIdListByUserTypeAndContactType(personIdsInTeam,</span>
<span class="fc" id="L737">                    Collections.singletonList(userType), Collections.singletonList(ContactType.EMAIL));</span>

<span class="pc bpc" id="L739" title="1 of 2 branches missed.">            if (targetPersonIds.isEmpty()) {</span>
<span class="nc" id="L740">                return Collections.emptyList();</span>
            }

<span class="fc" id="L743">            List&lt;String&gt; targetPersonEmails = beanFactory.getPKBPersonBean().findPKBPersonEmailList(targetPersonIds);</span>
<span class="fc" id="L744">            List&lt;UUID&gt; targetedInvitationIds= invitationService.getInvitationIdsForTargetEmails(targetPersonEmails, status);</span>

<span class="fc bfc" id="L746" title="All 2 branches covered.">            if (targetedInvitationIds.isEmpty()) {</span>
<span class="fc" id="L747">                return Collections.emptyList();</span>
            }

<span class="fc" id="L750">            List&lt;UUID&gt; invitationIds = invitationService.getIdAndAuthorPersonIdTuplesForIds(targetedInvitationIds)</span>
<span class="fc" id="L751">                    .filter(inv -&gt; personIdsInTeam.contains(inv.get(1, Long.class)))</span>
<span class="fc" id="L752">                    .map(inv -&gt; inv.get(0, UUID.class))</span>
<span class="fc" id="L753">                    .collect(toList());</span>

<span class="fc bfc" id="L755" title="All 2 branches covered.">            if (invitationIds.isEmpty()) {</span>
<span class="fc" id="L756">                return Collections.emptyList();</span>
            }

<span class="fc" id="L759">            List&lt;DocInvitation&gt; invitations = invitationService.getInvitations(invitationIds);</span>

<span class="fc" id="L761">            Map&lt;Long, PKBPerson&gt; targetPersonMap = beanFactory.getPKBPersonBean().findPKBPersonMap(</span>
<span class="fc" id="L762">                    invitations.stream().map(DocInvitation::getTargetPersonId).collect(toList())</span>
            );

<span class="fc" id="L765">            return invitations.stream()</span>
<span class="fc" id="L766">                    .map(i -&gt; invitationManagerHelper.mapToPKBInvitation(i, targetPersonMap.get(i.getTargetPersonId())))</span>
<span class="fc" id="L767">                    .collect(toList());</span>
<span class="nc" id="L768">        } catch (Exception e) {</span>
<span class="nc" id="L769">            throw new RuntimeException(&quot;Exception while getting active invitations for team-&quot; + teamId, e);</span>
        }
    }

    public boolean validateInvitationKey(UUID invitationId,String invitationKey) {
<span class="fc" id="L774">        return validateInvitationKey(invitationService.getInvitation(invitationId), invitationKey);</span>
    }

    private boolean validateInvitationKey(DocInvitation docInvitation, String invitationKey) {
        try {
<span class="fc" id="L779">            EncodedEncryptedPrivateKeyInfoWithSecretDeriv eEPKIWSD = docInvitation.getAccountPrivateKey();</span>
<span class="fc" id="L780">            AccountPrivateKeyMapper.getPrivateKey(eEPKIWSD, invitationKey); // Will throw if salts don't match</span>
<span class="fc" id="L781">            return true;</span>
<span class="fc" id="L782">        } catch (Exception ignored) {</span>
<span class="fc" id="L783">            return false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>