<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserPrivateKeyAvailableHandler.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.kms.service.processor</a> &gt; <span class="el_source">UserPrivateKeyAvailableHandler.kt</span></div><h1>UserPrivateKeyAvailableHandler.kt</h1><pre class="source lang-java linenums">package com.pkb.kms.service.processor

import com.pkb.common.config.KmsConfig
import com.pkb.crypto.UserPrivateKey
import com.pkb.kms.service.AccessService
import com.pkb.kms.service.AccountPath
import com.pkb.kms.service.EncryptedAccountKey
import com.pkb.kms.service.EncryptedOrgAccountKey
import com.pkb.kms.service.cache.KmsCacheManager
import com.pkb.kms.service.cache.OrgAccessibleAccountPrivateKeyCacheService
import com.pkb.kms.service.cache.OrgAccountKeyCacheService
import com.pkb.kms.service.cache.UserAccessibleAccountPrivateKeyCacheService
import com.pkb.kms.service.cache.UserPrivateKeyCacheService
import com.pkb.kms.service.routing.KeyAvailableRouteBuilder.Companion.INBOUND_USER_KEY_AVAILABLE
import com.pkb.kms.service.routing.KeyAvailableRouteBuilder.Companion.OUTBOUND_USER_KEY_AVAILABLE_STARTUP
import com.pkb.kms.shared.representation.KmsError
import com.pkb.kms.shared.representation.PersonPublicId
import com.pkb.kms.shared.representation.PersonRequester
import com.pkb.kms.shared.structures.pubsub.KeyAvailable
import com.pkb.kms.shared.structures.pubsub.personPublicId
import com.pkb.kms.shared.structures.pubsub.userKeyAvailable
import io.micrometer.core.annotation.Timed
import io.micrometer.core.instrument.MeterRegistry
import io.vavr.control.Either
import org.apache.camel.Consume
import org.apache.camel.Produce
import org.apache.camel.ProducerTemplate
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.boot.context.event.ApplicationReadyEvent
import org.springframework.context.event.EventListener
import org.springframework.stereotype.Service
import java.lang.invoke.MethodHandles
import java.util.concurrent.Executors

/**
 * Decrypt all the accounts directly accessible from a user when their key becomes available.
 * 
 * Do this asynchronously, as there may be a large number of directly accessible keys, and
 * we don't want to slow down user login.
 */
<span class="fc" id="L42">@Service</span>
<span class="fc" id="L43">class UserPrivateKeyAvailableHandler(private val userPrivateKeyCacheService: UserPrivateKeyCacheService,</span>
<span class="fc" id="L44">                                     private val accessService: AccessService,</span>
<span class="fc" id="L45">                                     private val orgAccountKeyCacheService: OrgAccountKeyCacheService,</span>
<span class="fc" id="L46">                                     private val userAccessibleAccountPrivateKeyCacheService: UserAccessibleAccountPrivateKeyCacheService,</span>
<span class="fc" id="L47">                                     private val orgAccessibleAccountPrivateKeyCacheService: OrgAccessibleAccountPrivateKeyCacheService,</span>
<span class="fc" id="L48">                                     private val cacheManager: KmsCacheManager,</span>
<span class="fc" id="L49">                                     private val meterRegistry: MeterRegistry,</span>
<span class="fc" id="L50">                                     private val kmsConfig: KmsConfig,</span>
<span class="fc" id="L51">                                     @Produce(OUTBOUND_USER_KEY_AVAILABLE_STARTUP) private val startupKeyAvailableProducer: ProducerTemplate) {</span>
<span class="fc" id="L52">    private val log: Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())</span>
<span class="fc" id="L53">    private val t = Executors.newSingleThreadExecutor()</span>

    @EventListener(ApplicationReadyEvent::class)
<span class="fc" id="L56">    fun doEnsureAccessToAllAccounts() = t.execute { ensureAccessToAllAccounts() }</span>

    fun ensureAccessToAllAccounts() {
<span class="fc" id="L59">        cacheManager.iterateAllEntries(UserPrivateKeyCacheService.USER_PRIVATE_KEY_CACHE_NAME)</span>
        { k: PersonPublicId, _: Either&lt;KmsError, UserPrivateKey&gt; -&gt;
<span class="nc" id="L61">            startupKeyAvailableProducer.sendBody(userKeyAvailable(k))</span>
<span class="nc" id="L62">        }</span>
<span class="fc" id="L63">    }</span>
    
    @Timed(&quot;user_private_key_available_handler&quot;, histogram = true, percentiles = [0.5, 0.75, 0.9, 0.95, 0.99, 0.999])
    @Consume(INBOUND_USER_KEY_AVAILABLE)
    fun process(keyAvailable: KeyAvailable) {
<span class="fc" id="L68">        log.debug(&quot;got a user key available pubsub message {}&quot;, keyAvailable)        </span>
<span class="fc" id="L69">        val personPublicId = keyAvailable.personPublicId()</span>
<span class="fc" id="L70">        userPrivateKeyCacheService.getCachedUserPrivateKey(personPublicId)</span>
<span class="fc" id="L71">                .map { ensureAccountsAccess(personPublicId, it) }</span>
<span class="fc" id="L72">                .peekLeft { log.error(&quot;Pubsub message said user private key was available, but it wasn't. personPublicId: {}&quot;, personPublicId) }        </span>
<span class="fc" id="L73">    }</span>

    private fun ensureAccountsAccess(personPublicId: PersonPublicId, userPrivateKey: UserPrivateKey) {
<span class="fc" id="L76">        val (accessibleOrgAccounts, accessibleOtherAccounts) = accessService.getAccessibleAccountKeys(personPublicId)</span>
        // note the order here is important: decrypt &amp; cache org keys _first_. In case any other accounts we have 
        // direct access to are already available via the org, we won't need to cache those as well.
<span class="fc" id="L79">        val orgAccountResults = ensureOrgAccountKeyAccess(userPrivateKey, accessibleOrgAccounts)</span>
<span class="fc" id="L80">        recordSummary(orgAccountResults, &quot;org_accounts&quot;)</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (kmsConfig.unlockAccountKeysFromUserKeys) {</span>
<span class="fc" id="L82">            val otherAccountResults = ensureAccountKeyAccess(personPublicId, userPrivateKey, accessibleOtherAccounts)</span>
<span class="fc" id="L83">            recordSummary(otherAccountResults, &quot;other_accounts&quot;)</span>
        }
<span class="fc" id="L85">    }</span>

    private fun ensureOrgAccountKeyAccess(userPrivateKey: UserPrivateKey, orgKeys: List&lt;EncryptedOrgAccountKey&gt;): List&lt;Either&lt;KmsError, Boolean&gt;&gt; {
<span class="fc" id="L88">        val orgIds = orgKeys.map { it.orgId }</span>
<span class="fc" id="L89">        val orgIdsWithKeysCached = orgAccountKeyCacheService.getCachedOrgAccountKeys(orgIds)</span>
<span class="fc" id="L90">                .map { it.orgId }</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">        val orgKeysNotCached = orgKeys.filter { it.orgId !in orgIdsWithKeysCached }</span>
        // Typically users will have access to just one org account key, so no batching required here.
<span class="fc" id="L93">        val notCachedResults = orgKeysNotCached.map { orgKey -&gt;</span>
<span class="fc" id="L94">            try {</span>
<span class="fc" id="L95">                orgAccountKeyCacheService.decryptOrgAccountKey(userPrivateKey, orgKey)</span>
<span class="fc" id="L96">                        .map { false }</span>
<span class="fc" id="L97">            } catch (e: Throwable) {</span>
<span class="fc" id="L98">                Either.left(KmsError(&quot;unexpected.exception&quot;,</span>
<span class="fc" id="L99">                        &quot;Unexpected exception $e decrypting org account keys ${orgKey.orgId}&quot;,</span>
<span class="fc" id="L100">                        KmsError.Type.UNEXPECTED))</span>
            }
        }
<span class="fc" id="L103">        return orgIdsWithKeysCached.map { Either.right&lt;KmsError, Boolean&gt;(true) } + notCachedResults</span>
    }

    /**
     * Returns Either.right(&lt;was_cached&gt;) or Either.left(KmsError)
     */
    private fun ensureAccountKeyAccess(personPublicId: PersonPublicId,
                                       userPrivateKey: UserPrivateKey,
                                       encryptedAccountKeys: List&lt;EncryptedAccountKey&gt;): List&lt;Either&lt;KmsError, Boolean&gt;&gt; {
        // Run this in batches to avoid overwhelming the database with IN statements.
<span class="fc" id="L113">        return encryptedAccountKeys.chunked(kmsConfig.accountKeyUnlockingBatchSize).flatMap { batchEncryptedAccountKeys -&gt;</span>

            // Check which ones are already org accessible without decrypting anything
<span class="fc" id="L116">            val accountIds = batchEncryptedAccountKeys.map { it.accountPublicId }</span>
<span class="fc" id="L117">            val accountIdsOrgAccessible = orgAccessibleAccountPrivateKeyCacheService.accountsAccessibleViaCachedOrgKeys(accountIds)</span>

            // Find the ones which aren't org accessible
<span class="fc bfc" id="L120" title="All 2 branches covered.">            val accountPathsToFetch = batchEncryptedAccountKeys.filter { it.accountPublicId !in accountIdsOrgAccessible }</span>
<span class="fc" id="L121">                    .map {</span>
<span class="fc" id="L122">                        AccountPath(</span>
<span class="fc" id="L123">                                PersonRequester(personPublicId),</span>
<span class="fc" id="L124">                                it.accountPublicId,</span>
<span class="fc" id="L125">                                it.encryptedAccountPrivateKey,</span>
<span class="fc" id="L126">                                it.encryptedAccountPrivateKey.encryptedSymmetricKey,</span>
<span class="fc" id="L127">                                null)</span>
                    }

<span class="fc" id="L130">            val notOrgAccessibleResults = userAccessibleAccountPrivateKeyCacheService.getAccountPrivateKeysInPath(userPrivateKey, accountPathsToFetch)</span>
<span class="fc" id="L131">                    .map { it.value.map { it.wasCached } }</span>

<span class="fc" id="L133">            accountIdsOrgAccessible.map { Either.right&lt;KmsError, Boolean&gt;(true) } + notOrgAccessibleResults</span>
        }
    }

    private fun recordSummary(results: List&lt;Either&lt;KmsError, Boolean&gt;&gt;, prefix: String) {
<span class="fc" id="L138">        val (lefts, rights) = results.partition { it.isLeft }</span>
<span class="fc" id="L139">        val (cached, decrypted ) = rights.partition { it.get() }</span>
<span class="fc" id="L140">        meterRegistry.summary(&quot;user_private_key_handler_${prefix}_cached&quot;).record(cached.count().toDouble())</span>
<span class="fc" id="L141">        meterRegistry.summary(&quot;user_private_key_handler_${prefix}_decrypted&quot;).record(decrypted.count().toDouble())</span>
<span class="fc" id="L142">        lefts.map { it.left }.groupBy { it.type }.forEach { type, errorsForType -&gt;</span>
<span class="fc" id="L143">            errorsForType.forEach {</span>
<span class="fc" id="L144">                log.warn(&quot;{}&quot;, it)</span>
<span class="fc" id="L145">            }</span>
<span class="fc" id="L146">            meterRegistry.summary(&quot;user_private_key_handler_${prefix}_errors&quot;, &quot;type&quot;, &quot;$type&quot;).record(errorsForType.count().toDouble())</span>
<span class="fc" id="L147">        }</span>
<span class="fc" id="L148">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>