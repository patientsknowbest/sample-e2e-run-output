<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>A19PatientStatusService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.reports</a> &gt; <span class="el_source">A19PatientStatusService.java</span></div><h1>A19PatientStatusService.java</h1><pre class="source lang-java linenums">package com.pkb.reports;

import com.pkb.datamodel.user.Demographics;
import com.pkb.datamodel.user.Person;
import com.pkb.domain.duplicate.PatientDemographicsService;
import com.pkb.domain.duplicate.person.PersonService;
import com.pkb.entities.pub.PublicA19PatientStatus;
import com.pkb.repository.A19PatientStatusRepository;
import io.vavr.Tuple2;
import org.apache.commons.lang3.NotImplementedException;
import org.jetbrains.annotations.Nullable;

import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

public class A19PatientStatusService {

<span class="fc" id="L25">    private static final Instant POSTGRES_DATE_NEGATIVE_INFINITY_INSTANT = Instant.ofEpochMilli(-9223372036832400000L);</span>

    private final PersonService personService;
    private final A19PatientStatusRepository a19PatientStatusRepository;
    private final PatientDemographicsService patientDemographicsService;

    public A19PatientStatusService(PersonService personService,
                                   A19PatientStatusRepository a19PatientStatusRepository,
<span class="fc" id="L33">                                   PatientDemographicsService patientDemographicsService) {</span>
<span class="fc" id="L34">        this.personService = personService;</span>
<span class="fc" id="L35">        this.a19PatientStatusRepository = a19PatientStatusRepository;</span>
<span class="fc" id="L36">        this.patientDemographicsService = patientDemographicsService;</span>
<span class="fc" id="L37">    }</span>

    public Tuple2&lt;Boolean, List&lt;A19Record&gt;&gt; getOrgPatientsWithRegStatusForDataUpload(
            long orgId, @Nullable ZonedDateTime queryStart,
            int pageSize, @Nullable RegistrationStatus registeredStatus, @Nullable UUID lastSeenPublicId) {

<span class="fc bfc" id="L43" title="All 2 branches covered.">        Long lastSeenId = lastSeenPublicId == null ? null : personService.findByPublicId(lastSeenPublicId)</span>
<span class="fc" id="L44">                .map(Person::getId).orElse(null);</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">        Instant queryStartTime = queryStart == null ? null : queryStart.toInstant();</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">        String regStatus = registeredStatus == null ? null : registeredStatus.toString();</span>
<span class="fc" id="L47">        List&lt;PublicA19PatientStatus&gt; results = a19PatientStatusRepository.getPatientStatuses(orgId, queryStartTime, pageSize + 1, regStatus, lastSeenId);</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        if (isPaginationRestartNeeded(queryStartTime, lastSeenId)) {</span>
<span class="fc" id="L49">            results = a19PatientStatusRepository.getPatientStatuses(orgId, queryStartTime, pageSize + 1, regStatus, null);</span>
        }
<span class="fc" id="L51">        List&lt;Long&gt; personIds = results.stream().map(PublicA19PatientStatus::getPersonId).collect(toList());</span>
<span class="fc" id="L52">        Map&lt;Long, Demographics&gt; demographicsMap = patientDemographicsService.findByIds(personIds, toMap(d -&gt; d.getId(), identity()));</span>
<span class="fc" id="L53">        List&lt;A19Record&gt; resultList = results.stream().limit(pageSize).map(p -&gt; convertToResult(p, orgId, demographicsMap)).collect(toList());</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        return new Tuple2&lt;&gt;(pageSize &lt; results.size(), resultList);</span>
    }

    private boolean isPaginationRestartNeeded(Instant queryStartTime, Long lastSeenId) {
<span class="pc bpc" id="L58" title="1 of 4 branches missed.">        if (lastSeenId != null &amp;&amp; queryStartTime != null) {</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">            if (isNegativeInfinity(queryStartTime)) {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">                return a19PatientStatusRepository.countByLastSeenValuesWithNegativeInfinityTimestamp(lastSeenId) &lt; 1;</span>
            } else {
<span class="fc bfc" id="L62" title="All 2 branches covered.">                return a19PatientStatusRepository.countByLastSeenValues(queryStartTime, lastSeenId) &lt; 1;</span>
            }
        }
<span class="fc" id="L65">        return false;</span>
    }

    private A19Record convertToResult(PublicA19PatientStatus patientStatus, long orgId, Map&lt;Long, Demographics&gt; demographicsMap) {
<span class="fc" id="L69">        return ImmutableA19Record.builder()</span>
<span class="fc" id="L70">                .demographics(demographicsMap.get(patientStatus.getPersonId()))</span>
<span class="fc" id="L71">                .orgId(orgId)</span>
<span class="fc" id="L72">                .lastUpdated(patientStatus.getStatusDate())</span>
<span class="fc" id="L73">                .registrationStatus(RegistrationStatus.getRegistrationStatus(patientStatus.getRegistrationStatus())</span>
<span class="pc" id="L74">                        .orElseThrow(() -&gt; new NotImplementedException(&quot;Not implemented registration status: &quot; + patientStatus.getRegistrationStatus())))</span>
<span class="fc" id="L75">                .publicId(patientStatus.getPublicId())</span>
<span class="fc" id="L76">                .build();</span>
    }

    public static boolean isNegativeInfinity(Instant instant) {
<span class="fc" id="L80">        return POSTGRES_DATE_NEGATIVE_INFINITY_INSTANT.equals(instant);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>