<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BirthdayMapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.patient.invite.bulk.csv</a> &gt; <span class="el_source">BirthdayMapper.java</span></div><h1>BirthdayMapper.java</h1><pre class="source lang-java linenums">package com.pkb.patient.invite.bulk.csv;

import com.pkb.common.base.Error;
import com.pkb.common.csv.ColumnMapper;
import com.pkb.common.csv.CsvRecord;
import io.vavr.control.Either;
import org.jetbrains.annotations.NotNull;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Optional;

import static com.pkb.common.base.ErrorBuilder.error;
import static com.pkb.common.base.ErrorBuilder.errorOf;
import static com.pkb.patient.invite.bulk.csv.BulkInvitationConstants.INVITEE_DATE_OF_BIRTH_DAY;
import static com.pkb.patient.invite.bulk.csv.BulkInvitationConstants.INVITEE_DATE_OF_BIRTH_MONTH;
import static com.pkb.patient.invite.bulk.csv.BulkInvitationConstants.INVITEE_DATE_OF_BIRTH_YEAR;
import static java.lang.String.format;
import static java.time.LocalDate.now;
import static java.time.format.DateTimeFormatter.ofPattern;
import static java.util.Collections.singletonList;
import static java.util.Optional.empty;

<span class="fc" id="L26">public class BirthdayMapper implements ColumnMapper&lt;List&lt;Error&gt;, Optional&lt;LocalDate&gt;&gt; {</span>
<span class="fc" id="L27">    private static final DateTimeFormatter INPUT_DATE_TIME_FORMATTER = ofPattern(&quot;yyyy/M/d&quot;);</span>
<span class="fc" id="L28">    private static final DateTimeFormatter DATE_TIME_FORMATTER = ofPattern(&quot;yyyy/MM/dd&quot;);</span>
<span class="fc" id="L29">    private static final LocalDate EARLIEST_DATE = LocalDate.of(1900, 1, 1);</span>

    private static final String DATE_OF_BIRTH_IS_BEFORE_EARLIEST_ALLOWED_DATE_CODE = &quot;patient.bulk.invite.date.of.birth.before.earliest.allowed.date&quot;;
    private static final String DATE_OF_BIRTH_IS_BEFORE_EARLIEST_ALLOWED_DATE = &quot;Date of Birth '%s' is before %s&quot;;
    private static final String DATE_OF_BIRTH_IS_IN_FUTURE_CODE = &quot;patient.bulk.invite.date.of.birth.is.in.future&quot;;
    private static final String DATE_OF_BIRTH_IS_IN_FUTURE = &quot;Date of Birth '%s' is in the future&quot;;
    private static final String MALFORMED_DATE_OF_BIRTH_CODE = &quot;patient.bulk.invite.date.of.birth.malformed&quot;;
    private static final String MALFORMED_DATE_OF_BIRTH = &quot;Date of birth is malformed: '%s'. Parsing error: '%s'&quot;;

    @NotNull
    @Override
    public Either&lt;List&lt;Error&gt;, Optional&lt;LocalDate&gt;&gt; map(@NotNull CsvRecord row) {
<span class="fc" id="L41">        return row</span>
<span class="fc" id="L42">                .findColumn(INVITEE_DATE_OF_BIRTH_YEAR).flatMap(</span>
<span class="fc" id="L43">                        year -&gt; row.findColumn(INVITEE_DATE_OF_BIRTH_MONTH).flatMap(</span>
<span class="fc" id="L44">                                month -&gt; row.findColumn(INVITEE_DATE_OF_BIRTH_DAY).map(</span>
<span class="fc" id="L45">                                        day -&gt; format(&quot;%s/%s/%s&quot;, year, month, day)</span>
                                )
                        )
                )
<span class="fc" id="L49">                .map(dateOfBirth -&gt; validateDate(row, dateOfBirth))</span>
<span class="fc" id="L50">                .orElse(Either.right(empty()));</span>
    }

    private Either&lt;List&lt;Error&gt;, Optional&lt;LocalDate&gt;&gt; validateDate(CsvRecord row, String dateOfBirthString) {
        Either&lt;List&lt;Error&gt;, Optional&lt;LocalDate&gt;&gt; result;

        try {
<span class="fc" id="L57">            LocalDate dateOfBirth = LocalDate.parse(dateOfBirthString, INPUT_DATE_TIME_FORMATTER);</span>

<span class="pc bpc" id="L59" title="1 of 2 branches missed.">            if (dateOfBirth.isBefore(EARLIEST_DATE)) {</span>
<span class="nc" id="L60">                result = Either.left(singletonList(dateOfBirthIsTooEarly(row, dateOfBirth)));</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">            } else if (now().isBefore(dateOfBirth)) {</span>
<span class="nc" id="L62">                result = Either.left(singletonList(dateOfBirthIsInFuture(row, dateOfBirth)));</span>
            } else {
<span class="fc" id="L64">                result = Either.right(Optional.of(dateOfBirth));</span>
            }
<span class="nc" id="L66">        } catch (DateTimeParseException cause) {</span>
<span class="nc" id="L67">            result = Either.left(singletonList(malformed(dateOfBirthString, cause.getMessage())));</span>
<span class="fc" id="L68">        }</span>

<span class="fc" id="L70">        return result;</span>
    }

    private Error malformed(String dateOfBirthString, String cause) {
<span class="nc" id="L74">        return error(MALFORMED_DATE_OF_BIRTH_CODE, MALFORMED_DATE_OF_BIRTH)</span>
<span class="nc" id="L75">                .withArguments(dateOfBirthString, cause)</span>
<span class="nc" id="L76">                .build();</span>
    }

    private Error dateOfBirthIsInFuture(CsvRecord row, LocalDate dateOfBirth) {
<span class="nc" id="L80">        return errorOf(DATE_OF_BIRTH_IS_IN_FUTURE_CODE, DATE_OF_BIRTH_IS_IN_FUTURE, dateOfBirth.format(DATE_TIME_FORMATTER));</span>
    }

    private Error dateOfBirthIsTooEarly(CsvRecord row, LocalDate dateOfBirth) {
<span class="nc" id="L84">        return error(DATE_OF_BIRTH_IS_BEFORE_EARLIEST_ALLOWED_DATE_CODE, DATE_OF_BIRTH_IS_BEFORE_EARLIEST_ALLOWED_DATE)</span>
<span class="nc" id="L85">                .withArguments(dateOfBirth.format(DATE_TIME_FORMATTER), EARLIEST_DATE.format(DATE_TIME_FORMATTER))</span>
<span class="nc" id="L86">                .build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>