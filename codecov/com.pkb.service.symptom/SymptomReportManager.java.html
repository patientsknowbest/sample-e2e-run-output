<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SymptomReportManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.symptom</a> &gt; <span class="el_source">SymptomReportManager.java</span></div><h1>SymptomReportManager.java</h1><pre class="source lang-java linenums">//------------------------------------------------------------------------------
//
// Copyright (c) 2011 PatientsKnowBest, Inc. All Rights Reserved.
//
// $Id: $
//
//------------------------------------------------------------------------------

package com.pkb.service.symptom;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.collect.Table;
import com.google.common.collect.TreeBasedTable;
import com.pkb.app.dto.DateFilterDTO;
import com.pkb.app.dto.PageFilterDTO;
import com.pkb.app.entity.EHRData;
import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.EHRSearch;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.app.entity.PKBFilter;
import com.pkb.app.entity.SourceDetails;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.entities.enums.MenuDataType;
import com.pkb.entities.enums.SponsorshipStatus;
import com.pkb.entities.enums.UserStatus;
import com.pkb.exception.PKBException;
import com.pkb.institute.entity.InstituteUser;
import com.pkb.institute.entity.Team;
import com.pkb.institute.entity.TeamSymptom;
import com.pkb.model.RecordWithId;
import com.pkb.repository.legacy.LegacySymptomReportRepository;
import com.pkb.repository.legacy.LegacyTeamRepository;
import com.pkb.service.instituteuser.InstituteUserManager;
import com.pkb.service.team.TeamManager;
import com.pkb.service.team.TeamUserManager;
import com.pkb.service.user.impl.UserManager;
import com.pkb.service.uuid.UUIDProvider;
import com.pkb.symptom.entity.AlarmSymptomData;
import com.pkb.symptom.entity.Symptom;
import com.pkb.symptom.entity.SymptomAlarmDTO;
import com.pkb.symptom.entity.SymptomReportDTO;
import com.pkb.symptom.entity.SymptomReportHistoryDTO;
import com.pkb.symptom.entity.SymptomSeverity;
import com.pkb.util.DbUtil;
import com.pkb.util.tolven.TolvenBeanFactory;
import com.pkb.util.tolven.TransactionManager;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.beans.XMLDecoder;
import java.io.ByteArrayInputStream;
import java.io.Serializable;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.BiFunction;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.mapping;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;

public class SymptomReportManager extends TransactionManager {

<span class="fc" id="L94">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>
    private static final String UNKNOWN_SEVERITY = &quot;unknown_severity&quot;;
    private static final String REPORT_DATE = &quot;date01&quot;;

    private final UserManager userManager;
    private final TeamManager teamManager;
    private final TeamUserManager teamUserManager;
    private final InstituteUserManager instituteUserManager;
    private final LegacySymptomReportRepository symptomReportRepository;
    private final LegacyTeamRepository teamRepository;

    public SymptomReportManager(PhrConfig config, TolvenBeanFactory beanFactory, DateTimeService dateTimeService, UUIDProvider uuidProvider, UserManager userManager,
            TeamManager teamManager, TeamUserManager teamUserManager, InstituteUserManager instituteUserManager, LegacySymptomReportRepository symptomReportRepository,
                                LegacyTeamRepository teamRepository) {
<span class="fc" id="L108">        super(config, beanFactory, dateTimeService, uuidProvider);</span>
<span class="fc" id="L109">        this.userManager = userManager;</span>
<span class="fc" id="L110">        this.teamManager = teamManager;</span>
<span class="fc" id="L111">        this.teamUserManager = teamUserManager;</span>
<span class="fc" id="L112">        this.instituteUserManager = instituteUserManager;</span>
<span class="fc" id="L113">        this.symptomReportRepository = symptomReportRepository;</span>
<span class="fc" id="L114">        this.teamRepository = teamRepository;</span>
<span class="fc" id="L115">    }</span>

    public List&lt;SymptomReportHistoryDTO&gt; getSymptomReportHistoryList(@NotNull LoggedInEHRRequestContext requestContext, long patientUserId, DateFilterDTO dateFilterDTO, int limit) {
<span class="fc" id="L118">        List&lt;SymptomReportHistoryDTO&gt; historyList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L119">        Map&lt;Long, SymptomReportHistoryDTO&gt; symptomHistoryMap = new HashMap&lt;&gt;();</span>

        try {
<span class="fc" id="L122">            Long patientAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(patientUserId);</span>
<span class="fc" id="L123">            List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt; resultList = getSymptomReports(requestContext, emptyList(), dateFilterDTO, Collections.singletonList(patientAccountId), new PageFilterDTO(limit, 0));</span>

            // loop through and organize
<span class="fc bfc" id="L126" title="All 2 branches covered.">            for (RecordWithId&lt;Long, SymptomReportDTO&gt; result : resultList) {</span>
<span class="fc" id="L127">                addResultToHistory(result.record(), symptomHistoryMap);</span>
<span class="fc" id="L128">            }</span>

            SymptomReportHistoryDTO historyDTO;

<span class="fc bfc" id="L132" title="All 2 branches covered.">            for (Long key : Symptom.getSortedSymptomIds()) {</span>
<span class="fc" id="L133">                historyDTO = symptomHistoryMap.get(key);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                if (historyDTO != null) {</span>
<span class="fc" id="L135">                    historyList.add(historyDTO);</span>
                }
<span class="fc" id="L137">            }</span>

<span class="nc" id="L139">        } catch (Exception e) {</span>
<span class="nc" id="L140">            throw new PKBException(&quot;failed getting symptom report history for &quot; + patientUserId, e);</span>
<span class="fc" id="L141">        }</span>

        // sort. TODO: for greater efficiency, look at doing this in MenuBean where the MenuData query is done,
        // and also removing the searches by individual day in the JSP
        // Collections.sort(historyList, new SymptomListComparable() );
<span class="fc" id="L146">        return historyList;</span>
    }

<span class="fc" id="L149">    private class SymptomListComparable implements Comparator&lt;SymptomReportHistoryDTO&gt;, Serializable {</span>

        @Override
        public int compare(SymptomReportHistoryDTO symptom1, SymptomReportHistoryDTO symptom2) {
<span class="fc" id="L153">            String symptomName1 = symptom1.getSymptom().getName();</span>
<span class="fc" id="L154">            String symptomName2 = symptom2.getSymptom().getName();</span>
<span class="fc" id="L155">            return symptomName1.compareToIgnoreCase(symptomName2);</span>
        }
    }

    private void addResultToHistory(SymptomReportDTO result, Map&lt;Long, SymptomReportHistoryDTO&gt; symptomHistoryMap) {
<span class="fc" id="L160">        Long symptomId = result.getSymptomPrivateId();</span>
<span class="fc" id="L161">        SymptomReportHistoryDTO history = symptomHistoryMap.get(symptomId);</span>

        // didn't find -- set up a new history item
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (history == null) {</span>
<span class="fc" id="L165">            Symptom symptom = Symptom.getById(result.getSymptomPrivateId());</span>

<span class="fc" id="L167">            List&lt;SymptomReportDTO&gt; symptomReportList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L168">            history = new SymptomReportHistoryDTO();</span>
<span class="fc" id="L169">            history.setSymptom(symptom);</span>
<span class="fc" id="L170">            history.setSymptomReportList(symptomReportList);</span>
<span class="fc" id="L171">            symptomHistoryMap.put(symptomId, history);</span>
        }

<span class="fc" id="L174">        history.getSymptomReportList().add(result);</span>

<span class="fc" id="L176">    }</span>

    public Long saveSymptomReport(@NotNull LoggedInEHRRequestContext requestContext, SymptomReportDTO symptomReportDto, long patientUserId) {
<span class="fc" id="L179">        Long accountId = userManager.getDefaultAccountId(patientUserId);</span>
        try {
<span class="fc" id="L181">            return saveSymptomReport(requestContext, symptomReportDto, patientUserId, accountId);</span>
<span class="nc" id="L182">        } catch (Exception e) {</span>
<span class="nc" id="L183">            throw new PKBException(&quot;failed saving symptom report for &quot; + patientUserId, e);</span>
        }
    }

    public void saveSymptomReports(@NotNull LoggedInEHRRequestContext requestContext, List&lt;SymptomReportDTO&gt; resultList, long patientUserId) {
        try {
<span class="fc" id="L189">            transactional(() -&gt; {</span>
<span class="fc" id="L190">                Long accountId = userManager.getDefaultAccountId(patientUserId);</span>
<span class="fc" id="L191">                saveSymptomReports(requestContext, resultList, patientUserId, accountId);</span>
<span class="fc" id="L192">            });</span>
<span class="nc" id="L193">        } catch (Exception e) {</span>
<span class="nc" id="L194">            throw new RuntimeException(&quot;Failed saving symptom reports for patient-&quot; + patientUserId, e);</span>
<span class="fc" id="L195">        }</span>
<span class="fc" id="L196">    }</span>

    public Set&lt;TeamSymptom&gt; getTeamSymptoms(EHRRequestContext requestContext, String instituteCode) {
<span class="fc" id="L199">        Team team = teamManager.getTeamByCode(instituteCode, Team.Lazy.SYMPTOMS);</span>
<span class="fc" id="L200">        return team.getSymptomsToMonitor();</span>
    }

<span class="fc" id="L203">    static class TeamSymptomComparator implements Comparator&lt;TeamSymptom&gt;, Serializable {</span>

        @Override
        public int compare(TeamSymptom o1, TeamSymptom o2) {
<span class="pc bpc" id="L207" title="3 of 4 branches missed.">            if ((o1.getOrdering() == null) &amp;&amp; (o2.getOrdering() == null)) {</span>
<span class="nc" id="L208">                return 0;</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            } else if (o1.getOrdering() == null) {</span>
<span class="nc" id="L210">                return 1;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            } else if (o2.getOrdering() == null) {</span>
<span class="nc" id="L212">                return -1;</span>
            } else {
<span class="fc" id="L214">                return o1.getOrdering().compareTo(o2.getOrdering());</span>
            }
        }
    }

    /**
     * Returns an ordered list of symptoms monitored by a given team (ordered
     * low to high by the ordering for the corresponding TeamSymptom object)
     *
     * @param institudeCode
     * @return
     */
    public List&lt;Symptom&gt; getSymptomsMonitoredByTeam(EHRRequestContext requestContext, String teamCode) {
<span class="fc" id="L227">        Team team = teamManager.getTeamByCode(teamCode, Team.Lazy.SYMPTOMS);</span>
<span class="fc" id="L228">        List&lt;Symptom&gt; symptoms = new ArrayList&lt;&gt;();</span>

        //order team symptoms by ordering
<span class="fc" id="L231">        List&lt;TeamSymptom&gt; teamSymptoms = new ArrayList&lt;&gt;(team.getSymptomsToMonitor());</span>
<span class="fc" id="L232">        teamSymptoms.sort(new TeamSymptomComparator());</span>

        //make symptom list in same order
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (TeamSymptom teamSymptom : teamSymptoms) {</span>
<span class="fc" id="L236">            symptoms.add(teamSymptom.getSymptom());</span>
<span class="fc" id="L237">        }</span>
<span class="fc" id="L238">        return symptoms;</span>
    }

    public void saveSymptomsForInstitute(@NotNull LoggedInEHRRequestContext requestContext, String instituteCode,
                                         Set&lt;TeamSymptom&gt; symptoms,
                                         Long symptomAlarmRedThreshold, Long symptomAlarmAmberThreshold, Long symptomAlarmDays) {
<span class="fc" id="L244">        Team team = teamManager.getTeamByCode(instituteCode, Team.Lazy.SYMPTOMS);</span>
<span class="fc" id="L245">        LOGGER.info(&quot;Saving symptoms for team-{} redThreshold={} amberThreshold={} days={}&quot;,</span>
                instituteCode, symptomAlarmRedThreshold, symptomAlarmAmberThreshold, symptomAlarmDays);
        // TEMPORARILY use transactions at this level until potentially long-running
        // updateSymptomAlarmsForTeam() can be done as a background job

<span class="fc" id="L250">        teamManager.transactional(() -&gt; {</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">            for (TeamSymptom symptom : symptoms) {</span>
<span class="fc" id="L253">                symptom.setTeam(team);</span>
<span class="fc" id="L254">            }</span>
<span class="fc" id="L255">            team.setSymptomsToMonitor(symptoms);</span>
<span class="fc" id="L256">            team.setSymptomAlarmRedThreshold(symptomAlarmRedThreshold);</span>
<span class="fc" id="L257">            team.setSymptomAlarmAmberThreshold(symptomAlarmAmberThreshold);</span>
<span class="fc" id="L258">            team.setSymptomAlarmDays(symptomAlarmDays);</span>
<span class="fc" id="L259">            teamManager.deleteSymptomsToMonitor(team);</span>
<span class="fc" id="L260">            teamManager.updateTeam(team);</span>
<span class="fc" id="L261">        });</span>

<span class="fc" id="L263">        updateSymptomAlarmsForTeam(requestContext, team);</span>
<span class="fc" id="L264">    }</span>

    public boolean hasSymptomsForToday(EHRRequestContext requestContext, long patientUserId) {
<span class="fc" id="L267">        Instant midnightThisMorning = dateTimeService.nowZonedDateTime().truncatedTo(ChronoUnit.DAYS).toInstant();</span>

<span class="fc" id="L269">        Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(patientUserId);</span>
<span class="fc" id="L270">        EHRSearch&lt;SymptomReportDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, SymptomReportDTO.class,</span>
                SymptomReportDTO.MS_PATH);

<span class="fc" id="L273">        ehrSearch.addFilter(new PKBFilter(REPORT_DATE, PKBFilter.Operator.GREATER_OR_EQUAL, midnightThisMorning));</span>

<span class="fc" id="L275">        return beanFactory</span>
<span class="fc" id="L276">                .getEhrRemote()</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                .countEHRData(ehrSearch, requestContext) &gt; 0L;</span>
    }

    private void updateSymptomAlarmsForTeam(@NotNull LoggedInEHRRequestContext requestContext, Team team) {

<span class="fc" id="L282">        LOGGER.info(&quot;Updating symptom alarms for team-{}&quot;, team.getId());</span>

        // TEMPORARILY update each patient's alarms in a separate transaction as the whole update can
        // cause a single transaction to timeout, and letting the bean manage the transactions is
        // too much of a nuisance

<span class="fc" id="L288">        List&lt;InstituteUser&gt; patientInstituteUsers = teamUserManager.getTeamPatientsByStatus(team.getId(),</span>
<span class="fc" id="L289">                EnumSet.of(UserStatus.EMAIL_CONFIRMED, UserStatus.NOCONTACT), EnumSet.of(SponsorshipStatus.ACTIVE), 0, 0);</span>

<span class="fc" id="L291">        var patientIds = patientInstituteUsers.stream()</span>
<span class="fc" id="L292">                .map(iu -&gt; iu.getPersonId())</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                .filter(l -&gt; l != null)</span>
<span class="fc" id="L294">                .collect(toSet());</span>

<span class="fc" id="L296">        updateSymptomAlarms(requestContext, team, patientIds);</span>
<span class="fc" id="L297">    }</span>

    public Long saveSymptomReport(@NotNull LoggedInEHRRequestContext requestContext, SymptomReportDTO dto, long patientUserId,
                                  Long accountId) {
        try {
<span class="fc" id="L302">            return saveReports(requestContext, Collections.singletonList(dto), patientUserId, accountId).stream()</span>
<span class="fc" id="L303">                    .findAny()</span>
<span class="fc" id="L304">                    .orElseThrow();</span>
<span class="nc" id="L305">        } catch (Exception e) {</span>
<span class="nc" id="L306">            throw new RuntimeException(&quot;Exception while saving symptom report for &quot; + patientUserId, e);</span>
        }
    }

    public void saveSymptomReports(@NotNull LoggedInEHRRequestContext requestContext, List&lt;SymptomReportDTO&gt; dtoList,
                                   long patientUserId, Long accountId) {
        try {
<span class="fc" id="L313">            saveReports(requestContext, dtoList, patientUserId, accountId);</span>
<span class="nc" id="L314">        } catch (Exception e) {</span>
<span class="nc" id="L315">            throw new RuntimeException(&quot;Exception while saving symptom reports for &quot; + patientUserId, e);</span>
<span class="fc" id="L316">        }</span>
<span class="fc" id="L317">    }</span>

    private Set&lt;Long&gt; saveReports(@NotNull LoggedInEHRRequestContext requestContext, List&lt;SymptomReportDTO&gt; dtoList, long patientUserId, Long accountId) {
        try {
<span class="fc" id="L321">            dtoList.forEach(symptomReportDTO -&gt; {</span>
<span class="fc" id="L322">                symptomReportDTO.getBaseFields().generateNewRandomUniqueId();</span>

<span class="fc" id="L324">                symptomReportDTO.setSymptomPrivateId(symptomReportDTO.getSymptomPrivateId());</span>

<span class="fc" id="L326">                SymptomSeverity symptomSeverity = symptomReportDTO.getSeverity();</span>
<span class="fc" id="L327">                String severity = UNKNOWN_SEVERITY;</span>
<span class="pc bpc" id="L328" title="2 of 4 branches missed.">                if (symptomSeverity != null &amp;&amp; symptomSeverity != SymptomSeverity.UNKNOWN) {</span>
<span class="fc" id="L329">                    severity = symptomSeverity.getNumber0to3().toString();</span>
                }

<span class="fc" id="L332">                symptomReportDTO.setSeverityPrivateId(severity);</span>
<span class="fc" id="L333">                symptomReportDTO.getBaseFields().setDefaultGeneralConsentIfNoneSet();</span>
<span class="fc" id="L334">            });</span>

<span class="fc" id="L336">            var ids = beanFactory.getEhrRemote().populateEHRDataListAndSave(dtoList, accountId, MenuDataType.symptomReport, requestContext);</span>
            // Ensuring records can be picked up by the following call which updates alarms for patients
            // thereby alerting the professionals
<span class="fc" id="L339">            symptomReportRepository.flush();</span>

            try {
<span class="fc" id="L342">                updateSymptomAlarmsForPatient(requestContext, patientUserId, accountId);</span>
<span class="nc" id="L343">            } catch (Exception e) {</span>
<span class="nc" id="L344">                LOGGER.error(&quot;Error while updating symptom alarms after saving symptom reports for patient-{}&quot;, patientUserId, e);</span>
<span class="fc" id="L345">            }</span>

<span class="fc" id="L347">            return ids;</span>
<span class="nc" id="L348">        } catch (Exception e) {</span>
<span class="nc" id="L349">            throw new RuntimeException(&quot;Exception while saving symptom reports&quot;, e);</span>
        }
    }

    private List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt; getSymptomReports(@NotNull LoggedInEHRRequestContext requestContext,
                                                                         Collection&lt;Long&gt; symptomIds,
                                                                         DateFilterDTO dateFilterDTO,
                                                                         Collection&lt;Long&gt; patientAccountIds,
                                                                         PageFilterDTO pageFilterDTO) {
<span class="fc" id="L358">        return fillSeverity(getSymptomReportsForAccount(requestContext, symptomIds, dateFilterDTO, patientAccountIds, pageFilterDTO));</span>
    }

    private List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt; getSymptomReportsForAccount(@NotNull LoggedInEHRRequestContext requestContext,
                                                                                   Collection&lt;Long&gt; symptomIds,
                                                                                   DateFilterDTO dateFilterDTO,
                                                                                   Collection&lt;Long&gt; patientAccountIds,
                                                                                   PageFilterDTO pageFilterDTO) {
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">        if (pageFilterDTO.getOffset() != 0 || pageFilterDTO.getPageSize() != 0) {</span>
<span class="pc bpc" id="L367" title="7 of 8 branches missed.">            if (isNotEmpty(symptomIds) &amp;&amp; 1 &lt; symptomIds.size() &amp;&amp; isNotEmpty(patientAccountIds) &amp;&amp; 1 &lt; patientAccountIds.size()) {</span>
<span class="nc" id="L368">                throw new NotImplementedException(&quot;Pagination with multiple set of IDs isn't implemented!&quot;);</span>
            }

<span class="pc bpc" id="L371" title="3 of 4 branches missed.">            if (isNotEmpty(symptomIds) &amp;&amp; 1 &lt; symptomIds.size()) {</span>
<span class="nc" id="L372">                return symptomIds.stream()</span>
<span class="nc" id="L373">                        .flatMap(symptomId -&gt; doGetSymptomReportsForAccount(requestContext, Collections.singletonList(symptomId), dateFilterDTO, patientAccountIds, pageFilterDTO).stream())</span>
<span class="nc" id="L374">                        .collect(toList());</span>
<span class="pc bpc" id="L375" title="2 of 4 branches missed.">            } else if (isNotEmpty(patientAccountIds) &amp;&amp; 1 &lt; patientAccountIds.size()) {</span>
<span class="nc" id="L376">                return patientAccountIds.stream()</span>
<span class="nc" id="L377">                        .flatMap(patientAccountId -&gt; doGetSymptomReportsForAccount(requestContext, symptomIds, dateFilterDTO, Collections.singletonList(patientAccountId), pageFilterDTO).stream())</span>
<span class="nc" id="L378">                        .collect(toList());</span>
            }
        }

<span class="fc" id="L382">        return doGetSymptomReportsForAccount(requestContext, symptomIds, dateFilterDTO, patientAccountIds, pageFilterDTO);</span>
    }

    private List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt; doGetSymptomReportsForAccount(@NotNull LoggedInEHRRequestContext requestContext,
                                                                                     Collection&lt;Long&gt; symptomIds,
                                                                                     DateFilterDTO dateFilterDTO,
                                                                                     Collection&lt;Long&gt; patientAccountIds,
                                                                                     PageFilterDTO pageFilterDTO) {
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (isEmpty(patientAccountIds)) {</span>
<span class="nc" id="L391">            return emptyList();</span>
        }

<span class="fc" id="L394">        BiFunction&lt;Collection&lt;Long&gt;, Collection&lt;Long&gt;, List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt;&gt; search = (batchOfSymptomIds, batchOfPatientAccountIds) -&gt; {</span>

<span class="fc" id="L396">            EHRSearch&lt;SymptomReportDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(batchOfPatientAccountIds, SymptomReportDTO.class, SymptomReportDTO.MS_PATH);</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (isNotEmpty(batchOfSymptomIds)) {</span>
<span class="fc" id="L399">                ehrSearch.addFilter(new PKBFilter(&quot;symptomPrivateId&quot;, PKBFilter.Operator.IN, batchOfSymptomIds));</span>
            }

<span class="fc bfc" id="L402" title="All 2 branches covered.">            if (dateFilterDTO.getFromDate() != null) {</span>
<span class="fc" id="L403">                ehrSearch.addFilter(</span>
<span class="fc" id="L404">                        new PKBFilter(SymptomReportDTO.MD_REPORT_DATE, PKBFilter.Operator.GREATER_OR_EQUAL, dateFilterDTO.getFromDate()));</span>
            }

<span class="pc bpc" id="L407" title="1 of 2 branches missed.">            if (dateFilterDTO.getToDate() != null) {</span>
<span class="nc" id="L408">                ehrSearch.addFilter(</span>
<span class="nc" id="L409">                        new PKBFilter(SymptomReportDTO.MD_REPORT_DATE, PKBFilter.Operator.LESS_OR_EQUAL, dateFilterDTO.getToDate()));</span>
            }

<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (pageFilterDTO.getPageSize() &gt; 0) {</span>
<span class="fc" id="L413">                ehrSearch.setResultsMaxReturned(pageFilterDTO.getPageSize());</span>
            }

<span class="fc" id="L416">            ehrSearch.setResultsStartPosition(pageFilterDTO.getOffset());</span>

            // No need for sorting by date because the plotting takes care of it
<span class="fc" id="L419">            ehrSearch.setOrderBy(REPORT_DATE, EHRSearch.OrderByDirection.Asc);</span>

<span class="fc" id="L421">            return beanFactory.getEhrRemote().queryDecryptAndPopulateDataByAccountId(ehrSearch, SymptomReportDTO.class, requestContext);</span>
        };

<span class="pc bpc" id="L424" title="1 of 4 branches missed.">        if (isEmpty(symptomIds) || symptomIds.size() &lt; patientAccountIds.size()) {</span>
<span class="fc" id="L425">            return DbUtil.getInBatches(patientAccountIds, batchOfPatientAccountIds -&gt; search.apply(symptomIds, batchOfPatientAccountIds));</span>
        }
<span class="fc" id="L427">        return DbUtil.getInBatches(symptomIds, batchOfSymptomIds -&gt; search.apply(batchOfSymptomIds, patientAccountIds));</span>
    }

    private List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt; fillSeverity(List&lt;RecordWithId&lt;Long, SymptomReportDTO&gt;&gt; dtoList) {
<span class="fc" id="L431">        dtoList.forEach(recordWithId -&gt; {</span>
<span class="fc" id="L432">            var symptomReportDTO = recordWithId.record();</span>
<span class="fc" id="L433">            String severity = symptomReportDTO.getSeverityPrivateId();</span>
<span class="fc" id="L434">            symptomReportDTO.setSeverity(null);</span>
<span class="pc bpc" id="L435" title="2 of 4 branches missed.">            if (StringUtils.isNotEmpty(severity) &amp;&amp; !severity.equals(UNKNOWN_SEVERITY)) {</span>
<span class="fc" id="L436">                symptomReportDTO.setSeverity(SymptomSeverity.getBy0to3(Integer.valueOf(severity)));</span>
            }
<span class="fc" id="L438">        });</span>
<span class="fc" id="L439">        return dtoList;</span>
    }

    public List&lt;SymptomReportHistoryDTO&gt; getSymptomReportHistoryList(@NotNull LoggedInEHRRequestContext requestContext, List&lt;Long&gt; symptomIds, long patientUserId, long patientAccountId, Instant fromDate) {
        try {
<span class="fc" id="L444">            Instant nullToDate = null;</span>
<span class="fc" id="L445">            List&lt;SymptomReportHistoryDTO&gt; historyList = retrieveSymptomReportHistoryList(requestContext, symptomIds, fromDate, nullToDate, patientAccountId, 0, 0);</span>
            // sort. TODO: for greater efficiency, look at doing this in MenuBean where the MenuData query is done,
            // and also removing the searches by individual day in the JSP
<span class="fc" id="L448">            historyList.sort(new SymptomListComparable());</span>
<span class="fc" id="L449">            return historyList;</span>
<span class="nc" id="L450">        } catch (Exception e) {</span>
<span class="nc" id="L451">            throw new PKBException(&quot;Error while getting symptoms history for &quot; + patientUserId, e);</span>
        }
    }

    public List&lt;SymptomReportHistoryDTO&gt; retrieveSymptomReportHistoryList(@NotNull LoggedInEHRRequestContext requestContext,
                                                                          List&lt;Long&gt; symptomIds, Instant fromDateOrNull, Instant toDateOrNull, long patientAccountId, int pageSize, int offset) {

<span class="fc" id="L458">        var symptomReportList = getSymptomReports(requestContext, symptomIds, new DateFilterDTO(fromDateOrNull, toDateOrNull), singletonList(patientAccountId), new PageFilterDTO(pageSize, offset));</span>

<span class="fc" id="L460">        List&lt;SymptomReportHistoryDTO&gt; historyList = new ArrayList&lt;&gt;(symptomReportList.size());</span>

<span class="fc" id="L462">        var symptomReportMap = symptomReportList.stream()</span>
<span class="fc" id="L463">                .collect(groupingBy(recordWithId -&gt; recordWithId.record().getSymptomPrivateId(), mapping(recordWithId -&gt; recordWithId.record(), toList())));</span>

<span class="fc bfc" id="L465" title="All 2 branches covered.">        for (Long symptomId : symptomIds) {</span>
            // didn't find -- set up a new history item
<span class="fc" id="L467">            Symptom symptom = Symptom.getById(symptomId);</span>
<span class="fc" id="L468">            SymptomReportHistoryDTO history = new SymptomReportHistoryDTO();</span>
<span class="fc" id="L469">            history.setSymptom(symptom);</span>
<span class="fc" id="L470">            history.setSymptomReportList(symptomReportMap.getOrDefault(symptomId, emptyList()));</span>

<span class="fc" id="L472">            historyList.add(history);</span>
<span class="fc" id="L473">        }</span>

<span class="fc" id="L475">        return historyList;</span>
    }

    private Map&lt;Long, SymptomReportDTO&gt; retrieveLatestSymptoms(@NotNull LoggedInEHRRequestContext requestContext, List&lt;Long&gt; symptomIds, long patientAccountId) {
        try {
<span class="fc bfc" id="L480" title="All 2 branches covered.">            if (isEmpty(symptomIds)) {</span>
<span class="fc" id="L481">                return emptyMap();</span>
            }
<span class="fc" id="L483">            EHRSearch&lt;SymptomReportDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(patientAccountId, SymptomReportDTO.class, SymptomReportDTO.MS_PATH);</span>
<span class="fc" id="L484">            ehrSearch.setOrderBy(REPORT_DATE, EHRSearch.OrderByDirection.Asc);</span>
<span class="fc" id="L485">            var symptoms = beanFactory.getEhrRemote().queryDecryptAndPopulateDataByAccountId(ehrSearch, SymptomReportDTO.class, requestContext);</span>
<span class="fc" id="L486">            return fillSeverity(symptoms)</span>
<span class="fc" id="L487">                    .stream()</span>
<span class="pc" id="L488">                    .collect(toMap(recordWithId -&gt; recordWithId.record().getSymptomPrivateId(), recordWithId -&gt; recordWithId.record(), (v1, v2) -&gt; v1, TreeMap::new));</span>
<span class="nc" id="L489">        } catch (Exception e) {</span>
<span class="nc" id="L490">            LOGGER.error(&quot;Exception getting latest symptom reports&quot;, e);</span>
<span class="nc" id="L491">            throw new RuntimeException(&quot;Exception while getting latest symptom reports&quot;, e);</span>
        }
    }

    /**
     * Get latest value for each of the symptom in the list
     *
     * @param symptoms
     * @param userId
     * @return
     */
    public Map&lt;Long, SymptomReportDTO&gt; getLatestSymptoms(@NotNull LoggedInEHRRequestContext requestContext, List&lt;Long&gt; symptoms, long userId, long userAccountId) {
        try {
<span class="fc" id="L504">            return retrieveLatestSymptoms(requestContext, symptoms, userAccountId);</span>
<span class="nc" id="L505">        } catch (Exception e) {</span>
<span class="nc" id="L506">            throw new PKBException(&quot;Exception while getting latest value of symptoms for user-&quot; + userId, e);</span>
        }
    }

    /**
     * Get the date of the latest symptom
     *
     * @param patientId
     * @return
     */
    public Optional&lt;LocalDate&gt; getDateOfLatestSymptom(long patientId) {
<span class="fc" id="L517">        return transactional(() -&gt; {</span>
<span class="fc" id="L518">            Long patientAccountId = userManager.getDefaultAccountId(patientId);</span>
<span class="fc" id="L519">            return symptomReportRepository.getDateOfLatestSymptom(patientAccountId);</span>
        });
    }

    /**
     * Get a list of teams with active alarms for the given patient
     *
     * @param patientId
     * @return
     */
    public List&lt;Team&gt; getTeamsWithActiveAlarms(long patientId) {
        try {
<span class="fc" id="L531">            return teamManager.getTeamsWithActiveAlarms(patientId);</span>
<span class="nc" id="L532">        } catch (Exception e) {</span>
<span class="nc" id="L533">            throw new PKBException(&quot;Exception while getting teams with active alarms for patient-&quot; + patientId, e);</span>
        }
    }

    private boolean hasAnySymptomAlarms(Team team) {
<span class="pc bpc" id="L538" title="1 of 4 branches missed.">        return team.getSymptomAlarmAmberThreshold() != null || team.getSymptomAlarmRedThreshold() != null;</span>
    }

    private boolean eitherOfTheAlarmThresholdReached(Team team, long score) {
<span class="pc bpc" id="L542" title="1 of 4 branches missed.">        return (team.getSymptomAlarmAmberThreshold() != null &amp;&amp; score &gt;= team.getSymptomAlarmAmberThreshold())</span>
<span class="pc bpc" id="L543" title="2 of 4 branches missed.">                || (team.getSymptomAlarmRedThreshold() != null &amp;&amp; score &gt;= team.getSymptomAlarmRedThreshold());</span>
    }

    /**
     * Source for alarms populated from EHRRequestContext
     */
    private void updateSymptomAlarmsForPatient(@NotNull LoggedInEHRRequestContext requestContext, long patientUserId, Long patientAccountId) {
<span class="fc" id="L550">        LOGGER.info(&quot;Updating symptom alarms for patient-{} account-{}&quot;, patientUserId, patientAccountId);</span>
<span class="fc" id="L551">        ZonedDateTime now = dateTimeService.nowZonedDateTime();</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (InstituteUser patientInstituteUser : instituteUserManager.getInstituteUsersForPerson(requestContext, patientUserId, Team.Lazy.SYMPTOMS)) {</span>
<span class="fc" id="L554">            Team team = patientInstituteUser.getInstitute(); // Not returning</span>
            // symptomAlarmX!!!
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">            LOGGER.info(&quot;Updating symptom alarms for patient-{} team-{}&quot;, patientUserId, (team == null ? &quot;null&quot; : team.getCode()));</span>
<span class="fc" id="L557">            ImmutableMap&lt;Symptom, Long&gt; symptomWeightMap = getSymptomWeightMap(team);</span>

<span class="fc bfc" id="L559" title="All 2 branches covered.">            if (hasAnySymptomAlarms(team)) {</span>
<span class="fc" id="L560">                Tuple2&lt;Instant, Instant&gt; dates = getSymptomAlarmStartAndEnd(now, team);</span>
<span class="fc" id="L561">                Instant fromDate = dates._1;</span>
<span class="fc" id="L562">                Instant expiryDate = dates._2;</span>
<span class="fc" id="L563">                var latestReports = getLatestReportForEachSymptom(requestContext, Collections.singletonList(patientAccountId), fromDate, null/* toDate */);</span>

<span class="fc" id="L565">                transactional(() -&gt; {</span>
<span class="fc" id="L566">                    symptomReportRepository.deleteSymptomAlarms(team.getTeamAccountId(), Collections.singletonList(patientUserId));</span>
<span class="fc" id="L567">                    SymptomAlarmDTO symptomAlarm = convertToSymptomAlarmDto(team, latestReports, symptomWeightMap, requestContext, expiryDate, patientUserId, patientAccountId);</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                    if (symptomAlarm != null) {</span>
<span class="fc" id="L569">                        beanFactory.getEhrRemote().populateEHRDataAndSave(symptomAlarm, team.getTeamAccountId(), MenuDataType.symptomAlarm, requestContext);</span>
                    }
<span class="fc" id="L571">                });</span>
            }
<span class="fc" id="L573">        }</span>
<span class="fc" id="L574">    }</span>

    public AlarmSymptomData getAlarmSymptomData(SymptomReportDTO reportDTO) {
<span class="fc" id="L577">        AlarmSymptomData alarmSymptomData = new AlarmSymptomData();</span>
<span class="fc" id="L578">        alarmSymptomData.setSymptomReportId(reportDTO.getId());</span>
<span class="fc" id="L579">        alarmSymptomData.setSeverity(reportDTO.getSeverity());</span>
<span class="fc" id="L580">        alarmSymptomData.setReportDate(reportDTO.getReportDate());</span>
<span class="fc" id="L581">        alarmSymptomData.setSymptomId(reportDTO.getSymptomPrivateId());</span>
<span class="fc" id="L582">        return alarmSymptomData;</span>
    }

    private Tuple2&lt;Instant, Instant&gt; getSymptomAlarmStartAndEnd(ZonedDateTime now, Team team) {
<span class="fc" id="L586">        Instant fromDate = now.minusDays(team.getSymptomAlarmDays()).toInstant();</span>
<span class="fc" id="L587">        Instant expiryDate = now.plusDays(team.getSymptomAlarmDays()).toInstant();</span>
<span class="fc" id="L588">        return Tuple.of(fromDate, expiryDate);</span>
    }

    private Table&lt;Long, Long, SymptomReportDTO&gt; getLatestReportForEachSymptom(@NotNull LoggedInEHRRequestContext requestContext,
                                                                              Collection&lt;Long&gt; patientAccountIds,
                                                                              Instant fromDate,
                                                                              Instant toDate) {
<span class="fc" id="L595">        var symptomReports = getSymptomReports(</span>
                requestContext,
<span class="fc" id="L597">                emptyList(),</span>
                new DateFilterDTO(fromDate, toDate),
                patientAccountIds,
                new PageFilterDTO(0, 0));

<span class="fc" id="L602">        Table&lt;Long, Long, SymptomReportDTO&gt; latestReportsByAccountId = TreeBasedTable.create();</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">        for (RecordWithId&lt;Long, SymptomReportDTO&gt; recordWithId : symptomReports) {</span>
<span class="fc" id="L605">            var report = recordWithId.record();</span>
            // Cannot get the latest by checking the reportDate field because
            // symptoms submitted from the 'Update Symptoms'
            // page only have dd/mm/yyyy dates (although those from the dashboard
            // have full timestamps).
            // Instead rely on hibernate giving higher ids to later records
<span class="fc" id="L611">            SymptomReportDTO currentLatest = latestReportsByAccountId.get(recordWithId.id(), report.getSymptomPrivateId());</span>
<span class="fc bfc" id="L612" title="All 4 branches covered.">            if (currentLatest == null || report.getId() &gt; currentLatest.getId()) {</span>
<span class="fc" id="L613">                latestReportsByAccountId.put(recordWithId.id(), report.getSymptomPrivateId(), report);</span>
            }
<span class="fc" id="L615">        }</span>

<span class="fc" id="L617">        return latestReportsByAccountId;</span>
    }

    private ImmutableMap&lt;Symptom, Long&gt; getSymptomWeightMap(Team team) {
<span class="fc" id="L621">        EnumMap&lt;Symptom, Long&gt; result = new EnumMap&lt;&gt;(Symptom.class);</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (isNotEmpty(team.getSymptomsToMonitor())) {</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            for (TeamSymptom teamSymptom : team.getSymptomsToMonitor()) {</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">                if (teamSymptom.getAlarmWeighting() == null) {</span>
<span class="nc" id="L625">                    result.put(teamSymptom.getSymptom(), 0L);</span>
                } else {
<span class="fc" id="L627">                    result.put(teamSymptom.getSymptom(), teamSymptom.getAlarmWeighting());</span>
                }
<span class="fc" id="L629">            }</span>
        }
<span class="fc" id="L631">        return Maps.immutableEnumMap(result);</span>
    }

    private long calculateAlarmScore(ImmutableMap&lt;Symptom, Long&gt; symptomWeightMap, Map&lt;Long, SymptomReportDTO&gt; latestReports) {
<span class="fc" id="L635">        long score = 0L;</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (var entry : symptomWeightMap.entrySet()) {</span>
<span class="fc" id="L637">            SymptomReportDTO latestReport = latestReports.get(entry.getKey().getId());</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">            if (latestReport != null) {</span>
<span class="fc" id="L639">                Integer severityValue = latestReport.getSeverity().getNumber0to3();</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">                if (severityValue != null) {</span>
<span class="fc" id="L641">                    Long weighting = entry.getValue();</span>
<span class="pc bpc" id="L642" title="2 of 4 branches missed.">                    if (weighting != null &amp;&amp; 0L &lt; weighting) {</span>
<span class="fc" id="L643">                        score += (weighting * severityValue);</span>
                    }
                }
            }
<span class="fc" id="L647">        }</span>
<span class="fc" id="L648">        return score;</span>
    }

    @Nullable
    private SymptomAlarmDTO convertToSymptomAlarmDto(Team team, Table&lt;Long, Long, SymptomReportDTO&gt; latestReportsByAccountId, ImmutableMap&lt;Symptom, Long&gt; symptomWeightMap, LoggedInEHRRequestContext requestContext, Instant expiryDate, Long patientUserId, Long patientDefaultAccountId) {
<span class="fc" id="L653">        Map&lt;Long, SymptomReportDTO&gt; latestReports = latestReportsByAccountId.row(patientDefaultAccountId);</span>

<span class="fc" id="L655">        long score = calculateAlarmScore(symptomWeightMap, latestReports);</span>
        // TODO - with a future configPhase3 store alarm colour
        // meanwhile store all alarms together and separate on
        // display
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (eitherOfTheAlarmThresholdReached(team, score)) {</span>
<span class="fc" id="L660">            var monitoredSymptoms = symptomWeightMap.keySet();</span>
<span class="fc" id="L661">            List&lt;AlarmSymptomData&gt; alarmSymptomDataList = new ArrayList&lt;&gt;(monitoredSymptoms.size());</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">            for (Symptom monitoredSymptom : monitoredSymptoms) {</span>
<span class="fc" id="L663">                SymptomReportDTO latestReport = latestReports.get(monitoredSymptom.getId());</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">                if (latestReport == null) {</span>
<span class="fc" id="L665">                    SymptomReportDTO emptyReport = new SymptomReportDTO(new SourceDetails(requestContext));</span>
<span class="fc" id="L666">                    emptyReport.setSymptomPrivateId(monitoredSymptom.getId());</span>
<span class="fc" id="L667">                    emptyReport.setSeverity(null);</span>
<span class="fc" id="L668">                    latestReport = emptyReport;</span>
                }
<span class="fc" id="L670">                alarmSymptomDataList.add(getAlarmSymptomData(latestReport));</span>
<span class="fc" id="L671">            }</span>

<span class="fc" id="L673">            SymptomAlarmDTO symptomAlarm = new SymptomAlarmDTO(new SourceDetails(requestContext));</span>
<span class="fc" id="L674">            symptomAlarm.setPatientId(Long.toString(patientUserId));</span>
<span class="fc" id="L675">            symptomAlarm.setScore(score);</span>
<span class="fc" id="L676">            symptomAlarm.setSymptomDataList(alarmSymptomDataList);</span>
<span class="fc" id="L677">            symptomAlarm.setExpiryDate(Date.from(expiryDate));</span>
<span class="fc" id="L678">            symptomAlarm.generateNewRandomUniqueId();</span>
<span class="fc" id="L679">            return symptomAlarm;</span>
        }
<span class="fc" id="L681">        return null;</span>
    }

    /**
     * Alarm source populated from requestContext
     */
    public void updateSymptomAlarms(@NotNull LoggedInEHRRequestContext requestContext, Team team, Collection&lt;Long&gt; patientUserIds) {
        try {
<span class="fc" id="L689">            LOGGER.info(&quot;Updating symptom alarms for team-{} patients-{}&quot;, team.getId(), patientUserIds);</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">            if (hasAnySymptomAlarms(team)) {</span>
<span class="fc" id="L691">                ZonedDateTime today = dateTimeService.nowZonedDateTime();</span>
<span class="fc" id="L692">                Tuple2&lt;Instant, Instant&gt; dates = getSymptomAlarmStartAndEnd(today, team);</span>
<span class="fc" id="L693">                Instant fromDate = dates._1;</span>
<span class="fc" id="L694">                Instant expiryDate = dates._2;</span>

<span class="fc" id="L696">                var defaultAccountIds = userManager.getDefaultAccountId(patientUserIds);</span>

<span class="fc" id="L698">                var symptomWeightMap = getSymptomWeightMap(team);</span>

<span class="fc" id="L700">                transactional(() -&gt; {</span>
<span class="fc" id="L701">                    symptomReportRepository.deleteSymptomAlarms(team.getTeamAccountId(), patientUserIds);</span>

<span class="fc" id="L703">                    Table&lt;Long, Long, SymptomReportDTO&gt; latestReportsByAccountId = getLatestReportForEachSymptom(requestContext, Set.copyOf(defaultAccountIds.values()), fromDate, null);</span>

<span class="fc" id="L705">                    var symptomAlarms = patientUserIds.stream()</span>
<span class="fc" id="L706">                            .map(patientUserId -&gt; {</span>
<span class="fc" id="L707">                                Long patientDefaultAccountId = defaultAccountIds.get(patientUserId);</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">                                if (patientDefaultAccountId == null) {</span>
<span class="nc" id="L709">                                    LOGGER.error(&quot;Cannot update symptom alarms for patient {} as default account id is null!&quot;, patientUserId);</span>
<span class="nc" id="L710">                                    return null;</span>
                                } else {
<span class="fc" id="L712">                                    return convertToSymptomAlarmDto(team, latestReportsByAccountId, symptomWeightMap, requestContext, expiryDate, patientUserId, patientDefaultAccountId);</span>
                                }
                            })
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">                            .filter(symptomAlarm -&gt; symptomAlarm != null)</span>
<span class="fc" id="L716">                            .collect(toList());</span>

<span class="fc" id="L718">                    beanFactory.getEhrRemote().populateEHRDataListAndSave(symptomAlarms, team.getTeamAccountId(), MenuDataType.symptomAlarm, requestContext);</span>
<span class="fc" id="L719">                });</span>
            }
<span class="nc" id="L721">        } catch (Exception e) {</span>
<span class="nc" id="L722">            throw new RuntimeException(&quot;Error while updating symptom alarms for team-&quot; + team + &quot; patients: &quot; + patientUserIds.stream().map(p -&gt; p.toString()).collect(joining(&quot;,&quot;)), e);</span>
<span class="fc" id="L723">        }</span>
<span class="fc" id="L724">    }</span>

    /**
     * @param ehr
     * @
     */
    private List&lt;AlarmSymptomData&gt; getXMLToList(EHRData ehr) {
<span class="nc" id="L731">        List&lt;AlarmSymptomData&gt; symptomDataList = new ArrayList&lt;&gt;();</span>

        // old records has it in XML format
<span class="nc" id="L734">        Object symptomReportsXMLObj = ehr.getEncryptedField(&quot;symptomReports&quot;);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (symptomReportsXMLObj != null) {</span>
            List&lt;SymptomReportDTO&gt; symptomReports;
<span class="nc" id="L737">            String symptomReportsXML = (String) symptomReportsXMLObj;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">            if (symptomReportsXML instanceof String) {</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                if (StringUtils.isNotBlank(symptomReportsXML)) {</span>
                    // convert it into list of SymptomReportDTO
<span class="nc" id="L741">                    XMLDecoder decoder = new XMLDecoder(new ByteArrayInputStream(symptomReportsXML.getBytes()));</span>
<span class="nc" id="L742">                    symptomReports = (List&lt;SymptomReportDTO&gt;) decoder.readObject();</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">                    if (symptomReports != null) {</span>
                        // convert them into AlarmSymptomData
                        AlarmSymptomData alarmSymptomData;
<span class="nc bnc" id="L747" title="All 2 branches missed.">                        for (SymptomReportDTO reportDTO : symptomReports) {</span>
<span class="nc" id="L748">                            alarmSymptomData = getAlarmSymptomData(reportDTO);</span>
<span class="nc" id="L749">                            symptomDataList.add(alarmSymptomData);</span>
<span class="nc" id="L750">                        }</span>
                    }
                }
            }
        }
<span class="nc" id="L755">        return symptomDataList;</span>
    }

    /**
     * Populate symptom alarm DTO
     *
     * @param ehrData
     * @return
     * @
     */
    @Nullable
    private SymptomAlarmDTO populateSymptomAlarm(EHRRequestContext requestContext, EHRData ehrData) {
<span class="nc" id="L767">        SymptomAlarmDTO symptomAlarm = beanFactory.getEhrRemote().populateDTO(ehrData, SymptomAlarmDTO.class, requestContext);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (ehrData.getMigrationVersion() &lt; 1) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (symptomAlarm.getSymptomDataList() == null) {</span>
<span class="nc" id="L770">                List&lt;AlarmSymptomData&gt; symptomDataList = getXMLToList(ehrData);</span>
<span class="nc" id="L771">                symptomAlarm.setSymptomDataList(symptomDataList);</span>
                // Version 1 Migrate the list of SymptomReport saved as xml into
                // extended fields to AlarmSymptomData
<span class="nc" id="L774">                EHRData ehrData2 = beanFactory.getEhrRemote().populateEHRData(symptomAlarm,</span>
<span class="nc" id="L775">                        ehrData.getAccountId(), MenuDataType.symptomAlarm, requestContext);</span>
<span class="nc" id="L776">                beanFactory.getEhrRemote().saveEHRData(requestContext, ehrData2);</span>
            }
        }

<span class="nc" id="L780">        Long score = symptomAlarm.getScore();</span>
<span class="nc bnc" id="L781" title="All 4 branches missed.">        if ((score == null) || (score.compareTo(0L) == 0)) {</span>
<span class="nc" id="L782">            return null;</span>
        }

<span class="nc" id="L785">        String patientIdString = symptomAlarm.getPatientId();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if (StringUtils.isEmpty(patientIdString)) {</span>
<span class="nc" id="L787">            LOGGER.error(&quot;Empty patientId for symptomAlarm-{}&quot;, symptomAlarm.getId());</span>
        }
<span class="nc" id="L789">        Long patientId = getLong(patientIdString);</span>

<span class="nc" id="L791">        symptomAlarm.setPatient(beanFactory.getPKBPersonBean().findPKBPerson(patientId).getOrNull());</span>
<span class="nc" id="L792">        return symptomAlarm;</span>
    }

    @Nullable
    private Long getLong(Object object) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (StringUtils.isNumeric((String) object)) {</span>
<span class="nc" id="L798">            return Long.parseLong((String) object);</span>
        } else {
<span class="nc" id="L800">            return null;</span>
        }
    }

    private List&lt;SymptomAlarmDTO&gt; getSymptomAlarmRecords(@NotNull LoggedInEHRRequestContext requestContext, Long accountId) {
        try {
<span class="nc" id="L806">            EHRSearch&lt;SymptomAlarmDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, SymptomAlarmDTO.class,</span>
                    SymptomAlarmDTO.MS_PATH);
<span class="nc" id="L808">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>
<span class="nc" id="L809">            List&lt;SymptomAlarmDTO&gt; symptomAlarms = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L810">            Instant now = dateTimeService.now();</span>
            SymptomAlarmDTO symptomAlarm;
<span class="nc bnc" id="L812" title="All 2 branches missed.">            for (EHRData ehrData : ehrList) {</span>
<span class="nc" id="L813">                symptomAlarm = populateSymptomAlarm(requestContext, ehrData);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">                if ((symptomAlarm != null)</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                        &amp;&amp; now.isBefore(symptomAlarm.getExpiryDate().toInstant())) {</span>
<span class="nc" id="L816">                    symptomAlarms.add(symptomAlarm);</span>
                }
<span class="nc" id="L818">            }</span>

<span class="nc" id="L820">            return symptomAlarms;</span>
<span class="nc" id="L821">        } catch (Exception e) {</span>
<span class="nc" id="L822">            LOGGER.error(&quot;Exception getting symptom alarms&quot;, e);</span>
<span class="nc" id="L823">            throw new RuntimeException(&quot;Exception while getting symptom alarms&quot;, e);</span>
        }
    }

    public List&lt;SymptomAlarmDTO&gt; getSymptomAlarms(@NotNull LoggedInEHRRequestContext requestContext, String teamCode) {
<span class="nc" id="L828">        Team team = teamRepository.getInstituteByCode(teamCode, Team.Lazy.SYMPTOMS);</span>

<span class="nc" id="L830">        List&lt;SymptomAlarmDTO&gt; symptomAlarms = getSymptomAlarmRecords(requestContext, team.getTeamAccountId());</span>

<span class="nc" id="L832">        symptomAlarms.sort((lhs, rhs) -&gt; (int) (rhs.getScore() - lhs.getScore()));</span>

<span class="nc" id="L834">        return symptomAlarms;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>