<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EncounterManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.encounter.impl.tolven</a> &gt; <span class="el_source">EncounterManager.java</span></div><h1>EncounterManager.java</h1><pre class="source lang-java linenums">package com.pkb.service.encounter.impl.tolven;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.pkb.action.dto.ActivityDTO;
import com.pkb.allergy.entity.Allergy;
import com.pkb.api.internal.messaging.MessagingPKBPersonDTO;
import com.pkb.api.internal.messaging.PKBPersonToMessagingPKBPersonDTOConverter;
import com.pkb.app.entity.DTOMapping;
import com.pkb.app.entity.EHRData;
import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.EHRSearch;
import com.pkb.app.entity.ImmutableLoggedOutEHRRequestContext;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.app.entity.LoggedOutEHRRequestContext;
import com.pkb.app.entity.PKBFilter;
import com.pkb.app.entity.SourceDetails;
import com.pkb.app.interfaces.IBaseDTO;
import com.pkb.calendar.entity.AppointmentDTO;
import com.pkb.client.message.MessageDetails;
import com.pkb.client.message.MessageMetaData;
import com.pkb.client.message.exception.InconsistentDataException;
import com.pkb.client.message.exception.MessageServiceException;
import com.pkb.client.message.exception.PersonNotFoundException;
import com.pkb.client.message.exception.TeamNotFoundException;
import com.pkb.client.message.model.MessageDetailsAndContent;
import com.pkb.client.message.util.MessageMetaDataPrivacyFlagConverter;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.common.util.FrameFilter;
import com.pkb.consent.model.ConsentStatus;
import com.pkb.datamodel.ImmutableAttachmentMetadata;
import com.pkb.datamodel.ImmutableNewUnreadableDocument;
import com.pkb.datamodel.messages.workflow.ConversationWorkflowExisting;
import com.pkb.dataupload.entity.UploadedData;
import com.pkb.dataupload.entity.UploadedData.Format;
import com.pkb.dataupload.entity.UploadedDataDTO;
import com.pkb.document.entity.Attachment;
import com.pkb.document.entity.DocumentsByIdAndAccount;
import com.pkb.domain.UnreadableDocumentService;
import com.pkb.domain.messages.workflow.TrustedConversationWorkflowService;
import com.pkb.encounter.entity.ApiConversationDTO;
import com.pkb.encounter.entity.Encounter;
import com.pkb.encounter.entity.EncounterEvent;
import com.pkb.encounter.entity.EncounterToAppointmentLink;
import com.pkb.encounter.entity.FailedMessageDTO;
import com.pkb.encounter.entity.InboxConversationDTO;
import com.pkb.encounter.entity.Message;
import com.pkb.encounter.entity.MessageSenderDTO;
import com.pkb.entities.enums.EncounterClass;
import com.pkb.entities.enums.MenuDataType;
import com.pkb.entities.enums.PrivacyFlag;
import com.pkb.entities.enums.Route;
import com.pkb.entities.enums.SponsorshipStatus;
import com.pkb.entities.enums.messaging.MessageStatus;
import com.pkb.grpc.common.ListTransform;
import com.pkb.institute.entity.InstituteUser;
import com.pkb.institute.entity.Org;
import com.pkb.institute.entity.Team;
import com.pkb.messaging.workflow.ConversationWorkflowFilterDTO;
import com.pkb.notification.entity.Activity;
import com.pkb.notification.entity.ActivityProperty;
import com.pkb.phplan.entity.PHPlan;
import com.pkb.phplan.entity.PlanField;
import com.pkb.questionnaireservice.modelv2.QuestionnaireRequest;
import com.pkb.repository.legacy.LegacyEncounterRepository;
import com.pkb.repository.legacy.LegacyEncounterToAppointmentLinkRepository;
import com.pkb.repository.legacy.LegacyLoincMappingRepository;
import com.pkb.repository.legacy.LegacyLoincTestRepository;
import com.pkb.repository.legacy.LegacyOrgRepository;
import com.pkb.repository.legacy.LegacyTeamRepository;
import com.pkb.service.SynchableManager;
import com.pkb.service.code.CodeManager;
import com.pkb.service.dataupload.hl7.HL7MessageType;
import com.pkb.service.dataupload.hl7.HL7ParsingManager;
import com.pkb.service.dataupload.hl7.HL7Wrapper;
import com.pkb.service.dataupload.hl7.HL7XmlDoc;
import com.pkb.service.dataupload.impl.DataUploadManager;
import com.pkb.service.dataupload.processor.UploadedDataService;
import com.pkb.service.dataupload.processor.domain.UploadedDataProcessingResult;
import com.pkb.service.dataupload.processor.domain.UploadedDocument;
import com.pkb.service.document.AttachmentManager;
import com.pkb.service.document.DocumentManager;
import com.pkb.service.emailmessage.impl.EmailManager;
import com.pkb.service.emailmessage.impl.PKBEmailMessageManager;
import com.pkb.service.encounter.workflow.ConversationWorkflowConverter;
import com.pkb.service.file.ChunkedDocManager;
import com.pkb.service.instituteuser.InstituteUserManager;
import com.pkb.service.notification.nhs.NhsAppNotificationManager;
import com.pkb.service.notification.nhs.pubsub.payload.NhsApiNotificationTriggerType;
import com.pkb.service.patientconsent.PatientConsentManager;
import com.pkb.service.phplan.ParticipantManager;
import com.pkb.service.phplan.PlanManager;
import com.pkb.service.team.TeamManager;
import com.pkb.service.user.impl.UserManager;
import com.pkb.service.uuid.UUIDProvider;
import com.pkb.test.entity.LoincMapping;
import com.pkb.test.entity.LoincTest;
import com.pkb.test.entity.TestResultDTO;
import com.pkb.test.entity.TestResultType;
import com.pkb.user.entity.PKBPerson;
import com.pkb.util.CorrelationIdUtil;
import com.pkb.util.security.PdfValidator;
import com.pkb.util.tolven.TolvenBeanFactory;
import com.pkb.util.tolven.TransactionManager;
import io.micrometer.core.instrument.Metrics;
import io.prometheus.client.Counter;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.control.Either;
import io.vavr.control.Option;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.text.StringEscapeUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import javax.naming.NamingException;
import javax.transaction.SystemException;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandles;
import java.text.ParseException;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.base.Predicates.instanceOf;
import static com.google.common.collect.Lists.newArrayList;
import static com.pkb.action.dto.ActivityDTOBuilder.anActivityDTO;
import static com.pkb.encounter.entity.InlineContentTypes.MSG_INLINE_CALL;
import static com.pkb.grpc.common.GrpcValidationUtil.getOptionalIssueFromMissingValueInMap;
import static com.pkb.sciStore.util.SciStoreConstants.SCISTORE_LOINC_WHITELIST;
import static com.pkb.sciStore.util.SciStoreConstants.SCISTORE_SOURCE_TEXT;
import static com.pkb.service.dataupload.processor.ImmutableLoggedInUploadedDataProcessingContext.loggedInUploadedDataProcessingContext;
import static com.pkb.service.dataupload.processor.ImmutableLoggedOutUploadedDataProcessingContext.loggedOutUploadedDataProcessingContext;
import static com.pkb.service.encounter.impl.tolven.EncounterManagerUtil.populateApiRef;
import static com.pkb.util.Constants.APPLICATION_TZ;
import static com.pkb.util.EncryptedDocumentMapperHelper.genericMetadata;
import static io.vavr.API.$;
import static io.vavr.API.Case;
import static io.vavr.API.Match;
import static io.vavr.API.unchecked;
import static java.lang.Long.parseLong;
import static java.text.MessageFormat.format;
import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singleton;
import static java.util.Collections.singletonList;
import static java.util.Collections.unmodifiableList;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.collections.CollectionUtils.isEqualCollection;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

/**
 * This Manager class handles all Tolven specific operations on Message entity
 *
 * @author pravinam
 */
@SuppressWarnings({&quot;ClassWithTooManyMethods&quot;, &quot;OverlyComplexClass&quot;})
public class EncounterManager extends TransactionManager implements SynchableManager {

    private static final String ENCOUNTER_REASON_CODE_ID = &quot;reasonCodeId&quot;;
<span class="fc" id="L203">    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>
<span class="fc" id="L204">    private static final Pattern INLINE_CONTENT_PATTERN = Pattern.compile(&quot;[CALL=#]&quot;, Pattern.LITERAL);</span>

<span class="fc" id="L206">    private static final Counter documentSaves = Counter.build()</span>
<span class="fc" id="L207">            .name(&quot;pkb_phr_hl7_document_saves&quot;)</span>
<span class="fc" id="L208">            .help(&quot;Document save success/failure count&quot;)</span>
<span class="fc" id="L209">            .labelNames(&quot;type&quot;, &quot;outcome&quot;)</span>
<span class="fc" id="L210">            .register();</span>

<span class="fc" id="L212">    private static final io.prometheus.client.Counter hl7DocumentDeletionErrorCounter = Counter.build()</span>
<span class="fc" id="L213">            .name(&quot;pkb_phr_HL7_MDM_T11_error&quot;)</span>
<span class="fc" id="L214">            .help(&quot;HL7 Document deletion error&quot;)</span>
<span class="fc" id="L215">            .register();</span>

<span class="fc" id="L217">    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;dd/MMM/yyyy&quot;).withLocale(Locale.UK).withZone(APPLICATION_TZ);</span>

    private static final String DOCUMENT_TIMER_NAME = &quot;phr_add_participant_document_copy_timer&quot;;
    private static final String MESSAGE_TIMER_NAME = &quot;phr_add_participant_message_copy_timer&quot;;

<span class="fc" id="L222">    private static final Map&lt;MenuDataType, Class&gt; MESSAGE_AND_ENCOUNTER_DATATYPE_DTO_MAP = Maps.immutableEnumMap(ImmutableMap.&lt;MenuDataType, Class&gt;builder()</span>
<span class="fc" id="L223">            .put(Message.MS_PATH_MESSAGE, Message.class)</span>
<span class="fc" id="L224">            .put(EncounterEvent.MS_PATH_ENCOUNTER_EVENT, EncounterEvent.class)</span>
<span class="fc" id="L225">            .build());</span>

    /**
     * getRemoteBeanAndSynch is not safe to run in multiple threads for the same account.
     */
<span class="fc" id="L230">    private static final Cache&lt;Long, Object&gt; UPLOAD_SYNCH_LOCKS = CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.MINUTES).build();</span>
<span class="fc" id="L231">    private static final Pattern planPattern = Pattern.compile(&quot;\\[PLAN=[\\w-]+\\]&quot;);</span>
<span class="fc" id="L232">    private static final Set&lt;MenuDataType&gt; ENCOUNTER_TYPES = Sets.immutableEnumSet(Message.MS_PATH_MESSAGE, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>

<span class="fc" id="L234">    private volatile static List&lt;Long&gt; scistoreLoincIdWhitelist = null;</span>
<span class="fc" id="L235">    private volatile static ZonedDateTime nextCacheUpdate = null;</span>

    private final PKBEmailMessageManager messagingManager;
    private final UserManager userManager;
    private final PlanManager planManager;
    private final DataUploadManager dataUploadManager;
    private final ThreadPoolTaskExecutor taskExecutor;
    private final UploadedDataService uploadedDataService;
    private final TrustedConversationWorkflowService trustedConversationWorkflowService;
    private final TeamManager teamManager;
    private final CorrelationIdUtil correlationIdUtil;
    private final ConversationWorkflowConverter conversationWorkflowConverter;
    private final ParticipantManager participantManager;
    private final UnreadableDocumentService unreadableDocumentService;
    private final HL7ParsingManager hl7ParsingManager;
    private final NhsAppNotificationManager nhsAppNotificationManager;
    private final PdfValidator pdfValidator;
    private final CodeManager codeManager;
    private final AttachmentManager attachmentManager;
    private final PatientConsentManager patientConsentManager;
    private final InstituteUserManager instituteUserManager;
    private final PKBPersonToMessagingPKBPersonDTOConverter pkbPersonDTOConverter;
    private final LegacyEncounterRepository encounterRepository;
    private final ChunkedDocManager chunkedDocManager;
    private final LegacyEncounterToAppointmentLinkRepository encounterToAppointmentLinkRepository;
    private final LegacyLoincTestRepository loincTestRepository;
    private final LegacyTeamRepository teamRepository;
    private final LegacyOrgRepository orgRepository;
    private final LegacyLoincMappingRepository loincMappingRepository;
    private final DocumentManager documentManager;

    public EncounterManager(PhrConfig config, TolvenBeanFactory beanFactory, DateTimeService dateTimeService, UUIDProvider uuidProvider, PKBEmailMessageManager messagingManager,
                            UserManager userManager, PlanManager planManager, DataUploadManager dataUploadManager,
                            ThreadPoolTaskExecutor taskExecutor, UploadedDataService uploadedDataService,
                            TrustedConversationWorkflowService trustedConversationWorkflowService, TeamManager teamManager,
                            CorrelationIdUtil correlationIdUtil,
                            ConversationWorkflowConverter conversationWorkflowConverter, ParticipantManager participantManager, UnreadableDocumentService unreadableDocumentService,
                            HL7ParsingManager hl7ParsingManager, NhsAppNotificationManager nhsAppNotificationManager, PdfValidator pdfValidator, CodeManager codeManager,
                            AttachmentManager attachmentManager, PatientConsentManager patientConsentManager, InstituteUserManager instituteUserManager,
                            PKBPersonToMessagingPKBPersonDTOConverter pkbPersonDTOConverter, LegacyEncounterRepository encounterRepository,
                            LegacyEncounterToAppointmentLinkRepository encounterToAppointmentLinkRepository, LegacyLoincTestRepository loincTestRepository, LegacyLoincMappingRepository loincMappingRepository,
                            ChunkedDocManager chunkedDocManager, LegacyTeamRepository teamRepository, LegacyOrgRepository orgRepository, DocumentManager documentManager) {
<span class="fc" id="L277">        super(config, beanFactory, dateTimeService, uuidProvider);</span>
<span class="fc" id="L278">        this.messagingManager = messagingManager;</span>
<span class="fc" id="L279">        this.userManager = userManager;</span>
<span class="fc" id="L280">        this.planManager = planManager;</span>
<span class="fc" id="L281">        this.dataUploadManager = dataUploadManager;</span>
<span class="fc" id="L282">        this.taskExecutor = taskExecutor;</span>
<span class="fc" id="L283">        this.uploadedDataService = uploadedDataService;</span>
<span class="fc" id="L284">        this.trustedConversationWorkflowService = trustedConversationWorkflowService;</span>
<span class="fc" id="L285">        this.teamManager = teamManager;</span>
<span class="fc" id="L286">        this.correlationIdUtil = correlationIdUtil;</span>
<span class="fc" id="L287">        this.conversationWorkflowConverter = conversationWorkflowConverter;</span>
<span class="fc" id="L288">        this.participantManager = participantManager;</span>
<span class="fc" id="L289">        this.unreadableDocumentService = unreadableDocumentService;</span>
<span class="fc" id="L290">        this.hl7ParsingManager = hl7ParsingManager;</span>
<span class="fc" id="L291">        this.nhsAppNotificationManager = nhsAppNotificationManager;</span>
<span class="fc" id="L292">        this.pdfValidator = pdfValidator;</span>
<span class="fc" id="L293">        this.codeManager = codeManager;</span>
<span class="fc" id="L294">        this.attachmentManager = attachmentManager;</span>
<span class="fc" id="L295">        this.patientConsentManager = patientConsentManager;</span>
<span class="fc" id="L296">        this.instituteUserManager = instituteUserManager;</span>
<span class="fc" id="L297">        this.pkbPersonDTOConverter = pkbPersonDTOConverter;</span>
<span class="fc" id="L298">        this.encounterRepository = encounterRepository;</span>
<span class="fc" id="L299">        this.encounterToAppointmentLinkRepository = encounterToAppointmentLinkRepository;</span>
<span class="fc" id="L300">        this.chunkedDocManager = chunkedDocManager;</span>
<span class="fc" id="L301">        this.teamRepository = teamRepository;</span>
<span class="fc" id="L302">        this.orgRepository = orgRepository;</span>
<span class="fc" id="L303">        this.loincTestRepository = loincTestRepository;</span>
<span class="fc" id="L304">        this.loincMappingRepository = loincMappingRepository;</span>
<span class="fc" id="L305">        this.documentManager = documentManager;</span>
<span class="fc" id="L306">    }</span>
    
    public Long saveMessageNewConversation(LoggedInEHRRequestContext loggedInEHRRequestContext, Message message,
                                           List&lt;Attachment&gt; attachments) {
        try {
<span class="fc" id="L311">            setUpMessageEncounterUniqueId(message);</span>
            // Struts own List doesn't unserialize!
            // Also, no more mutating the participants now please.
<span class="fc" id="L314">            List&lt;String&gt; properList = ImmutableList.copyOf(message.getParticipants());</span>
<span class="fc" id="L315">            message.setParticipants(properList);</span>
<span class="fc" id="L316">            Long result = saveMessage(loggedInEHRRequestContext, message, attachments);</span>

<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (!message.isDraft()) {</span>
<span class="fc" id="L319">                participantManager.saveParticipantsForMessage(loggedInEHRRequestContext, message);</span>
            }

<span class="fc" id="L322">            return result;</span>
<span class="nc" id="L323">        } catch (Exception exception) {</span>
<span class="nc" id="L324">            throw new RuntimeException(&quot;Error while saving message&quot;, exception);</span>
        }
    }
    
    private void setUpMessageEncounterUniqueId(Message message){
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (message.getEncounterUniqueId() == null) {</span>
<span class="fc" id="L330">            UUID uniqueId = super.uuidProvider.randomUUID();</span>
<span class="fc" id="L331">            message.setEncounterUniqueId(uniqueId);</span>
<span class="fc" id="L332">            message.getBaseFields().setUniqueId(uniqueId);</span>
        }
<span class="fc" id="L334">    }</span>

    /**
     * @param requestContext    The logged in request context
     * @param loggedInUserId    The logged in user Id
     * @param message           The message to save
     * @param attachments       The attachments to be added when the message is sent
     * @param contextUserId     The context user Id
     * @param isDefinitelyFirst If you know it's the first message in a conversation, we can skip attempting to retrieve existing
     *                          conversation metadata to determine participants, referred patient etc.
     *                          {@code true} if {@code message} should be used as the source of truth.
     *                          {@code false} if details from existing messages should be prioritised instead
     * @return the id of the sender message
     */
    public Long saveMessage(LoggedInEHRRequestContext loggedInEHRRequestContext, long loggedInUserId, Message message,
                            List&lt;Attachment&gt; attachments, Long contextUserId, boolean isDefinitelyFirst) {
        try {
<span class="fc" id="L351">            Long accountId = userManager</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    .getDefaultAccountId(contextUserId == null ? loggedInUserId : contextUserId);</span>

<span class="fc" id="L354">            Encounter conversation = null;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">            if (!isDefinitelyFirst) {</span>
<span class="fc" id="L356">                conversation = getConversation(loggedInEHRRequestContext.withoutAccessLog(),</span>
<span class="fc" id="L357">                        message.getEncounterUniqueId(),</span>
<span class="fc" id="L358">                        loggedInUserId,</span>
                        accountId);
<span class="fc" id="L360">                Optional.ofNullable(conversation).ifPresent(encounter -&gt; codeManager.populateCodes(Collections.singletonList(encounter)));</span>
            }

            List&lt;String&gt; participants;
<span class="fc" id="L364">            PKBPerson patientReferredTo = null;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (conversation != null) {</span>
<span class="fc" id="L366">                Message lastMessage = conversation.getLatestMessage();</span>
<span class="fc" id="L367">                participants = lastMessage.getParticipants();</span>
<span class="fc" id="L368">                stackTraceIfParticipantsDiffer(message, participants);</span>
<span class="fc" id="L369">                patientReferredTo = getReferredPatient(loggedInEHRRequestContext, accountId, conversation);</span>
                //maintain the encounter class
<span class="fc" id="L371">                message.setEncounterClass(conversation.getEncounterClass());</span>
<span class="fc" id="L372">            } else {</span>
                // Struts own List doesn't unserialize!
<span class="fc" id="L374">                participants = new LinkedList&lt;&gt;(message.getParticipants());</span>
<span class="fc" id="L375">                message.setParticipants(null);</span>
<span class="fc" id="L376">                String patientId = message.getPatientId();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                if (patientId != null) {</span>
                    // if a clinician sends message to colleagues without selecting patients
<span class="fc" id="L379">                    patientReferredTo = userManager.getPKBPerson(parseLong(patientId), PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>
                }
                // conversation initiated from PKB , by default it would be virtual
                // till we support choosing encounter-class through UI
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                if (message.getEncounterClass() == null) {</span>
<span class="fc" id="L384">                    message.setEncounterClass(EncounterClass.VIRTUAL);</span>
                }
            }

            //Set the participants in the conversation
<span class="fc" id="L389">            message.setParticipants(participants);</span>
            // participants for which the message should not be saved
            // the list will be empty in this case
<span class="fc" id="L392">            List&lt;String&gt; skipParticipants = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L394" title="All 4 branches covered.">            boolean requiresImmediatePatientAccountSave = contextUserId != null &amp;&amp; !contextUserId.equals(loggedInUserId);</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">            message.initializeUniqueIds(conversation == null);</span>

<span class="fc" id="L398">            return saveMessageForParticipants(loggedInEHRRequestContext, patientReferredTo, skipParticipants, message,</span>
                    attachments, requiresImmediatePatientAccountSave);
<span class="nc" id="L400">        } catch (Exception exception) {</span>
<span class="nc" id="L401">            throw new RuntimeException(&quot;Error while saving message&quot;, exception);</span>
        }
    }

    private void stackTraceIfParticipantsDiffer(Message newMessage, List&lt;String&gt; previousParticipants) {
<span class="fc" id="L406">        List&lt;String&gt; newParticipants = newMessage.getParticipants();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (!newParticipants.isEmpty()</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                &amp;&amp; !isEqualCollection(previousParticipants, newMessage.getParticipants())) {</span>
            //noinspection NewExceptionWithoutArguments
<span class="fc" id="L410">            LOGGER.warn(&quot;PHR-7102: Using participants for previous message rather than those requested. EncounterUniqueId: {} Previous: {} Requested: {}&quot;, newMessage.getEncounterUniqueId(), previousParticipants, newMessage.getParticipants(),</span>
<span class="fc" id="L411">                    FrameFilter.filter(new Exception().fillInStackTrace()));</span>
        }
<span class="fc" id="L413">    }</span>

    private void logIfPatientMessageHasMissingPatientParticipant(UUID encounterUniqueId, List&lt;String&gt; participants, PKBPerson referredPatient) {
<span class="fc" id="L416">        Optional.ofNullable(referredPatient)</span>
<span class="fc" id="L417">                .map(PKBPerson::getIdString)</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">                .filter(patid -&gt; !participants.contains(patid))</span>
<span class="fc" id="L419">                .ifPresent(patid -&gt; {</span>
<span class="nc" id="L420">                    String logging = String.format(&quot;PHRZ-563 - Message %s about patient %s is missing patient participant. Participants: %s&quot;, encounterUniqueId, patid,</span>
                            participants);
<span class="nc bnc" id="L422" title="All 2 branches missed.">                    if (config.isExceptionForMissingPatientParticipantEnabled()) {</span>
<span class="nc" id="L423">                        throw new RuntimeException(logging);</span>
                    } else {
                        //noinspection NewExceptionWithoutArguments
<span class="nc" id="L426">                        LOGGER.error(logging, FrameFilter.filter(new Exception().fillInStackTrace()));</span>
                    }
<span class="nc" id="L428">                });</span>
<span class="fc" id="L429">    }</span>

    public Long addParticipants(LoggedInEHRRequestContext loggedInEHRRequestContext, Message joinMessage,
                                List&lt;String&gt; addedParticipants, List&lt;Attachment&gt; joinMessageAttachments, Long contextUserId) {
        try {
<span class="fc" id="L434">            String inviterIdString = joinMessage.getSenderId();</span>
<span class="fc" id="L435">            long inviterId = parseLong(inviterIdString);</span>

<span class="fc" id="L437">            long existingConversationAccountId = getBestExistingConversationAccountId(joinMessage, contextUserId);</span>

<span class="fc" id="L439">            long inviterAccountId = userManager.getDefaultAccountId(inviterId);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            boolean requiresImmediatePatientAccountSave = inviterAccountId != existingConversationAccountId;</span>

<span class="fc" id="L442">            Encounter conversation = getOptionalConversation(loggedInEHRRequestContext.withoutAccessLog(),</span>
<span class="fc" id="L443">                    joinMessage.getEncounterUniqueId(),</span>
                    inviterId,
                    existingConversationAccountId)
<span class="pc" id="L446">                    .orElseThrow(() -&gt; new IllegalStateException(format(&quot;Unable to find conversation uuid=%s&quot;, joinMessage.getEncounterUniqueId())));</span>

<span class="fc" id="L448">            List&lt;String&gt; newParticipants = calculateAndSetParticipants(loggedInEHRRequestContext, joinMessage, addedParticipants, existingConversationAccountId, conversation);</span>

<span class="fc" id="L450">            joinMessage.setEncounterClass(conversation.getEncounterClass());</span>

<span class="fc" id="L452">            PKBPerson inviterPerson = userManager.getPKBPerson(inviterId);</span>
            // get the referred patient
<span class="fc" id="L454">            PKBPerson patientReferredTo = userManager.getPKBPerson(parseLong(conversation.getAboutPatientId()), PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>

<span class="fc" id="L456">            Long senderMessageId = null;</span>

<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            if (joinMessage.getContent() != null) {</span>
                // first save the message into sender's account
                // the messages id thus saved will be used for parallel save
                // for new &amp; old participants, skip the new ones
<span class="fc" id="L462">                List&lt;String&gt; skipParticipants = new ArrayList&lt;&gt;(newParticipants);</span>
                try {
                    //save the message in all participants list except for new ones
                    // if it is in draft it will not be saved for other participants
<span class="fc" id="L466">                    senderMessageId = saveMessageForParticipants(loggedInEHRRequestContext, patientReferredTo,</span>
                            skipParticipants, joinMessage, joinMessageAttachments, requiresImmediatePatientAccountSave);
<span class="nc" id="L468">                } catch (Exception e) {</span>
                    //noinspection ThrowCaughtLocally
<span class="nc" id="L470">                    throw new RuntimeException(&quot;Exception while saving the message for composer&quot;, e);</span>
<span class="fc" id="L471">                }</span>
            }

            // If the message is in draft then do not save it to any participants
            // including new ones
<span class="fc bfc" id="L476" title="All 2 branches covered.">            if (!joinMessage.isDraft()) {</span>

                // This list will have join message too
<span class="fc" id="L479">                List&lt;Message&gt; messages = getMessages(loggedInEHRRequestContext.withoutAccessLog(), existingConversationAccountId, 0/*ALL*/, 0,</span>
<span class="fc" id="L480">                        conversation.getEncounterUniqueId());</span>

<span class="fc" id="L482">                Map&lt;String, PKBPerson&gt; personMap = userManager.getPKBPersonMap(newParticipants,</span>
                        PKBPerson.Lazy.CONTACTS);
<span class="fc" id="L484">                Map&lt;Long, Long&gt; newParticipantAccountIds = userManager.getDefaultAccountId(newParticipants.stream().map(Long::parseLong).collect(Collectors.toSet()));</span>

                // Only copy DPL encrypted docs in advance, as the rest will take a long time (we'll do those in the background thread)
<span class="fc" id="L487">                DocumentsByIdAndAccount documentIdMap = copyAllDocumentsInMessages(loggedInEHRRequestContext, messages, Set.copyOf(newParticipantAccountIds.values()), true);</span>

                AddParticipantThreadDTO participantThreadDTO;
<span class="fc bfc" id="L490" title="All 2 branches covered.">                for (String newParticipant : newParticipants) {</span>
<span class="fc" id="L491">                    long newParticipantId = parseLong(newParticipant);</span>
<span class="fc" id="L492">                    participantThreadDTO = new AddParticipantThreadDTO();</span>
<span class="fc" id="L493">                    participantThreadDTO.setMessageViaClone(joinMessage);</span>
<span class="fc" id="L494">                    participantThreadDTO.setComposer(inviterPerson);</span>
<span class="fc" id="L495">                    participantThreadDTO.setReferredPatient(patientReferredTo);</span>
<span class="fc" id="L496">                    participantThreadDTO.setReceiver(personMap.get(newParticipant));</span>
<span class="fc" id="L497">                    participantThreadDTO.setSenderMessageId(senderMessageId);</span>
<span class="fc" id="L498">                    participantThreadDTO.setInviterId(inviterId);</span>
<span class="fc" id="L499">                    participantThreadDTO.setInviterAccountId(existingConversationAccountId);</span>
<span class="fc" id="L500">                    participantThreadDTO.setNewUserId(newParticipantId);</span>
<span class="fc" id="L501">                    participantThreadDTO.setNewUserAccountId(newParticipantAccountIds.get(newParticipantId));</span>
<span class="fc" id="L502">                    participantThreadDTO.setMessageListViaClone(messages);</span>
<span class="fc" id="L503">                    participantThreadDTO.setDocumentIdMap(documentIdMap);</span>

<span class="fc" id="L505">                    AddParticipantThreadDTO finalThreadDTO = participantThreadDTO;</span>
<span class="fc" id="L506">                    taskExecutor.execute(new AddParticipantTask(loggedInEHRRequestContext, this, messagingManager, finalThreadDTO));</span>
<span class="fc" id="L507">                }</span>
            }
<span class="fc" id="L509">            return senderMessageId;</span>
<span class="nc" id="L510">        } catch (Exception exception) {</span>
<span class="nc" id="L511">            throw new RuntimeException(&quot;Error while adding participants to conversationId-&quot;</span>
<span class="nc" id="L512">                    + joinMessage.getEncounterUniqueId(), exception);</span>
        }
    }


    /**
     * Work out the full set of participants (based on last non draft + additions) and set on the message
     * &lt;p&gt;
     * Returns the new participants that are being added after taking into account:
     * - any existing participants from the last non-draft message
     * - funky edge cases
     */
    @NotNull
    private List&lt;String&gt; calculateAndSetParticipants(LoggedInEHRRequestContext loggedInEHRRequestContext, Message joinMessage, List&lt;String&gt; addedParticipants, long existingConversationAccountId, Encounter conversation) {
<span class="fc" id="L526">        Set&lt;String&gt; futureParticipantsSet = new HashSet&lt;&gt;();</span>
<span class="fc" id="L527">        Set&lt;String&gt; existingParticipantsSet = new HashSet&lt;&gt;();</span>

<span class="fc" id="L529">        String inviterIdString = joinMessage.getSenderId();</span>
<span class="fc" id="L530">        long inviterId = parseLong(inviterIdString);</span>

<span class="fc" id="L532">        Message lastNonDraftMessage = getLastNonDraftMessage(loggedInEHRRequestContext, inviterId, existingConversationAccountId, conversation);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (lastNonDraftMessage != null) {</span>
<span class="fc" id="L534">            existingParticipantsSet.addAll(lastNonDraftMessage.getParticipants());</span>
<span class="fc" id="L535">            futureParticipantsSet.addAll(existingParticipantsSet);</span>

<span class="pc bpc" id="L537" title="1 of 2 branches missed.">            if (futureParticipantsSet.isEmpty()) {</span>
                //not sure why this is here :-(, I suspect some partial initialization
                //for very old messages where participants weren't correctly configured? (Nothing hits this in e2es)
<span class="nc" id="L540">                futureParticipantsSet.add(lastNonDraftMessage.getSenderId());</span>
<span class="nc" id="L541">                futureParticipantsSet.add(lastNonDraftMessage.getReceiverId());</span>
            }
        } else {
<span class="fc" id="L544">            handleAddContactsToDraftConversation(joinMessage, inviterIdString, futureParticipantsSet, existingParticipantsSet);</span>
        }

        // sender is joining the conversations so sender is new participant
<span class="fc bfc" id="L548" title="All 4 branches covered.">        if (!futureParticipantsSet.contains(inviterIdString) &amp;&amp; !addedParticipants.contains(inviterIdString)) {</span>
<span class="fc" id="L549">            addedParticipants.add(inviterIdString);</span>
        }

<span class="fc" id="L552">        futureParticipantsSet.addAll(addedParticipants);</span>
<span class="fc" id="L553">        Set&lt;String&gt; newParticipantsSet = new HashSet&lt;&gt;(futureParticipantsSet);</span>
<span class="fc" id="L554">        newParticipantsSet.removeAll(existingParticipantsSet);</span>

<span class="fc" id="L556">        joinMessage.setParticipants(new ArrayList&lt;&gt;(futureParticipantsSet));</span>
<span class="fc" id="L557">        return new ArrayList&lt;&gt;(newParticipantsSet);</span>
    }

    /**
     * The sender doesn't always have full access to a conversation in their own account
     * Prefer the patient's copy if you can, but for pro-pro messages that's not possible or necessary.
     */
    private long getBestExistingConversationAccountId(Message message, Long contextUserId) {
<span class="fc" id="L565">        long senderId = parseLong(message.getSenderId());</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">        if (contextUserId != null) {</span>
            // User is replying to a message from within context.
            // The user may be a full participant, they may just be joining (with no copies of messages themself) / re-joining (with partial history)
            // Existing messages should be fetched from the patient's account as the patient should always have all of the messages.
<span class="fc" id="L570">            return userManager.getDefaultAccountId(contextUserId);</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        } else if (StringUtils.isNotEmpty(message.getPatientId())</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                &amp;&amp; senderId != parseLong(message.getPatientId())) {</span>
            // User is not in patient context, but the message is about a patient
            // The user may be a full participant, they may just be joining (with no copies of messages themself) / re-joining (with partial history)
            // Existing messages should be fetched from the patient's account as the patient should always have all of the messages.
<span class="fc" id="L576">            return userManager.getDefaultAccountId(parseLong(message.getPatientId()));</span>
        }

<span class="fc" id="L579">        return userManager.getDefaultAccountId(senderId);</span>
    }

    /**
     * Special case :-(
     * We're adding contacts to a draft message in a draft conversation (e.g. by autosaving on compose and re-opening from the inbox)
     * To remove this code, make draft messages in draft conversations open with the compose page rather than reply action (which is just asking for trouble)
     */
    private void handleAddContactsToDraftConversation(Message joinMessage, String senderIdString, Set&lt;String&gt; futureParticipantsSet, Set&lt;String&gt; existingParticipantsSet) {

        // because we don't have the base participants to copy over, we need to make sure we include the patient as a recipient because the add contact
        // selector isn't designed to add patients to a conversation, it's designed to add participants to an existing message. This covers a pro
        // composing a messaging to a patient, autosaving, and then adding a contact to the draft message
<span class="fc" id="L592">        String patientId = joinMessage.getPatientId();</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(patientId)) {</span>
<span class="fc" id="L594">            futureParticipantsSet.add(patientId);</span>
        }

        // because we don't have the base participants to copy over, we need to make sure the sender is
        //  1. included in the set of participants, but
        //  2. considered an 'existing' participant
        // because ideally we don't want them to get two copies of this message (the join message is already destined for the senders account)
<span class="fc" id="L601">        futureParticipantsSet.add(senderIdString);</span>
<span class="fc" id="L602">        existingParticipantsSet.add(senderIdString);</span>
<span class="fc" id="L603">    }</span>

    @Nullable
    public Message getLastNonDraftMessage(LoggedInEHRRequestContext loggedInEHRRequestContext, long inviterId, long contextAccountId, Encounter conversation) {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (conversation == null) {</span>
<span class="nc" id="L608">            return null;</span>
        }

<span class="fc" id="L611">        Message potentialLastNonDraftMessage = conversation.getLatestMessage();</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">        if (potentialLastNonDraftMessage.isDraft()) {</span>
<span class="fc" id="L613">            return getLastMessageOnConversationExcludeDraft(loggedInEHRRequestContext, &quot;&quot; + inviterId, contextAccountId,</span>
<span class="fc" id="L614">                    conversation.getEncounterUniqueId());</span>
        }
<span class="fc" id="L616">        return potentialLastNonDraftMessage;</span>
    }

    /**
     * message source populated from requestContext
     */
    public void removeParticipant(LoggedInEHRRequestContext loggedInEHRRequestContext, Long loggedInUserId, Long loggedInAccountId,
                                  UUID conversationId, Long exParticipantUserId, long exParticipantAccountId, String leavingMessageText) {
        try {
<span class="fc" id="L625">            transactional(() -&gt; {</span>
<span class="fc" id="L626">                Encounter conversation = Optional.ofNullable(getConversation(loggedInEHRRequestContext,</span>
                                conversationId,
                                loggedInUserId,
                                loggedInAccountId))
<span class="pc" id="L630">                        .orElseThrow(() -&gt; new IllegalStateException(&quot;Unable to get conversation id=&quot; + conversationId));</span>
<span class="fc" id="L631">                codeManager.populateCodes(Collections.singletonList(conversation));</span>
<span class="fc" id="L632">                Message lastMessage = conversation.getLatestMessage();</span>
<span class="fc" id="L633">                List&lt;String&gt; participants = lastMessage.getParticipants();</span>
<span class="fc" id="L634">                participants.remove(exParticipantUserId.toString());</span>

<span class="fc" id="L636">                Message leavingMessage = createMessage(lastMessage.getPatientId(),</span>
                        conversationId,
                        false,
<span class="fc" id="L639">                        exParticipantUserId.toString(),</span>
<span class="fc" id="L640">                        lastMessage.getSubject(),</span>
                        leavingMessageText,
                        PrivacyFlag.GENERAL,
                        loggedInEHRRequestContext);

                //No more mutating the participants now please.
<span class="fc" id="L646">                participants = ImmutableList.copyOf(participants);</span>
<span class="fc" id="L647">                leavingMessage.setParticipants(participants);</span>

<span class="fc" id="L649">                saveSingleMessage(loggedInEHRRequestContext, exParticipantUserId.toString(), exParticipantAccountId, leavingMessage, null);</span>

<span class="fc" id="L651">                saveMessage(loggedInEHRRequestContext, leavingMessage, null);</span>

<span class="fc" id="L653">                trustedConversationWorkflowService.forceUnassignConversationFromPersonId(conversation.getEncounterUniqueId(), loggedInUserId, loggedInUserId);</span>
<span class="fc" id="L654">            });</span>
<span class="nc" id="L655">        } catch (Exception exception) {</span>
<span class="nc" id="L656">            throw new RuntimeException(&quot;Error while removing participantId-&quot; + exParticipantUserId + &quot; from conversationId-&quot; + conversationId, exception);</span>
<span class="fc" id="L657">        }</span>
<span class="fc" id="L658">    }</span>

    public String getMessageTemplate(String templateName) {
<span class="fc" id="L661">        StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L662">        try (InputStreamReader inputStreamReader = new InputStreamReader(this.getClass()</span>
<span class="fc" id="L663">                .getResourceAsStream(&quot;/templates/messages/&quot; + templateName + &quot;.txt&quot;))) {</span>
<span class="fc" id="L664">            char[] buffer = new char[4096];</span>
            int charsRead;
<span class="fc bfc" id="L666" title="All 2 branches covered.">            while ((charsRead = inputStreamReader.read(buffer)) &gt; 0) {</span>
<span class="fc" id="L667">                result.append(buffer, 0, charsRead);</span>
            }
<span class="nc" id="L669">        } catch (Exception exception) {</span>
<span class="nc" id="L670">            throw new RuntimeException(&quot;Error while fetching message template &quot;</span>
                    + templateName, exception);
<span class="fc" id="L672">        }</span>
<span class="fc" id="L673">        return result.toString();</span>
    }

    public List&lt;Message&gt; getMessages(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext,
                                     long accountId, int pageSize, int offset, UUID conversationId,
                                     @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {
        try {
<span class="fc" id="L680">            doSyncUploadedData(loggedInEHRRequestContext, accountId);</span>
            // Expand out inline contents of message
<span class="fc" id="L682">            var messages = getMessages(loggedInEHRRequestContext, accountId, pageSize, offset, conversationId);</span>
<span class="fc" id="L683">            translate(i18nMethod, messages);</span>
<span class="fc" id="L684">            return messages;</span>
<span class="nc" id="L685">        } catch (Exception e) {</span>
<span class="nc" id="L686">            throw new RuntimeException(&quot;Error while getting the message for account-&quot; + accountId, e);</span>
        }
    }

    public List&lt;Attachment&gt; getAttachments(Long messageId) {
<span class="fc" id="L691">        return chunkedDocManager.findAttachmentsAsAttachment(messageId);</span>
    }

    public Map&lt;Long, List&lt;Attachment&gt;&gt; getAttachments(Collection&lt;Long&gt; messageIds) {
<span class="fc" id="L695">        return chunkedDocManager.findAttachmentsAsAttachment(messageIds);</span>
    }

    public List&lt;ActivityDTO&gt; getActivityListAsActivities(LoggedInEHRRequestContext loggedInEHRRequestContext, long userId,
                                                         long accountId, int pageSize, int offset, @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {

        try {
<span class="fc" id="L702">            doSyncUploadedData(loggedInEHRRequestContext, accountId);</span>
<span class="fc" id="L703">            var activityList = getActivityList(loggedInEHRRequestContext, userId, accountId, pageSize, offset);</span>
<span class="fc" id="L704">            translate(i18nMethod, activityList.stream()</span>
<span class="fc" id="L705">                    .filter(activity -&gt; activity instanceof Message)</span>
<span class="fc" id="L706">                    .map(activity -&gt; (Message) activity)</span>
<span class="fc" id="L707">                    .collect(Collectors.toList()));</span>
<span class="fc" id="L708">            return getActivityListAsActivities(loggedInEHRRequestContext, activityList);</span>
<span class="nc" id="L709">        } catch (Exception e) {</span>
<span class="nc" id="L710">            throw new RuntimeException(&quot;Exception while getting conversation list for user -&quot; + userId, e);</span>
        }
    }

    public List&lt;InboxConversationDTO&gt; getConversationListForInbox(LoggedInEHRRequestContext loggedInEHRRequestContext, long currentPersonId,
                                                                  long accountId, int pageSize, int offset, String filterPatientId, Instant filterFromDate,
                                                                  Instant filterToDate, ConversationWorkflowFilterDTO conversationWorkflowFilterDTO,
                                                                  @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {
        try {
<span class="fc" id="L719">            List&lt;InboxConversationDTO&gt; inboxConversationDTOList = getConversationListForInbox(loggedInEHRRequestContext, accountId,</span>
                    pageSize, offset, filterPatientId, filterFromDate, filterToDate, conversationWorkflowFilterDTO);
<span class="fc" id="L721">            inboxConversationDTOList.forEach(dto -&gt; translate(i18nMethod, Collections.singletonList(dto.getLatestMessage())));</span>
<span class="fc" id="L722">            addConversationWorkflowData(inboxConversationDTOList, conversationWorkflowFilterDTO);</span>

<span class="fc" id="L724">            return inboxConversationDTOList;</span>
<span class="nc" id="L725">        } catch (Exception e) {</span>
<span class="nc" id="L726">            throw new RuntimeException(&quot;Exception while getting inbox conversation list for &quot; + currentPersonId + &quot;/&quot; + accountId, e);</span>
        }
    }

    private void addConversationWorkflowData(List&lt;InboxConversationDTO&gt; dtoList, ConversationWorkflowFilterDTO conversationWorkflowFilterDTO) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (conversationWorkflowFilterDTO.isWorkflowEnabled()) {</span>
<span class="fc" id="L732">            Set&lt;UUID&gt; conversationIds = dtoList.stream().map(InboxConversationDTO::getConversationId).collect(Collectors.toSet());</span>
<span class="fc" id="L733">            Map&lt;UUID, ConversationWorkflowExisting&gt; conversationWorkflowByConversationId = trustedConversationWorkflowService.findConversationWorkflows(conversationIds,</span>
<span class="fc" id="L734">                    conversationWorkflowFilterDTO.teamId());</span>

<span class="fc" id="L736">            Set&lt;Long&gt; assignedPersonIds = conversationWorkflowConverter.getAllAssignedPersonIds(conversationWorkflowByConversationId);</span>
<span class="fc" id="L737">            var personsByIdMap = userManager.getPKBPersonMapById(assignedPersonIds);</span>
<span class="fc" id="L738">            var conversationWorkflowsDTOs = conversationWorkflowConverter.convertToDTOs(conversationWorkflowByConversationId, personsByIdMap);</span>
<span class="fc" id="L739">            dtoList.forEach(dto -&gt; dto.setConversationWorkflow(conversationWorkflowsDTOs.get(dto.getConversationId())));</span>
        }
<span class="fc" id="L741">    }</span>

    public List&lt;ApiConversationDTO&gt; getConversationListForApi(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext, Long currentPersonId,
                                                              Long accountId, Instant fromDateOrNull, Instant toDateOrNull, int pageSize, int offset,
                                                              boolean orderNewestFirst, @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {
        try {
<span class="fc" id="L747">            doSyncUploadedData(loggedInEHRRequestContext, accountId);</span>
<span class="fc" id="L748">            var conversationList = getConversationListForApi(loggedInEHRRequestContext, currentPersonId,</span>
                    accountId, orderNewestFirst, fromDateOrNull, toDateOrNull, pageSize, offset);
<span class="fc" id="L750">            conversationList.forEach(conversation -&gt; translate(i18nMethod, conversation.getMessages()));</span>
<span class="fc" id="L751">            return conversationList;</span>
<span class="nc" id="L752">        } catch (Exception e) {</span>
<span class="nc" id="L753">            throw new RuntimeException(&quot;Exception while getting inbox conversation list for &quot; + currentPersonId + &quot;/&quot; + accountId, e);</span>
        }
    }

    public Optional&lt;Encounter&gt; getOptionalConversation(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext, UUID conversationId, long userId, long accountId) {

        try {
<span class="fc" id="L760">            var conversation = Optional.ofNullable(getConversation(loggedInEHRRequestContext,</span>
                    conversationId,
<span class="fc" id="L762">                    userId,</span>
<span class="fc" id="L763">                    accountId));</span>
<span class="fc" id="L764">            conversation.ifPresent(encounter -&gt; codeManager.populateCodes(Collections.singletonList(encounter)));</span>
<span class="fc" id="L765">            return conversation;</span>
<span class="nc" id="L766">        } catch (Exception e) {</span>
<span class="nc" id="L767">            throw new RuntimeException(&quot;Exception while getting conversation for id-&quot; + conversationId, e);</span>
        }
    }

    public Attachment getAttachmentContent(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext, Long attachmentId) {
        try {
<span class="fc" id="L773">            return attachmentManager.getAttachmentContent(loggedInEHRRequestContext, attachmentId);</span>
<span class="nc" id="L774">        } catch (Exception exception) {</span>
<span class="nc" id="L775">            throw new RuntimeException(&quot;Exception while getting contents for attachment-&quot; + attachmentId, exception);</span>
        }
    }

    /**
     * Message source populated from requestContext
     */
    public void handoverConversation(LoggedInEHRRequestContext loggedInEHRRequestContext, UUID conversationId,
                                     String referralText, Long oldUserId, Long oldUserAccountId,
                                     Long newUserId, Long newUserAccountId, Long otherUserId) {
        try {
<span class="fc" id="L786">            String strOldUserId = oldUserId.toString();</span>
<span class="fc" id="L787">            String strNewUserId = newUserId.toString();</span>

<span class="fc" id="L789">            transactional(() -&gt; {</span>
<span class="fc" id="L790">                Encounter conversation = Optional.ofNullable(getConversation(loggedInEHRRequestContext,</span>
                                conversationId,
                                oldUserId,
                                oldUserAccountId))
<span class="pc" id="L794">                        .orElseThrow(() -&gt; new IllegalStateException(&quot;Unable to get conversation id=&quot; + conversationId));</span>
<span class="fc" id="L795">                codeManager.populateCodes(Collections.singletonList(conversation));</span>
<span class="fc" id="L796">                Message lastMessage = conversation.getLatestMessage();</span>

<span class="fc" id="L798">                List&lt;Message&gt; messages = getMessages(loggedInEHRRequestContext,</span>
<span class="fc" id="L799">                        oldUserAccountId, conversation.getMessageCount().intValue(), 0,</span>
<span class="fc" id="L800">                        conversation.getEncounterUniqueId());</span>

<span class="fc" id="L802">                DocumentsByIdAndAccount documentIdMap = copyAllDocumentsInMessages(loggedInEHRRequestContext, messages, singleton(newUserAccountId), false);</span>
<span class="fc" id="L803">                copyConversationToNewParticipant(loggedInEHRRequestContext, oldUserId, oldUserAccountId, newUserId, newUserAccountId, messages, documentIdMap);</span>

<span class="fc" id="L805">                List&lt;String&gt; participants = lastMessage.getParticipants();</span>
<span class="fc" id="L806">                participants.remove(strOldUserId);</span>
<span class="fc" id="L807">                participants.add(strNewUserId);</span>

<span class="fc" id="L809">                Message referralMessage = createMessage(lastMessage.getPatientId(),</span>
                        conversationId,
                        false,
                        strOldUserId,
<span class="fc" id="L813">                        lastMessage.getSubject(),</span>
                        referralText,
                        PrivacyFlag.GENERAL,
                        loggedInEHRRequestContext);

                //No more mutating the participants now please.
<span class="fc" id="L819">                participants = ImmutableList.copyOf(participants);</span>
<span class="fc" id="L820">                referralMessage.setParticipants(participants);</span>

<span class="fc" id="L822">                saveSingleMessage(loggedInEHRRequestContext, strOldUserId, oldUserAccountId, referralMessage, null);</span>
<span class="fc" id="L823">                saveMessage(loggedInEHRRequestContext, referralMessage, null);</span>

<span class="fc" id="L825">                Map&lt;Long, PKBPerson&gt; personsById = userManager.getPKBPersonMapById(List.of(oldUserId, newUserId, otherUserId));</span>
<span class="fc" id="L826">                PKBPerson oldPerson = personsById.get(oldUserId);</span>
<span class="fc" id="L827">                PKBPerson newPerson = personsById.get(newUserId);</span>
<span class="fc" id="L828">                PKBPerson otherPerson = personsById.get(otherUserId);</span>

<span class="fc" id="L830">                trustedConversationWorkflowService.forceUnassignConversationFromPersonId(conversationId, oldUserId, oldUserId);</span>

                //for now we'll assume that the consent level of the last message is a reasonable basis for the consent level of the conversation:
<span class="fc" id="L833">                messagingManager.sendDiscussionHandoverNotificationToNewPerson(</span>
<span class="fc" id="L834">                        oldPerson, newPerson, conversationId, lastMessage, loggedInEHRRequestContext.getTeamId());</span>
<span class="fc" id="L835">                messagingManager.sendDiscussionHandoverNotificationToOtherPerson(</span>
<span class="fc" id="L836">                        oldPerson, newPerson, otherPerson, conversationId, lastMessage, loggedInEHRRequestContext.getTeamId());</span>
<span class="fc" id="L837">            });</span>
<span class="nc" id="L838">        } catch (Exception exception) {</span>
<span class="nc" id="L839">            throw new RuntimeException(&quot;Exception while getting handing over conversation-&quot; + conversationId, exception);</span>
<span class="fc" id="L840">        }</span>
<span class="fc" id="L841">    }</span>

    @VisibleForTesting
    @NotNull
    DocumentsByIdAndAccount copyAllDocumentsInMessages(LoggedInEHRRequestContext loggedInEHRRequestContext, List&lt;Message&gt; messages, Set&lt;Long&gt; newAccountIds, boolean onlyDplEncrypted) {
<span class="fc" id="L846">        List&lt;UUID&gt; originalDocumentIds = chunkedDocManager.getAttachedDocumentIds(messages.stream().map(Message::getId).collect(Collectors.toList()));</span>

<span class="fc" id="L848">        DocumentsByIdAndAccount documentIdMap = Metrics.timer(DOCUMENT_TIMER_NAME)</span>
<span class="fc" id="L849">                .record(() -&gt; chunkedDocManager.copyDocuments(loggedInEHRRequestContext, originalDocumentIds,</span>
<span class="fc" id="L850">                        loggedInEHRRequestContext.getAccessingUserId(), newAccountIds, onlyDplEncrypted));</span>

<span class="fc" id="L852">        return documentIdMap;</span>
    }

    void copyConversationToNewParticipant(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext, long oldUserId, long oldUserAccountId,
                                          long newUserId, Long newUserAccountId, List&lt;Message&gt; messages, DocumentsByIdAndAccount documentIdMap) {

        try {
<span class="fc bfc" id="L859" title="All 2 branches covered.">            for (Message message : messages) {</span>
                // If the some message was in draft within conversation
                // don't copy it to new participant
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">                if ((message.getMessageStatus() != null)</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">                        &amp;&amp; message.getMessageStatus() == MessageStatus.INDRAFT) {</span>
<span class="nc" id="L864">                    continue;</span>
                }

                //Copy any referenced objects

<span class="fc" id="L869">                Matcher tagMatcher = planPattern.matcher(message.getContent());</span>

<span class="pc bpc" id="L871" title="1 of 2 branches missed.">                while (tagMatcher.find()) {</span>
<span class="nc" id="L872">                    String tag = tagMatcher.group();</span>
<span class="nc" id="L873">                    UUID planUniqueId = UUID.fromString(tag.substring(6, tag.length() - 1));</span>

<span class="nc" id="L875">                    PHPlan pHPlan = planManager.getPHPlanForAccountId(planUniqueId, loggedInEHRRequestContext, oldUserAccountId, false/*includeDeleted*/);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                    if (!planManager.userHasPlan(loggedInEHRRequestContext, newUserId, planUniqueId)) {</span>
<span class="nc" id="L877">                        Long oldPlanId = pHPlan.getId();</span>
<span class="nc" id="L878">                        pHPlan.setId(null); // So that plan is saved as a fresh copy</span>
                        // Re-escape any html
<span class="nc bnc" id="L880" title="All 2 branches missed.">                        for (PlanField planField : pHPlan.getPlanFields()) {</span>
<span class="nc" id="L881">                            planField.setText(StringEscapeUtils.escapeHtml4(planField.getText()));</span>
<span class="nc" id="L882">                        }</span>
<span class="nc" id="L883">                        Long newPlanId = planManager.savePHPlan(loggedInEHRRequestContext, newUserAccountId, pHPlan);</span>

<span class="nc" id="L885">                        planManager.copyAttachments(loggedInEHRRequestContext, oldUserId, oldPlanId, newUserId, newPlanId);</span>
                    }

<span class="nc" id="L888">                }</span>

<span class="fc" id="L890">                Message messageCopy = getMessageCopy(message, Long.toString(newUserId), MessageStatus.UNREAD);</span>

                // Copy the message itself
<span class="fc" id="L893">                List&lt;Attachment&gt; attachments = getAttachments(message.getId());</span>
<span class="fc" id="L894">                Metrics.timer(MESSAGE_TIMER_NAME).record(() -&gt;</span>
<span class="fc" id="L895">                        copyMessage(loggedInEHRRequestContext, newUserId, newUserAccountId, messageCopy, attachments, documentIdMap));</span>
<span class="fc" id="L896">            } // end for</span>
<span class="nc" id="L897">        } catch (Exception e) {</span>
<span class="nc" id="L898">            throw new RuntimeException(&quot;Exception while copying the message to new participant-&quot; + newUserId, e);</span>
<span class="fc" id="L899">        }</span>
<span class="fc" id="L900">    }</span>
    
    private final class MessageDetailsWithinContext {
        private final MessageDetailsAndContent messageDetailsAndContent;
        private final LoggedOutEHRRequestContext loggedOutEHRRequestContext;
        
<span class="fc" id="L906">        MessageDetailsWithinContext(MessageDetailsAndContent messageDetailsAndContent, LoggedOutEHRRequestContext loggedOutEHRRequestContext) {</span>
<span class="fc" id="L907">            this.messageDetailsAndContent = messageDetailsAndContent;</span>
<span class="fc" id="L908">            this.loggedOutEHRRequestContext = loggedOutEHRRequestContext;</span>
<span class="fc" id="L909">        }</span>

        MessageDetailsAndContent getMessageDetailsAndContent() {
<span class="fc" id="L912">            return messageDetailsAndContent;</span>
        }

        LoggedOutEHRRequestContext getLoggedOutEHRRequestContext() {
<span class="fc" id="L916">            return loggedOutEHRRequestContext;</span>
        }
    }
    
    /**
     * Source populated from requestContext
     */
    public List&lt;Either&lt;MessageServiceException, MessageDetails&gt;&gt; saveMessagesFromLoggedOutContext(List&lt;MessageDetailsAndContent&gt; messageDetailsList) {

<span class="fc" id="L925">        Set&lt;UUID&gt; teamUUIDs = messageDetailsList.stream().map(</span>
<span class="fc" id="L926">                        messageDetailsAndContent -&gt; messageDetailsAndContent.getMessageDetails().getMetadata().getSource().getTeamId())</span>
<span class="fc" id="L927">                .map(UUID::fromString).collect(toSet());</span>

<span class="fc" id="L929">        Map&lt;UUID, Team&gt; teamsByPublicId = teamManager.getTeamsByPublicIds(teamUUIDs).stream()</span>
<span class="fc" id="L930">                .collect(Collectors.toMap(Team::getPublicId, team -&gt; team));</span>

<span class="fc" id="L932">        var messageDetailsContentAndContext = messageDetailsList.stream().map(</span>
                messageDetailsAndContent -&gt; {
<span class="fc" id="L934">                    String idString = messageDetailsAndContent.getMessageDetails().getMetadata().getSource().getTeamId();</span>
<span class="fc" id="L935">                    return Option.of(teamsByPublicId.get(UUID.fromString(idString)))</span>
<span class="fc" id="L936">                            .toEither(new TeamNotFoundException(idString, messageDetailsAndContent.getMessageDetails()))</span>
<span class="fc" id="L937">                            .map(team -&gt; new MessageDetailsWithinContext(</span>
                                messageDetailsAndContent,
<span class="fc" id="L939">                                ImmutableLoggedOutEHRRequestContext.builder()</span>
<span class="fc" id="L940">                                        .org(team.getOrg())</span>
<span class="fc" id="L941">                                        .teamId(team.getId())</span>
<span class="fc" id="L942">                                        .accountLinkType(EHRRequestContext.AccountLinkType.INDIVIDUAL)</span>
<span class="fc" id="L943">                                        .accessRoute(Route.FHIR_API)</span>
<span class="fc" id="L944">                                        .consentStatus(ConsentStatus.noConsentRequired())</span>
<span class="fc" id="L945">                                        .correlationId(correlationIdUtil.getOrDefault())</span>
<span class="fc" id="L946">                                        .build()));</span>
<span class="fc" id="L947">                }).collect(toList());</span>

<span class="fc" id="L949">        return ListTransform.transformByPredicateAndReturnInSameOrder(messageDetailsContentAndContext, Either::isRight,</span>
<span class="fc" id="L950">                rights -&gt; saveMessagesNoAttachment(rights.stream().map(Either::get).collect(Collectors.toList())),</span>
<span class="nc" id="L951">                lefts -&gt; lefts.stream().map(l -&gt; Either.&lt;MessageServiceException, MessageDetails&gt;left(l.getLeft())).collect(Collectors.toList()));</span>
    }

    /*
     * Does not support draft messages or attachments
     */
    private List&lt;Either&lt;MessageServiceException, MessageDetails&gt;&gt; saveMessagesNoAttachment(List&lt;MessageDetailsWithinContext&gt; messageDetailsWithinContextList) {
<span class="fc" id="L958">        Set&lt;UUID&gt; publicIdsToFetch = new HashSet&lt;&gt;();</span>
<span class="fc" id="L959">        Map&lt;MessageMetaData, List&lt;UUID&gt;&gt; participantsByMetadata = new HashMap&lt;&gt;();</span>
<span class="fc" id="L960">        messageDetailsWithinContextList.forEach(</span>
                messageDetailsWithinContext -&gt; {
<span class="fc" id="L962">                    var metadata = messageDetailsWithinContext.getMessageDetailsAndContent().getMessageDetails().getMetadata();</span>
<span class="fc" id="L963">                    var participants = metadata.getParticipantIdList().stream().map(UUID::fromString).collect(toList());</span>
<span class="fc" id="L964">                    participantsByMetadata.put(metadata, participants);</span>
<span class="fc" id="L965">                    publicIdsToFetch.addAll(Stream.concat(participants.stream(), Stream.of(</span>
<span class="fc" id="L966">                            UUID.fromString(metadata.getPatientId()),</span>
<span class="fc" id="L967">                            UUID.fromString(metadata.getSenderId()))).collect(toSet()));</span>
<span class="fc" id="L968">                });</span>

<span class="fc" id="L970">        Map&lt;UUID, Long&gt; personPublicIdToIdMap = userManager.getPersonIdsByPublicIds(publicIdsToFetch);</span>
<span class="fc" id="L971">        Map&lt;UUID, Pair&lt;Message, EHRRequestContext&gt;&gt; conversationIdToMessageAndContextMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L973">        List&lt;Either&lt;MessageServiceException, Pair&lt;MessageDetailsWithinContext, Message&gt;&gt;&gt; messages = messageDetailsWithinContextList.stream().map(</span>
                messageDetailsWithinContext -&gt; {
<span class="fc" id="L975">                    var messageMetaData = messageDetailsWithinContext.getMessageDetailsAndContent().getMessageDetails().getMetadata();</span>
<span class="fc" id="L976">                    var participants = participantsByMetadata.get(messageMetaData);</span>
<span class="fc" id="L977">                    var patientId = UUID.fromString(messageMetaData.getPatientId());</span>
<span class="fc" id="L978">                    var senderId = UUID.fromString(messageMetaData.getSenderId());</span>
<span class="fc" id="L979">                    var personUUIDs = Stream.concat(participants.stream(), Stream.of(patientId, senderId)).collect(toSet());</span>

<span class="fc" id="L981">                    Optional&lt;String&gt; maybeIssue = getOptionalIssueFromMissingValueInMap(personUUIDs, personPublicIdToIdMap, &quot;person&quot;);</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">                    if (maybeIssue.isEmpty()){</span>
<span class="fc" id="L983">                        var message = createMessage(Long.toString(personPublicIdToIdMap.get(patientId)),</span>
<span class="fc" id="L984">                                UUID.fromString(messageMetaData.getConversationId()),</span>
<span class="fc" id="L985">                                messageMetaData.getIsFirst(),</span>
<span class="fc" id="L986">                                Long.toString(personPublicIdToIdMap.get(senderId)),</span>
<span class="fc" id="L987">                                messageMetaData.getSubject(),</span>
<span class="fc" id="L988">                                messageDetailsWithinContext.getMessageDetailsAndContent().getContent(),</span>
<span class="fc" id="L989">                                MessageMetaDataPrivacyFlagConverter.toPrivacyFlag(messageMetaData.getPrivacyFlag()),</span>
<span class="fc" id="L990">                                messageDetailsWithinContext.getLoggedOutEHRRequestContext());</span>
<span class="fc" id="L991">                        message.setParticipants(participants.stream().map(uuid -&gt; personPublicIdToIdMap.get(uuid).toString()).collect(Collectors.toList()));</span>
<span class="fc" id="L992">                        setUpMessageEncounterUniqueId(message);</span>

<span class="fc" id="L994">                        conversationIdToMessageAndContextMap.put(message.getEncounterUniqueId(), Pair.of(message, messageDetailsWithinContext.getLoggedOutEHRRequestContext()));</span>
<span class="fc" id="L995">                        return Either.&lt;MessageServiceException, Pair&lt;MessageDetailsWithinContext, Message&gt;&gt;</span>
<span class="fc" id="L996">                                right(Pair.of(messageDetailsWithinContext, message));</span>
                    } else {
<span class="nc" id="L998">                        return Either.&lt;MessageServiceException, Pair&lt;MessageDetailsWithinContext, Message&gt;&gt;</span>
<span class="nc" id="L999">                                left(new PersonNotFoundException(maybeIssue.get(), messageDetailsWithinContext.getMessageDetailsAndContent().getMessageDetails()));</span>
                    }
<span class="fc" id="L1001">                }).collect(toList());</span>

<span class="fc" id="L1003">        return transactional(() -&gt; {</span>
            
<span class="fc" id="L1005">            var resultList = ListTransform.transformByPredicateAndReturnInSameOrder(messages, Either::isRight,</span>
<span class="fc" id="L1006">                    rights -&gt; saveMessagesNoSupportForCopyingAttachmentsOrDrafts(rights.stream()</span>
<span class="fc" id="L1007">                            .map(Either::get)</span>
<span class="fc" id="L1008">                            .collect(Collectors.toList())),</span>
<span class="nc" id="L1009">                    lefts -&gt; lefts.stream().map(l -&gt; Either.&lt;MessageServiceException, MessageDetails&gt;left(l.getLeft())).collect(Collectors.toList()));</span>

            // save non-existing participants to the DB as well
<span class="fc" id="L1012">            resultList.forEach(</span>
<span class="fc" id="L1013">                    messageDetails -&gt; messageDetails.peek(details -&gt; {</span>
<span class="fc" id="L1014">                        UUID conversationId = UUID.fromString(details.getMetadata().getConversationId());</span>
<span class="fc" id="L1015">                        participantManager.saveParticipantsForMessage(conversationIdToMessageAndContextMap.get(conversationId));</span>
<span class="fc" id="L1016">                    }));</span>
            
<span class="fc" id="L1018">            return resultList;</span>
        });
    }

    public Message saveMessageNoAttachment(EHRRequestContext requestContext, long patientId, UUID conversationId, boolean isFirst,
            long senderId, String subject, String text, PrivacyFlag privacyFlag, List&lt;Long&gt; participants) {
        try {
<span class="fc" id="L1025">            Message message = createMessage(Long.toString(patientId), conversationId, isFirst, Long.toString(senderId), subject, text, privacyFlag, requestContext);</span>
<span class="fc" id="L1026">            message.setParticipants(participants.stream().map(l -&gt; Long.toString(l)).collect(Collectors.toList()));</span>
<span class="fc" id="L1027">            setUpMessageEncounterUniqueId(message);</span>

<span class="fc" id="L1029">            Long messageId = saveMessageNoSupportForCopyingAttachments(requestContext, message);</span>
<span class="fc" id="L1030">            participantManager.saveParticipantsForMessage(requestContext, message);</span>
<span class="fc" id="L1031">            message.setId(messageId);</span>
<span class="fc" id="L1032">            return message;</span>

<span class="nc" id="L1034">        } catch (Exception exception) {</span>
<span class="nc" id="L1035">            LOGGER.error(&quot;Unable to send message &quot;, exception);</span>
<span class="nc" id="L1036">            throw new RuntimeException(&quot;Unable to send message to user -&quot; + Long.toString(patientId), exception);</span>
        }
    }

    public Message patientSubmitsQuestionnaire(LoggedInEHRRequestContext requestContext, QuestionnaireRequest questionnaireRequest, PKBPerson patient,
                                               Long loggedInUserId, List&lt;String&gt; recipientIds, String questionnaireResponseContentMessage) {
<span class="fc" id="L1042">        UUID conversationId = questionnaireRequest.getId();</span>
<span class="fc" id="L1043">        Message message = createMessage(patient.getId().toString(), conversationId,</span>
                false,
<span class="fc" id="L1045">                loggedInUserId.toString(),</span>
<span class="fc" id="L1046">                questionnaireRequest.getQuestionnaire().getName(),</span>
                questionnaireResponseContentMessage,
                PrivacyFlag.GENERAL,
                requestContext);

<span class="fc" id="L1051">        message.setId(null);</span>
<span class="fc" id="L1052">        message.setHtmlAllowed(true);</span>
<span class="fc" id="L1053">        message.setOnBehalfAuthorId(null);</span>

<span class="fc" id="L1055">        Set&lt;String&gt; participantSet = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1056">        participantSet.add(loggedInUserId.toString());</span>
<span class="fc" id="L1057">        participantSet.add(patient.getId().toString());</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">        if (recipientIds != null) {</span>
<span class="fc" id="L1059">            participantSet.addAll(recipientIds);</span>
        }
<span class="fc" id="L1061">        participantSet.add(userManager.getPersonIdByPublicId(questionnaireRequest.getRequestorPersonId()).toString());</span>

<span class="fc" id="L1063">        message.setParticipants(new ArrayList&lt;&gt;(participantSet));</span>
<span class="fc" id="L1064">        message.initializeUniqueIds(false);</span>
<span class="fc" id="L1065">        return message;</span>
    }

    public @Nullable Message getFirstMessageInConversation(@NotNull LoggedInEHRRequestContext requestContext,
                                                           Long accountId, UUID conversationId) {
        try {
            // this should become two methods, or pass in the data type
<span class="fc" id="L1072">            EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);
<span class="fc" id="L1074">            ehrSearch.addFilter(new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.EQUAL,</span>
                    conversationId));

            // we need to exclude ENCOUNTER_DETAILS messages from this query because
            // these are system generated messages and not visible to the end user

<span class="fc" id="L1080">            ehrSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L1081">                    Message.MessageType.ENCOUNTER_DETAILS.toString()));</span>

<span class="fc" id="L1083">            ehrSearch.addFilter(new PKBFilter(&quot;deleted&quot;, PKBFilter.Operator.EQUAL, false, true/*applyWhenChoosingLatest*/));</span>

<span class="fc" id="L1085">            ehrSearch.setUseParticipantFilter();</span>
<span class="fc" id="L1086">            ehrSearch.setLatestPerTypeFilter(&quot;date01&quot;, &quot;uniqueId&quot;);</span>

<span class="fc" id="L1088">            ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Asc);</span>
<span class="fc" id="L1089">            ehrSearch.setResultsMaxReturned(1);</span>
<span class="fc" id="L1090">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>

<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">            if (ehrList.isEmpty()) {</span>
<span class="nc" id="L1093">                return null;</span>
            }

<span class="fc" id="L1096">            return populateMessage(requestContext, ehrList.get(0));</span>
<span class="nc" id="L1097">        } catch (Exception e) {</span>
<span class="nc" id="L1098">            throw new RuntimeException(</span>
                    &quot;Exception while getting first message in the conversation-&quot;
                            + conversationId,
                    e);
        }
    }

    private Optional&lt;Message&gt; getOptionalFirstMessageInConversation(LoggedInEHRRequestContext loggedInEHRRequestContext, Long accountId,
                                                                    UUID conversationId) {
<span class="fc" id="L1107">        Message message = getFirstMessageInConversation(</span>
                loggedInEHRRequestContext, accountId, conversationId);
<span class="fc" id="L1109">        return Optional.ofNullable(message);</span>
    }

    public boolean deleteDraftMessage(@NotNull EHRRequestContext requestContext, Long messageId, UUID conversationId) {
        try {
<span class="fc" id="L1114">            EHRData ehrData = beanFactory.getEhrRemote().findEHRData(messageId, requestContext);</span>
<span class="fc" id="L1115">            Message message = beanFactory.getEhrRemote().populateDTO(ehrData, Message.class, requestContext);</span>
<span class="fc" id="L1116">            boolean found = false;</span>

<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">            if (message != null) {</span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">                if ((message.getMessageStatus() == null)</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">                        || message.getMessageStatus() != MessageStatus.INDRAFT) {</span>
                    // Don't delete message if it isn't in draft
                    // which means Conversation list has wrong information about
                    // latest message
                    // Pravina : It can be corrected using uncommenting
                    // following call
                    // updateConversationListWithPrevMessage(userId,
                    // accountUser,
                    // messageId, allConversationsMS, conversationList);
<span class="nc" id="L1129">                    return false;</span>
                }

<span class="fc" id="L1132">                found = true;</span>
<span class="fc" id="L1133">                UUID documentId = ehrData.getDocumentMetadataId();</span>
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">                if (documentId != null) {</span>
                    // document should be deleted as well for old records
<span class="nc" id="L1136">                    documentManager.delete(documentId);</span>
                }
                // delete placeholder
<span class="fc" id="L1139">                beanFactory.getEhrRemote().removeEHRData(messageId);</span>
            }
<span class="fc" id="L1141">            return found;</span>

<span class="nc" id="L1143">        } catch (Exception e) {</span>
<span class="nc" id="L1144">            throw new RuntimeException(</span>
                    &quot;Error while deleting draft message for conversation id&quot;
                            + conversationId,
                    e);
        }
    }

    void logFailedDeliveryOfMessage(EHRRequestContext requestContext, Long messageId,
                                    UUID conversationId, UUID messageUniqueId, String senderId, SourceDetails messageSource, String failedReceiverId) {
        try {
<span class="nc" id="L1154">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong(senderId));</span>
<span class="nc" id="L1155">            FailedMessageDTO failedMessageDTO = new FailedMessageDTO();</span>
<span class="nc" id="L1156">            failedMessageDTO.setReceiverId(failedReceiverId);</span>
<span class="nc" id="L1157">            failedMessageDTO.setConversationId(conversationId);</span>
<span class="nc" id="L1158">            failedMessageDTO.setUniqueId(messageUniqueId);</span>
<span class="nc" id="L1159">            failedMessageDTO.setMessageId(messageId);</span>

<span class="nc" id="L1161">            EHRData ehrData = beanFactory.getEhrRemote().populateEHRData(failedMessageDTO, accountId, FailedMessageDTO.MS_PATH, requestContext);</span>
<span class="nc" id="L1162">            ehrData.setUniqueId(uuidProvider.randomUUID());</span>
<span class="nc" id="L1163">            messageSource.writeToEHRData(ehrData);</span>
<span class="nc" id="L1164">            beanFactory.getEhrRemote().saveEHRData(requestContext, ehrData);</span>
<span class="nc" id="L1165">        } catch (Exception e) {</span>
<span class="nc" id="L1166">            throw new RuntimeException(&quot;Error while updating message &quot;</span>
                    + messageId + &quot; with failed receivers&quot;, e);
<span class="nc" id="L1168">        }</span>
<span class="nc" id="L1169">    }</span>

    public PKBPerson getReferredPatient(LoggedInEHRRequestContext loggedInEHRRequestContext, Long accountId,
                                        Encounter conversation) {
<span class="fc" id="L1173">        PKBPerson patientReferredTo = null;</span>
<span class="fc" id="L1174">        Message latestMessage = conversation.getLatestMessage();</span>
<span class="fc" id="L1175">        String patientId = latestMessage.getPatientId();</span>
<span class="pc bpc" id="L1176" title="1 of 4 branches missed.">        if ((patientId != null) &amp;&amp; !patientId.isEmpty()) {</span>
<span class="fc" id="L1177">            patientReferredTo = userManager.getPKBPerson(parseLong(patientId), PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>
        }

<span class="fc bfc" id="L1180" title="All 2 branches covered.">        if (patientReferredTo == null) {</span>
            // Pravina: This part of the code should be phased out because it is a lot of processing
            // to find the referred patient to support old conversations before June 21 2012
<span class="fc" id="L1183">            Optional&lt;Message&gt; firstMessage = getOptionalFirstMessageInConversation(</span>
                    loggedInEHRRequestContext, accountId,
<span class="fc" id="L1185">                    conversation.getEncounterUniqueId());</span>
<span class="fc" id="L1186">            String senderId = null;</span>
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">            if (firstMessage.isPresent()) {</span>
<span class="fc" id="L1188">                senderId = firstMessage.get().getSenderId();</span>
            }
<span class="fc" id="L1190">            PKBPerson sender = null;</span>
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">            if (isNotEmpty(senderId)) {</span>
<span class="fc" id="L1192">                sender = userManager.getPKBPerson(parseLong(senderId), PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>
            }

<span class="pc bpc" id="L1195" title="2 of 4 branches missed.">            if ((sender != null) &amp;&amp; sender.isPatient()) {</span>
                // patient himself started the conversation or a carer may have started the
                // conversation on bhalf of patient, in both cases sender is the referred patient
<span class="nc" id="L1198">                patientReferredTo = sender;</span>
            } else {
                // receiver might be the referred patient
<span class="fc" id="L1201">                String receiverId = null;</span>
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">                if (firstMessage.isPresent()) {</span>
<span class="fc" id="L1203">                    receiverId = firstMessage.get().getReceiverId();</span>
                }
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">                if (isNotEmpty(receiverId)) {</span>
<span class="fc" id="L1206">                    PKBPerson receiver = userManager.getPKBPerson(parseLong(receiverId), PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">                    if (receiver.isPatient()) {</span>
                        //receiver is the referred patient
<span class="nc" id="L1209">                        patientReferredTo = receiver;</span>
                    } else {
<span class="fc" id="L1211">                        List&lt;String&gt; participants = conversation.getParticipants();</span>
                        PKBPerson person;
<span class="fc" id="L1213">                        int noOfPatients = 0;</span>
                        // search number of patients among the participants
<span class="fc bfc" id="L1215" title="All 2 branches covered.">                        for (String participant : participants) {</span>
<span class="fc" id="L1216">                            person = userManager.getPKBPerson(parseLong(participant), PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">                            if (person.isPatient()) {</span>
<span class="nc" id="L1218">                                noOfPatients++;</span>
                                // if only 1 patient then this is the referred one
<span class="nc" id="L1220">                                patientReferredTo = person;</span>
                            }
<span class="fc" id="L1222">                        }</span>
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">                        if (noOfPatients != 1) {</span>
                            // referred patient is one among participant but cannot be found out
<span class="fc" id="L1225">                            patientReferredTo = null;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L1231">        return patientReferredTo;</span>
    }

    void deleteConversation(@NotNull EHRRequestContext requestContext, Long userId, UUID conversationId) {
        try {
<span class="fc" id="L1236">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
            // This mainly used for participant who has left the conversation
            // and now rejoining the conversation
            // the user adding the participant may not have access to the
            // account hence this approach
            // of fetching directly the menu_data ids instead of getMessages
<span class="fc" id="L1242">            EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);
<span class="fc" id="L1244">            ehrSearch.addFilter(new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.EQUAL, conversationId));</span>
<span class="fc" id="L1245">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryEHRData(ehrSearch, requestContext);</span>

            // delete all the messages in the conversation
<span class="fc bfc" id="L1248" title="All 2 branches covered.">            for (EHRData ehrData : ehrList) {</span>
<span class="fc" id="L1249">                beanFactory.getEhrRemote().deleteEHRData(ehrData.getId());</span>
<span class="fc" id="L1250">            }</span>

<span class="nc" id="L1252">        } catch (Exception e) {</span>
<span class="nc" id="L1253">            throw new RuntimeException(&quot;Error while deleting conversation -&quot;</span>
                    + conversationId, e);
<span class="fc" id="L1255">        }</span>
<span class="fc" id="L1256">    }</span>

    public List&lt;Encounter&gt; getAllEncounters(@NotNull LoggedInEHRRequestContext requestContext, String patientId,
                                            Instant updatedSince, boolean fetchMessages, List&lt;String&gt; reasonApiRefsOrNull,
                                            Set&lt;EncounterClass&gt; encounterClassFilters,
                                            @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {
        try {
<span class="fc" id="L1263">            synchUploadedData(requestContext, userManager.getDefaultAccountId(Long.parseLong(patientId)));</span>
<span class="fc" id="L1264">            List&lt;Long&gt; codeIds = null;</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">            if (reasonApiRefsOrNull != null) {</span>
<span class="fc" id="L1266">                var codes = EncounterReasonApiRef.getCodesByApiRef(reasonApiRefsOrNull);</span>
<span class="fc" id="L1267">                codeIds = codeManager.getCodeIds(codes);</span>
            }
<span class="fc" id="L1269">            List&lt;Encounter&gt; encounters = getAllEncounters(requestContext,</span>
                    patientId,
                    updatedSince,
                    fetchMessages,
                    codeIds,
                    encounterClassFilters);
<span class="fc" id="L1275">            codeManager.populateCodes(encounters);</span>
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">            if (i18nMethod != null) {</span>
<span class="fc" id="L1277">                encounters.forEach(encounter -&gt; translate(i18nMethod, encounter.getMessages()));</span>
            }
<span class="fc" id="L1279">            populateApiRefs(encounters);</span>
<span class="fc" id="L1280">            return encounters;</span>
<span class="nc" id="L1281">        } catch (Exception e) {</span>
<span class="nc" id="L1282">            throw new RuntimeException(&quot;Exception while fetching all non virtual encounters for patientId-&quot; + patientId, e);</span>
        }
    }

    private Encounter getConversationRecordFromDB(@NotNull LoggedInEHRRequestContext requestContext, UUID conversationId, Long currentUserId, long accountId) throws ParseException {
<span class="fc" id="L1287">        LOGGER.info(&quot;getConversationRecordFromDB for conversation - {} start&quot;, conversationId);</span>

<span class="fc" id="L1289">        Message latestMessage = getLatestMessageOnConversation(requestContext, accountId, conversationId);</span>

<span class="fc" id="L1291">        var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(currentUserId);</span>
<span class="fc bfc" id="L1292" title="All 2 branches covered.">        if (Objects.equals(defaultAccountId, accountId)) {</span>
<span class="fc" id="L1293">            LOGGER.info(&quot;defaultAccountUser=true&quot;);</span>
        } else {
            // user is not a default account user
            // check if the user is a participant
<span class="fc bfc" id="L1297" title="All 2 branches covered.">            if (latestMessage != null) {</span>
<span class="fc" id="L1298">                List&lt;String&gt; participants = latestMessage.getParticipants();</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">                if (latestMessage.isPrivateMessage()) {</span>
                    // if private message and not a participant then return null
<span class="fc" id="L1301">                    String currentUserIdString = currentUserId.toString();</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">                    if (!participants.contains(currentUserIdString)) {</span>
<span class="nc" id="L1303">                        LOGGER.info(&quot;Private message; logged user not a participant hence returning null conversation&quot;);</span>
<span class="nc" id="L1304">                        return null;</span>
                    }
                }
            }
        }

<span class="fc" id="L1310">        Encounter conversation = null;</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">        if (latestMessage != null) {</span>
<span class="fc" id="L1312">            List&lt;UUID&gt; conversationIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1313">            conversationIds.add(conversationId);</span>
<span class="fc" id="L1314">            Map&lt;UUID, Long&gt; messageCountMap = getEncounterToMessageCountMap(</span>
<span class="fc" id="L1315">                    accountId, conversationIds, requestContext);</span>
<span class="fc" id="L1316">            Message firstMessage = getFirstMessageInConversation(requestContext, accountId, conversationId);</span>
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">            if (firstMessage == null) {</span>
<span class="nc" id="L1318">                LOGGER.debug(&quot;Conversation is hidden from the accessing user&quot;);</span>
<span class="nc" id="L1319">                return null;</span>
            } else {
<span class="fc" id="L1321">                conversation = populateConversation(latestMessage,</span>
<span class="fc" id="L1322">                        messageCountMap.get(conversationId), firstMessage);</span>

<span class="fc" id="L1324">                LOGGER.info(&quot;getConversationRecordFromDB for end - {} start&quot;, conversationId);</span>
            }
<span class="fc" id="L1326">        } else {</span>
            // This could be a non-virtual encounter with no messages so attempt fetching it
<span class="fc" id="L1328">            conversation = getEncounterByConversationUniqueId(requestContext, currentUserId.toString(), conversationId, true /*fetchParticipants*/);</span>
        }
<span class="fc" id="L1330">        return conversation;</span>
    }

    /**
     * Populate the conversation object from a menu data row
     */
    private Encounter populateConversation(Message latestMessage, Long messageCount, @Nullable Message firstMessage) throws ParseException {
<span class="fc" id="L1337">        Encounter conversation = new Encounter(new SourceDetails());</span>
<span class="fc" id="L1338">        conversation.setEncounterUniqueId(latestMessage.getEncounterUniqueId());</span>

<span class="fc" id="L1340">        conversation.setAboutPatientId(latestMessage.getPatientId());</span>
<span class="fc" id="L1341">        conversation.setFirstMessage(firstMessage);</span>
<span class="fc" id="L1342">        conversation.setLatestMessage(latestMessage);</span>
<span class="fc" id="L1343">        conversation.setMessageCount(messageCount);</span>
<span class="fc" id="L1344">        conversation.setParticipants(latestMessage.getParticipants());</span>

        // Copy consent from first message into encounter object so that new messages can be given the same value
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">        if (firstMessage != null) {</span>
<span class="fc" id="L1348">            firstMessage.getBaseFields().copyConsentFlags(conversation.getBaseFields());</span>
        }

<span class="fc" id="L1351">        conversation.setParticipantsNonPKB(latestMessage.getParticipantsNonPKB());</span>
<span class="fc" id="L1352">        conversation.setEncounterClass(latestMessage.getEncounterClass());</span>
<span class="fc" id="L1353">        return conversation;</span>
    }

    private Map&lt;UUID, Long&gt; getEncounterToMessageCountMap(Long accountId, List&lt;UUID&gt; encounterUniqueIds, EHRRequestContext context) throws ParseException {
<span class="fc" id="L1357">        EHRSearch&lt;Message&gt; messageSearch = new EHRSearch&lt;&gt;(accountId, Message.class, Message.MS_PATH_MESSAGE);</span>
<span class="fc" id="L1358">        messageSearch.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>
<span class="fc" id="L1359">        messageSearch.addFilter(new PKBFilter(Message.ENCOUNTER_ID, PKBFilter.Operator.IN, encounterUniqueIds));</span>
        // it never makes sense to count the INDRAFTs as actual messages unless in own INBOX
<span class="fc bfc" id="L1361" title="All 2 branches covered.">        if (!context.isUserInOwnAccount()) {</span>
<span class="fc" id="L1362">            messageSearch.addFilter(new PKBFilter(&quot;string04&quot;, PKBFilter.Operator.NOT_EQUAL_OR_NULL, &quot;INDRAFT&quot;));</span>
        }
<span class="fc" id="L1364">        messageSearch.setRequestContext(context.withConsentStatus(context.getConsentStatus().withRequired(false)));</span>

<span class="fc" id="L1366">        EHRSearch&lt;EncounterEvent&gt; encounterSearch = new EHRSearch&lt;&gt;(accountId, EncounterEvent.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>
<span class="fc" id="L1367">        encounterSearch.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>
<span class="fc" id="L1368">        encounterSearch.addFilter(new PKBFilter(Message.ENCOUNTER_ID, PKBFilter.Operator.IN, encounterUniqueIds));</span>
        // We need to exclude messages of type ENCOUNTER_DETAILS because these are
        // system generated and should not be included in the message count
<span class="fc" id="L1371">        encounterSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L1372">                Message.MessageType.ENCOUNTER_DETAILS.toString())); // EHRBean knows what to do with this PrivateId, we just set the string value</span>
<span class="fc" id="L1373">        encounterSearch.setRequestContext(context);</span>

<span class="fc" id="L1375">        List&lt;EHRData&gt; allMessages = beanFactory.getEhrRemote().queryEHRData(newArrayList(messageSearch, encounterSearch), context.withoutAccessLog());</span>
<span class="fc" id="L1376">        return allMessages.stream().collect(Collectors.groupingBy(EHRData::getUuid01, Collectors.counting()));</span>
    }

    private Message getLatestMessageOnConversation(@NotNull LoggedInEHRRequestContext requestContext,
                                                   long accountId,
                                                   UUID conversationId) {
<span class="fc" id="L1382">        EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                ENCOUNTER_TYPES);
<span class="fc" id="L1384">        ehrSearch.addFilter(new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.EQUAL,</span>
                conversationId));

        // we need to exclude ENCOUNTER_DETAILS messages from this query because
        // these are system generated messages and not visible to the end user
<span class="fc" id="L1389">        ehrSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L1390">                Message.MessageType.ENCOUNTER_DETAILS.toString()));</span>
<span class="fc bfc" id="L1391" title="All 2 branches covered.">        if (requestContext.getConsentStatus().isRequired()) {</span>
<span class="fc" id="L1392">            ehrSearch.setUseParticipantFilter();</span>
        }
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        if (!requestContext.isUserInOwnAccount()) {</span>
<span class="fc" id="L1395">            ehrSearch.addFilter(new PKBFilter(&quot;string04&quot;, PKBFilter.Operator.NOT_EQUAL_OR_NULL, &quot;INDRAFT&quot;));</span>
        }
<span class="fc" id="L1397">        ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Desc);</span>
<span class="fc" id="L1398">        ehrSearch.setResultsMaxReturned(1);</span>
<span class="fc" id="L1399">        List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>

<span class="fc bfc" id="L1401" title="All 2 branches covered.">        if (ehrList.isEmpty()) {</span>
<span class="fc" id="L1402">            return null;</span>
        }
<span class="fc" id="L1404">        return populateMessage(requestContext, ehrList.get(0));</span>
    }

    @Nullable
    private Encounter getConversation(@NotNull LoggedInEHRRequestContext requestContext, UUID conversationId, Long currentUserId,
                                      Long accountId) {
        try {
<span class="fc" id="L1411">            LOGGER.debug(&quot;getConversation start&quot;);</span>
<span class="fc" id="L1412">            LOGGER.debug(&quot;Trying to fetch conversation for conversation id-{} userId-{} accountid-{}&quot;,</span>
                    conversationId, currentUserId, accountId);
<span class="fc" id="L1414">            Encounter conversation = null;</span>

<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">            if (conversationId != null) {</span>
<span class="fc" id="L1417">                conversation = getConversationRecordFromDB(requestContext, conversationId, currentUserId, accountId);</span>

<span class="fc bfc" id="L1419" title="All 2 branches covered.">                if (conversation == null) {</span>
<span class="fc" id="L1420">                    LOGGER.debug(&quot;No results found for conversation id-{} returning null conversation&quot;, conversationId);</span>
<span class="fc" id="L1421">                    return null;</span>
                }
<span class="fc" id="L1423">                Message message = conversation.getLatestMessage();</span>
<span class="fc" id="L1424">                Message firstMessage = conversation.getFirstMessage();</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">                if (firstMessage != null) {</span>
<span class="fc" id="L1426">                    conversation.setNextConversationId(getNextConversation(requestContext, currentUserId, accountId,</span>
<span class="fc" id="L1427">                            message.getId(), firstMessage.getMessageTimestamp()));</span>
<span class="fc" id="L1428">                    conversation.setPreviousConversationId(getPrevConversation(requestContext,</span>
<span class="fc" id="L1429">                            currentUserId, accountId, firstMessage));</span>
                }
            }
<span class="fc" id="L1432">            LOGGER.debug(&quot;getConversation end &quot;);</span>
<span class="fc" id="L1433">            return conversation;</span>
<span class="nc" id="L1434">        } catch (Exception e) {</span>
<span class="nc" id="L1435">            LOGGER.error(e.getMessage());</span>
<span class="nc" id="L1436">            throw new RuntimeException(Thread.currentThread().getName()</span>
                    + &quot; Exception while getting conversation for id-&quot;
                    + conversationId, e);
        }
    }

    /**
     * Return the previous conversation in the sequence of decreasing order of
     * time stamp
     *
     * @param requestContext
     * @param currentUserId  Timestamp of latest message id in the current conversation
     * @param accountId      the record holder's account
     * @return Id of the next conversation
     */
    private UUID getPrevConversation(EHRRequestContext requestContext, Long currentUserId, long accountId,
                                     @Nullable Message firstMessage) {

        try {
<span class="fc" id="L1455">            EHRSearch ehrSearch = prepareConversationSearch(currentUserId, accountId);</span>

<span class="pc bpc" id="L1457" title="2 of 4 branches missed.">            if (firstMessage != null &amp;&amp; firstMessage.getMessageTimestamp() != null) {</span>
<span class="fc" id="L1458">                ehrSearch.addFilter(new PKBFilter(&quot;date01&quot;, PKBFilter.Operator.GREATER, firstMessage.getMessageTimestamp()));</span>

<span class="fc" id="L1460">                ehrSearch.addFilter(new PKBFilter(Message.ENCOUNTER_ID,</span>
<span class="fc" id="L1461">                        PKBFilter.Operator.NOT_EQUAL, firstMessage.getEncounterUniqueId()));</span>
            }

<span class="fc" id="L1464">            ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Asc);</span>

<span class="fc" id="L1466">            return getConversationUuid(requestContext, ehrSearch);</span>
<span class="nc" id="L1467">        } catch (Exception e) {</span>
<span class="nc" id="L1468">            throw new RuntimeException(</span>
                    &quot;Exception while getting previous conversation for account: &quot; + accountId + &quot;, user &quot;
                            + currentUserId + &quot; and current message: &quot; + firstMessage,
                    e);
        }
    }

    /**
     * Return the next conversation in the decreasing sequence of timestamp
     *
     * @param requestContext
     * @param currentUserId
     * @param accountId        record holder's account
     * @param currentTimestamp : Timestamp of the latest message in the conversation id
     * @return Id of the next conversation
     */
    private UUID getNextConversation(EHRRequestContext requestContext, Long currentUserId, long accountId,
                                     Long currentId, Instant currentTimestamp) {

        try {
<span class="fc" id="L1488">            EHRSearch ehrSearch = prepareConversationSearch(currentUserId, accountId);</span>

<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">            if (currentTimestamp != null) {</span>
<span class="fc" id="L1491">                ehrSearch.addFilter(new PKBFilter(&quot;date01&quot;, PKBFilter.Operator.LESS, currentTimestamp));</span>
            }

<span class="fc" id="L1494">            ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Desc);</span>

<span class="fc" id="L1496">            return getConversationUuid(requestContext, ehrSearch);</span>
<span class="nc" id="L1497">        } catch (Exception e) {</span>
<span class="nc" id="L1498">            throw new RuntimeException(</span>
                    &quot;Exception while next conversation for -&quot; + currentId, e);
        }
    }

    @Nullable
    private UUID getConversationUuid(EHRRequestContext requestContext, EHRSearch ehrSearch) {
<span class="fc" id="L1505">        List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryEHRData(ehrSearch, requestContext);</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">        if (ehrList.isEmpty()) {</span>
<span class="fc" id="L1507">            return null;</span>
        } else {
<span class="fc" id="L1509">            return ehrList.get(0).getUuid01();</span>
        }
    }

    @NotNull
    private EHRSearch prepareConversationSearch(Long currentUserId, long accountId) {
<span class="fc" id="L1515">        EHRSearch ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                ENCOUNTER_TYPES);

<span class="fc" id="L1518">        ehrSearch.setResultsMaxReturned(1);</span>

<span class="fc" id="L1520">        var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(currentUserId);</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">        if (!Objects.equals(accountId, defaultAccountId)) {</span>
<span class="fc" id="L1522">            ehrSearch.addFilter(new PKBFilter(&quot;boolean01&quot;, PKBFilter.Operator.FALSE_OR_IS_NULL, null));</span>
        }
        // exclude messages of type ENCOUNTER_DETAILS
<span class="fc" id="L1525">        ehrSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L1526">                Message.MessageType.ENCOUNTER_DETAILS.toString()));</span>

<span class="fc" id="L1528">        return ehrSearch;</span>
    }

    public Encounter getEncounterByEncounterEventUniqueId(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext, String patientId, UUID encounterEventUniqueId,
                                                          boolean fetchParticipants, @Nullable BiFunction&lt;String, String[], String&gt; i18nMethod) {

<span class="fc" id="L1534">        Encounter encounter = getEncounterByEncounterEventUniqueId(loggedInEHRRequestContext, patientId, encounterEventUniqueId, fetchParticipants);</span>
<span class="pc bpc" id="L1535" title="1 of 2 branches missed.">        if (encounter != null) {</span>
<span class="fc" id="L1536">            codeManager.populateCodes(Collections.singletonList(encounter));</span>
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">            if (i18nMethod != null) {</span>
<span class="fc" id="L1538">                translate(i18nMethod, encounter.getMessages());</span>
            }
<span class="fc" id="L1540">            populateApiRef(encounter);</span>
        }
<span class="fc" id="L1542">        return encounter;</span>
    }

    public void synchUploadedData(@NotNull LoggedInEHRRequestContext loggedInEHRRequestContext, long accountId)
            throws NamingException, SystemException {
<span class="fc" id="L1547">        LOGGER.info(&quot;Claim Uploaded Encounter Data being externally triggered.&quot;);</span>
<span class="fc" id="L1548">        doSyncUploadedData(loggedInEHRRequestContext, accountId);</span>
<span class="fc" id="L1549">    }</span>

    public Tuple2&lt;HL7MessageType, Optional&lt;UUID&gt;&gt; saveUploadedMessage(@NotNull EHRRequestContext requestContext, PKBPerson patient, UploadedDataDTO dto) {
<span class="fc" id="L1552">        HL7XmlDoc hl7 = getHl7XmlDoc(requestContext, dto);</span>

<span class="fc" id="L1554">        HL7MessageType messageType = hl7.getMessageType();</span>

<span class="pc bpc" id="L1556" title="3 of 4 branches missed.">        checkState(messageType == HL7MessageType.MDM_T02 || messageType == HL7MessageType.MDM_T11, &quot;HL7 MessageType must be MDM^T02 or MDM^T11&quot;);</span>

<span class="fc" id="L1558">        EHRRequestContext piggybackContext = requestContext.withPiggyback(true);</span>
<span class="fc" id="L1559">        Long accountId = userManager.getDefaultAccountId(patient.getId());</span>

<span class="fc" id="L1561">        UploadedDataProcessingResult&lt;?&gt; uploadedDataProcessingResult = uploadedDataService.processUploadedData(</span>
<span class="fc" id="L1562">                loggedOutUploadedDataProcessingContext()</span>
<span class="fc" id="L1563">                        .requestContext(piggybackContext)</span>
<span class="fc" id="L1564">                        .patientId(patient.getId())</span>
<span class="fc" id="L1565">                        .destination(UploadedData.Destination.DOCUMENT)</span>
<span class="fc" id="L1566">                        .patientAccountId(accountId)</span>
<span class="fc" id="L1567">                        .patient(patient)</span>
<span class="fc" id="L1568">                        .build(),</span>
                dto);

<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">        if (uploadedDataProcessingResult.getStatus() == UploadedData.Status.COMPLETED) {</span>
<span class="fc" id="L1572">            documentSaves.labels(hl7.getClass().getSimpleName(), &quot;success&quot;).inc();</span>
        } else {
<span class="nc" id="L1574">            documentSaves.labels(hl7.getClass().getSimpleName(), &quot;failure&quot;).inc();</span>
        }
<span class="fc" id="L1576">        return Tuple.of(messageType, Optional.ofNullable((UploadedDocument) uploadedDataProcessingResult</span>
<span class="fc" id="L1577">                        .getSingleResult()</span>
<span class="fc" id="L1578">                        .orElse(null))</span>
<span class="fc" id="L1579">                .map(uploadedDocument -&gt; Optional.ofNullable(uploadedDocument.getEncounterEvent())</span>
<span class="fc" id="L1580">                        .map(Message::getEncounterUniqueId))</span>
<span class="fc" id="L1581">                .orElse(null));</span>
    }

    private HL7XmlDoc getHl7XmlDoc(EHRRequestContext requestContext, UploadedDataDTO dto) {
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">        checkState(dto.getFormat() == Format.HL7, &quot;DTO format must be HL7&quot;);</span>
<span class="fc" id="L1586">        HL7Wrapper wrapper = hl7ParsingManager.processXmlData(dto.getData(), requestContext);</span>
<span class="fc" id="L1587">        return wrapper.getHL7Xml();</span>
    }

    // Private methods

    private void doSyncUploadedData(@NotNull LoggedInEHRRequestContext requestContext, long accountId) {
<span class="fc" id="L1593">        Object lock = unchecked(() -&gt; UPLOAD_SYNCH_LOCKS.get(accountId, Object::new)).get();</span>
<span class="fc" id="L1594">        synchronized (lock) {</span>
<span class="fc" id="L1595">            LoggedInEHRRequestContext piggybackContext = requestContext.withPiggyback(true);</span>
<span class="fc" id="L1596">            PKBPerson patient = userManager.getAccountOwner(accountId);</span>
<span class="pc bpc" id="L1597" title="1 of 2 branches missed.">            if (patient == null) {</span>
<span class="nc" id="L1598">                throw new IllegalStateException(&quot;No owner found for accountId: &quot; + accountId);</span>
            }

<span class="fc" id="L1601">            uploadedDataService.synchUploadedData(</span>
<span class="fc" id="L1602">                    loggedInUploadedDataProcessingContext()</span>
<span class="fc" id="L1603">                            .requestContext(piggybackContext)</span>
<span class="fc" id="L1604">                            .patientId(patient.getId())</span>
<span class="fc" id="L1605">                            .destination(UploadedData.Destination.DOCUMENT)</span>
<span class="fc" id="L1606">                            .build());</span>

<span class="fc" id="L1608">            uploadedDataService.synchUploadedData(</span>
<span class="fc" id="L1609">                    loggedInUploadedDataProcessingContext()</span>
<span class="fc" id="L1610">                            .requestContext(piggybackContext)</span>
<span class="fc" id="L1611">                            .patientId(patient.getId())</span>
<span class="fc" id="L1612">                            .destination(UploadedData.Destination.ENCOUNTER)</span>
<span class="fc" id="L1613">                            .build());</span>
<span class="fc" id="L1614">        }</span>
<span class="fc" id="L1615">    }</span>

    /*
     * Called when document deletions are processed synchronously when received
     */
    public Tuple2&lt;@Nullable UUID, Integer&gt; deleteDocumentByExternalDocumentId(EHRRequestContext requestContext, String externalDocumentId,
                                                                              UploadedDataDTO dto, PKBPerson patient) {

<span class="fc" id="L1623">        SourceDetails sourceDetails = new SourceDetails(dto);</span>
<span class="fc" id="L1624">        Long accountId = userManager.getDefaultAccountId(patient.getId());</span>

        try {
<span class="fc" id="L1627">            return transactional(() -&gt; {</span>
<span class="fc" id="L1628">                Tuple2&lt;UUID, Integer&gt; encounterUniqueIdAndDeleteCount = deleteEncountersByExternalDocumentId(</span>
<span class="fc" id="L1629">                        requestContext, accountId, sourceDetails, externalDocumentId, dto.getSourceOrg());</span>
<span class="fc" id="L1630">                dataUploadManager.updateUploadedDataStatus(dto.getId(), dto.getVersion(), UploadedData.Status.COMPLETED);</span>
<span class="fc" id="L1631">                return encounterUniqueIdAndDeleteCount;</span>
            });
<span class="nc" id="L1633">        } catch (Exception e) {</span>
<span class="nc" id="L1634">            throw new RuntimeException(&quot;Exception while deleting document for external document ID-&quot; + externalDocumentId, e);</span>
        }
    }

    Long saveMessageForParticipants(LoggedInEHRRequestContext loggedInEHRRequestContext, PKBPerson referredPatient,
                                    List&lt;String&gt; skipParticipants, Message message, List&lt;Attachment&gt; attachments,
                                    boolean requiresImmediatePatientAccountSave) {

        // Can be null or if INDRAFT then a valid id
<span class="fc" id="L1643">        Long senderMessageId = message.getId();</span>
<span class="fc" id="L1644">        List&lt;String&gt; participants = message.getParticipants();</span>
<span class="pc bpc" id="L1645" title="2 of 4 branches missed.">        if ((participants == null) || participants.isEmpty()) {</span>
            // if no participant add the sender/receiver id in the list
<span class="nc" id="L1647">            participants = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1648">            participants.add(message.getSenderId());</span>
<span class="nc" id="L1649">            String receiver = message.getReceiverId();</span>
            // Receiver can be empty for INDRAFT message
<span class="nc bnc" id="L1651" title="All 2 branches missed.">            if (!StringUtils.isEmpty(receiver)) {</span>
<span class="nc" id="L1652">                participants.add(receiver);</span>
            }
        }

<span class="fc bfc" id="L1656" title="All 2 branches covered.">        if (!participants.contains(message.getSenderId())) {</span>
<span class="fc" id="L1657">            participants.add(message.getSenderId());</span>
        }

<span class="fc" id="L1660">        logIfPatientMessageHasMissingPatientParticipant(message.getEncounterUniqueId(), participants, referredPatient);</span>

        //No more mutating the participants now please.
<span class="fc" id="L1663">        participants = ImmutableList.copyOf(participants);</span>
<span class="fc" id="L1664">        message.setParticipants(participants);</span>

        // First save the message in sender's account whether INDRAFT Or any other
        // if this was in draft message then do not create a new message
        // use the original message id ; it will be set to null for others
<span class="fc" id="L1669">        message.setId(senderMessageId);</span>
<span class="fc" id="L1670">        message.getBaseFields().generateNewRandomUniqueId();</span>
<span class="fc" id="L1671">        long senderAccountId = userManager.getDefaultAccountId(parseLong(message.getSenderId()));</span>
<span class="fc" id="L1672">        senderMessageId = saveSingleMessage(loggedInEHRRequestContext, message.getSenderId(), senderAccountId, message, attachments);</span>
<span class="fc" id="L1673">        skipParticipants.add(message.getSenderId());</span>

<span class="pc bpc" id="L1675" title="1 of 4 branches missed.">        if ((message.getMessageStatus() != null) &amp;&amp; message.getMessageStatus() == MessageStatus.INDRAFT) {</span>
<span class="fc" id="L1676">            return senderMessageId;</span>
        } else {
<span class="fc" id="L1678">            Map&lt;String, PKBPerson&gt; personMap = userManager.getPKBPersonMap(participants, PKBPerson.Lazy.CONTACTS, PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);</span>
<span class="fc" id="L1679">            PKBPerson composer = personMap.get(message.getSenderId());</span>

            // Special case:
            // Usually the message would get saved across accounts asynchronously, but this causes issues for cases
            // where we're in patient context or somehow reliant on the patient record being updated immediately.
            // (E.g. if you're in the patient record sending a message, when you hit send you expect to see the result
            // immediately, not just whenever the async task happens to finish).
<span class="fc bfc" id="L1686" title="All 2 branches covered.">            if (requiresImmediatePatientAccountSave) {</span>
                // we should pass around the contextUserId... or get via EHRRequestContext.  BUT not from the consent in there!
                // in BTG or TDV there's a patient contextUserId but no consent in place!
<span class="fc" id="L1689">                String contextUserIdString = referredPatient.getIdString();</span>
                //set message id to null;
<span class="fc" id="L1691">                message.setId(null);</span>
<span class="fc" id="L1692">                senderMessageId = saveSingleMessage(loggedInEHRRequestContext, contextUserIdString, referredPatient.getDefaultAccountId(), message, attachments);</span>
                // Add context user id to skip participants for later part of the flow
                // now that we have already saved it
<span class="fc" id="L1695">                skipParticipants.add(contextUserIdString);</span>
                // notify context patient
<span class="fc" id="L1697">                messagingManager.notifyReceiverOnly(composer, referredPatient, message.getEncounterUniqueId());</span>

                // Send NHS notification to context patient
<span class="fc" id="L1700">                nhsAppNotificationManager.sendNotification(loggedInEHRRequestContext, referredPatient, NhsApiNotificationTriggerType.NEW_MESSAGE_RECEIVED);</span>
            }

<span class="fc" id="L1703">            participantManager.saveParticipantsForMessage(loggedInEHRRequestContext, message);</span>

<span class="fc" id="L1705">            message.setAttachments(attachments);</span>

            // This is a sent message to save it for all recipients other than sender
            MessageThreadDTO messageThreadDTO;
<span class="fc" id="L1709">            messageThreadDTO = new MessageThreadDTO();</span>
<span class="fc" id="L1710">            messageThreadDTO.setMessageViaClone(message);</span>
<span class="fc" id="L1711">            messageThreadDTO.setComposer(composer);</span>
<span class="fc" id="L1712">            messageThreadDTO.setReferredPatient(referredPatient);</span>
<span class="fc" id="L1713">            messageThreadDTO.setSenderMessageId(senderMessageId);</span>
<span class="fc" id="L1714">            messageThreadDTO.setPersonMap(personMap);</span>
<span class="fc" id="L1715">            messageThreadDTO.setSkipParticipants(skipParticipants);</span>
<span class="fc" id="L1716">            messageThreadDTO.setExistingMessageUniqueId(message.getBaseFields().getUniqueId());</span>

<span class="fc" id="L1718">            taskExecutor.execute(new SaveMessageTask(loggedInEHRRequestContext, this, userManager, messagingManager, messageThreadDTO, patientConsentManager, nhsAppNotificationManager, chunkedDocManager));</span>

<span class="fc bfc" id="L1720" title="All 2 branches covered.">            if (carersShouldBeNotified(referredPatient, message)) {</span>
<span class="fc" id="L1721">                taskExecutor.execute(new NotifyCarersTask(</span>
                        messagingManager,
                        patientConsentManager,
                        composer,
                        referredPatient,
                        message,
                        loggedInEHRRequestContext
                ));
            }

<span class="fc" id="L1731">            transactional(() -&gt; trustedConversationWorkflowService.forceUnarchiveConversationForAllTeams(message.getEncounterUniqueId(), parseLong(message.getSenderId())));</span>

<span class="fc" id="L1733">            return senderMessageId;</span>
        }
    }

    boolean carersShouldBeNotified(PKBPerson referredPatient, Message message) {
<span class="fc bfc" id="L1738" title="All 4 branches covered.">        return !message.isPrivateMessage()</span>
                &amp;&amp; (referredPatient != null)
<span class="fc bfc" id="L1740" title="All 2 branches covered.">                &amp;&amp; !EmailManager.emailsDisabledForPerson(referredPatient);</span>
    }

    // *****************************************
    // Send Messages using Velocity templates *
    // *****************************************
    private Message getMessageCopy(Message message, String receiverId, MessageStatus status) {
<span class="fc" id="L1747">        Message copy = new Message(new SourceDetails(message.getSource()));</span>
<span class="fc" id="L1748">        copy.setAttachmentCount(message.getAttachmentCount());</span>
<span class="fc" id="L1749">        copy.setContent(message.getContent());</span>
<span class="fc" id="L1750">        copy.setEncounterUniqueId(message.getEncounterUniqueId());</span>
<span class="fc" id="L1751">        copy.setPatientId(message.getPatientId());</span>
<span class="fc" id="L1752">        copy.setPatientIdString(message.getPatientIdString());</span>
<span class="fc" id="L1753">        copy.setInlineContentId(message.getInlineContentId());</span>
<span class="fc" id="L1754">        copy.setInlineContentText(message.getInlineContentText());</span>
<span class="fc" id="L1755">        copy.setInlineContentType(message.getInlineContentType());</span>
<span class="fc" id="L1756">        copy.setMessageTimestamp(message.getMessageTimestamp());</span>
<span class="fc" id="L1757">        copy.setHtmlAllowed(message.isHtmlAllowed());</span>
<span class="fc" id="L1758">        copy.setParticipants(message.getParticipants());</span>
<span class="fc" id="L1759">        copy.setOnBehalfAuthorId(message.getOnBehalfAuthorId());</span>
<span class="fc" id="L1760">        copy.setReceiverPhoneNumber(message.getReceiverPhoneNumber());</span>
<span class="fc" id="L1761">        copy.setReceiverSkypeId(message.getReceiverSkypeId());</span>
<span class="fc" id="L1762">        copy.setSenderId(message.getSenderId());</span>
<span class="fc" id="L1763">        copy.setSubject(message.getSubject());</span>
        // from method parameters
<span class="fc" id="L1765">        copy.setReceiverId(receiverId);</span>
<span class="fc" id="L1766">        copy.setMessageStatus(status);</span>
<span class="fc" id="L1767">        copy.getBaseFields().setUniqueId(message.getBaseFields().getUniqueId());</span>

<span class="fc" id="L1769">        return copy;</span>
    }

    private void populateApiRefs(List&lt;Encounter&gt; encounters) {
        // add apirefs back to each encounter record
<span class="fc" id="L1774">        encounters.forEach(EncounterManagerUtil::populateApiRef);</span>
<span class="fc" id="L1775">    }</span>

    public Message createMessage(String patientId, UUID conversationId, boolean isFirst, String senderId, String subject, String content, PrivacyFlag privacyFlag,
                                 EHRRequestContext requestContext) {
<span class="fc" id="L1779">        Message message = new Message(new SourceDetails(requestContext));</span>
<span class="fc" id="L1780">        message.setPatientId(patientId);</span>
<span class="fc" id="L1781">        message.setReceiverId(patientId);</span>
<span class="fc" id="L1782">        message.setEncounterUniqueId(conversationId);</span>
<span class="fc" id="L1783">        message.setSenderId(senderId);</span>
<span class="fc" id="L1784">        message.setSubject(subject);</span>
<span class="fc" id="L1785">        message.setContent(content);</span>
<span class="fc" id="L1786">        message.setMessageTimestamp(dateTimeService.now());</span>
<span class="fc" id="L1787">        message.setPrivacyFlag(privacyFlag);</span>
<span class="fc" id="L1788">        message.initializeUniqueIds(isFirst);</span>
<span class="fc bfc" id="L1789" title="All 2 branches covered.">        message.setPatientNotFound(patientId == null);</span>
<span class="fc" id="L1790">        return message;</span>
    }

    @Override
    public void syncUploadedData(LoggedInEHRRequestContext loggedInEHRRequestContext, Collection&lt;Long&gt; targetPersonIds) {
<span class="fc" id="L1795">        Map&lt;Long, Long&gt; defaultAccountIds = userManager.getDefaultAccountId(targetPersonIds);</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">        for (Long targetPersonId : targetPersonIds) {</span>
<span class="fc" id="L1797">            doSyncUploadedData(loggedInEHRRequestContext, defaultAccountIds.get(targetPersonId));</span>
<span class="fc" id="L1798">        }</span>
<span class="fc" id="L1799">    }</span>

    public void analysePDFandReport(LoggedInEHRRequestContext loggedInEHRRequestContext, String externalMessageId,
                                    Attachment attachment) throws Exception {
<span class="fc" id="L1803">        var pdfValidationResult = pdfValidator.validatePDF(attachment.getContent());</span>
<span class="fc" id="L1804">        UUID publicPersonId = userManager.getPKBPerson(loggedInEHRRequestContext.getContextOrAccessingUserId()).getPublicId();</span>
<span class="fc" id="L1805">        Instant now = dateTimeService.now();</span>
<span class="fc" id="L1806">        unreadableDocumentService.save(ImmutableNewUnreadableDocument.builder()</span>
<span class="fc" id="L1807">                .personPublicId(publicPersonId)</span>
<span class="fc" id="L1808">                .externalMessageId(externalMessageId)</span>
<span class="fc" id="L1809">                .attachment(ImmutableAttachmentMetadata.builder()</span>
<span class="fc" id="L1810">                        .id(attachment.getId())</span>
<span class="fc" id="L1811">                        .filename(attachment.getFilename())</span>
<span class="pc bpc" id="L1812" title="1 of 2 branches missed.">                        .uploadTime(attachment.getUploadTime() != null ? attachment.getUploadTime().toInstant() : now)</span>
<span class="fc" id="L1813">                        .build()</span>
                )
<span class="fc" id="L1815">                .reported(now)</span>
<span class="fc" id="L1816">                .pdfValidationResult(pdfValidationResult)</span>
<span class="fc" id="L1817">                .build());</span>
<span class="fc" id="L1818">    }</span>

    public boolean isDocumentReported(long attachmentId) {
<span class="fc" id="L1821">        return unreadableDocumentService.isDocumentReported(attachmentId);</span>
    }

    private void translate(@Nullable BiFunction&lt;String, String[], String&gt; i18nMethod, @NotNull List&lt;Message&gt; messages) {
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">        if (i18nMethod != null) {</span>
<span class="fc" id="L1826">            messages.stream()</span>
<span class="fc bfc" id="L1827" title="All 2 branches covered.">                    .filter(message -&gt; message.getDocumentType() != null)</span>
<span class="fc" id="L1828">                    .forEach(message -&gt; Message.DocumentType.translate(i18nMethod, message));</span>
        }
<span class="fc" id="L1830">    }</span>

    private MessageSenderDTO getMessageSenderDetails(EHRRequestContext requestContext, MessagingPKBPersonDTO sender, Message message) {

<span class="fc" id="L1834">        MessageSenderDTO ms = new MessageSenderDTO();</span>
<span class="fc" id="L1835">        ms.setSender(sender);</span>

        // we now have the original message that started this conversation
<span class="fc bfc" id="L1838" title="All 2 branches covered.">        if (sender != null) {</span>
            // get team for sender ID
<span class="fc" id="L1840">            Team team = null;</span>

<span class="fc bfc" id="L1842" title="All 2 branches covered.">            if (sender.isPro()) {</span>

<span class="fc" id="L1844">                List&lt;InstituteUser&gt; instituteUsers = instituteUserManager.getInstituteUsersForPerson(requestContext,</span>
<span class="fc" id="L1845">                        sender.getId());</span>

<span class="fc bfc" id="L1847" title="All 2 branches covered.">                for (InstituteUser iu : instituteUsers) {</span>
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">                    if (iu.getSponsorshipStatus() == SponsorshipStatus.ACTIVE) {</span>
<span class="fc" id="L1849">                        team = iu.getInstitute();</span>
<span class="fc" id="L1850">                        break;</span>
                    }
<span class="nc" id="L1852">                }</span>
            }

<span class="fc bfc" id="L1855" title="All 2 branches covered.">            if (team != null) {</span>
<span class="fc" id="L1856">                ms.setTeamId(team.getId());</span>
<span class="fc" id="L1857">                ms.setTeamName(team.getName());</span>
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">                ms.setOrgId(team.getOrg() == null ? null : team.getOrg().getId());</span>
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">                ms.setOrgName(team.getOrg() == null ? null : team.getOrg().getName());</span>
            }
<span class="fc" id="L1861">        } else {</span>
            // must be an HL7 message
<span class="fc" id="L1863">            Long orgId = message.getSource().getOrgId();</span>
<span class="fc" id="L1864">            Long teamId = message.getSource().getTeamId();</span>

<span class="fc bfc" id="L1866" title="All 2 branches covered.">            if (teamId != null) {</span>
<span class="fc" id="L1867">                Team team = teamRepository.getInstitute(teamId);</span>
<span class="pc bpc" id="L1868" title="1 of 2 branches missed.">                if (team != null) {</span>
<span class="fc" id="L1869">                    ms.setTeamId(team.getId());</span>
<span class="fc" id="L1870">                    ms.setTeamName(team.getName());</span>
                }
            }

<span class="pc bpc" id="L1874" title="1 of 2 branches missed.">            if (orgId != null) {</span>
<span class="fc" id="L1875">                orgRepository.getOrg(orgId).ifPresent(t -&gt; {</span>
<span class="fc" id="L1876">                    ms.setOrgId(t.getId());</span>
<span class="fc" id="L1877">                    ms.setOrgName(t.getName());</span>
<span class="fc" id="L1878">                });</span>
            }
        }

<span class="fc" id="L1882">        return ms;</span>
    }

    private List&lt;InboxConversationDTO&gt; getInboxConversationDTOList(@NotNull LoggedInEHRRequestContext requestContext, Long currentPersonId,
                                                                   Long accountId, List&lt;Encounter&gt; convList) {

        // temporary local cache; avoid repeated lookups of same users
<span class="fc" id="L1889">        Map&lt;String, PKBPerson&gt; personLookup = new HashMap&lt;&gt;();</span>

<span class="fc" id="L1891">        List&lt;InboxConversationDTO&gt; dtoList = new ArrayList&lt;&gt;();</span>
        InboxConversationDTO dto;
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        for (Encounter conv : convList) {</span>
<span class="fc" id="L1894">            dto = new InboxConversationDTO();</span>
<span class="fc" id="L1895">            dto.setConversationId(conv.getEncounterUniqueId());</span>
<span class="fc" id="L1896">            dto.setMessageCount(conv.getMessageCount());</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">            dto.setEncounterClass(conv.getEncounterClass() != null ? conv.getEncounterClass() : null);</span>

            // Drafts! If latest is a draft written by someone else, we need to
            // avoid it.
            // If there aren't any visible messages in the conversation, hide it
            // entirely (though
            // this will mean fewer results returned than requested here...
            // explain in UI?)
<span class="fc" id="L1905">            Message latestMessage = getLatestVisibleMessage(requestContext, conv,</span>
                    currentPersonId, accountId);
<span class="pc bpc" id="L1907" title="1 of 2 branches missed.">            if (latestMessage == null) {</span>
<span class="nc" id="L1908">                continue;</span>
            }

            // Set message inline content type -- is this still needed? ...what
            // about for other embeds?
<span class="fc bfc" id="L1913" title="All 2 branches covered.">            if (latestMessage.getContent().contains(&quot;[CALL=#]&quot;)) {</span>
<span class="fc" id="L1914">                latestMessage.setContent(INLINE_CONTENT_PATTERN.matcher(latestMessage.getContent()).replaceAll(Matcher.quoteReplacement(&quot;&quot;)));</span>
<span class="fc" id="L1915">                latestMessage.setInlineContentType(MSG_INLINE_CALL);</span>
            }

<span class="fc" id="L1918">            Long attachmentCount = chunkedDocManager.getAttachmentCount(latestMessage.getId());</span>
<span class="fc" id="L1919">            latestMessage.setAttachmentCount(attachmentCount);</span>
<span class="fc" id="L1920">            dto.setParticipants(conv.getParticipants());</span>
<span class="fc" id="L1921">            dto.setLatestMessage(latestMessage);</span>
<span class="fc" id="L1922">            dto.setLatestSender(pkbPersonDTOConverter.convert(getPersonOnce(personLookup, latestMessage.getSenderId())));</span>
<span class="fc" id="L1923">            dto.setPatient(pkbPersonDTOConverter.convert(getPersonOnce(personLookup, latestMessage.getPatientId())));</span>

            // obtain information about the sender of the original message in this thread
<span class="fc bfc" id="L1926" title="All 2 branches covered.">            if (conv.getMessageCount() == 1) {</span>
                // latestMessage is original message
<span class="fc" id="L1928">                dto.setOriginalMessage(latestMessage);</span>
<span class="fc" id="L1929">                dto.setOriginalSender(dto.getLatestSender());</span>
            } else {
                // we have to find the original message
<span class="fc" id="L1932">                Message originalMessage = null;</span>
<span class="fc bfc" id="L1933" title="All 2 branches covered.">                if (conv.getMenuDataType() == MenuDataType.message) {</span>
<span class="fc" id="L1934">                    originalMessage = getFirstMessageInConversation(</span>
                            requestContext,
                            accountId,
<span class="fc" id="L1937">                            conv.getEncounterUniqueId());</span>
                } else {
<span class="fc" id="L1939">                    originalMessage = getFirstEncounterInConversation(</span>
                            requestContext,
                            accountId,
<span class="fc" id="L1942">                            conv.getEncounterUniqueId());</span>
                }

<span class="pc bpc" id="L1945" title="1 of 2 branches missed.">                if (originalMessage == null) {</span>
<span class="nc" id="L1946">                    throw new IllegalStateException(&quot;We cannot find the original message that started this conversation.&quot;);</span>
                } else {
<span class="fc" id="L1948">                    dto.setOriginalMessage(originalMessage);</span>
<span class="fc" id="L1949">                    dto.setOriginalSender(pkbPersonDTOConverter.convert(getPersonOnce(personLookup, originalMessage.getSenderId())));</span>
                }
            }

            // We now set some more information for each of the original message sender
            // and latest message sender, encapsulated and flattened out into a DTO, for easy access
            // to display in the presentation layer.
<span class="fc" id="L1956">            dto.setLatestMessageSenderDetails(getMessageSenderDetails(requestContext, dto.getLatestSender(), dto.getLatestMessage()));</span>
<span class="fc" id="L1957">            dto.setOriginalMessageSenderDetails(getMessageSenderDetails(requestContext, dto.getOriginalSender(), dto.getOriginalMessage()));</span>

            // unfortunately here we need to do another query for all the encounters, and we dont even
            // know if this is an encounter or not
<span class="fc" id="L1961">            List&lt;EncounterEvent&gt; allVisibleEncounterEventMessages = getAllVisibleEncounterEventMessages(requestContext.withoutAccessLog(), accountId, conv.getEncounterUniqueId());</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">            for (EncounterEvent event : allVisibleEncounterEventMessages) {</span>
<span class="fc bfc" id="L1963" title="All 2 branches covered.">                if (event.getRequireGeneral()) {</span>
<span class="fc" id="L1964">                    dto.getOriginalMessage().getBaseFields().setGeneralHealthConsentRequired(true);</span>
                }
<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">                if (event.getRequireSocialCare()) {</span>
<span class="nc" id="L1967">                    dto.getOriginalMessage().getBaseFields().setSocialCareConsentRequired(true);</span>
                }
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">                if (event.getRequireMentalHealth()) {</span>
<span class="nc" id="L1970">                    dto.getOriginalMessage().getBaseFields().setMentalHealthConsentRequired(true);</span>
                }
<span class="fc bfc" id="L1972" title="All 2 branches covered.">                if (event.getRequireSexualHealth()) {</span>
<span class="fc" id="L1973">                    dto.getOriginalMessage().getBaseFields().setSexualHealthConsentRequired(true);</span>
                }
<span class="fc" id="L1975">            }</span>
<span class="fc" id="L1976">            dtoList.add(dto);</span>
<span class="fc" id="L1977">        }</span>

<span class="fc" id="L1979">        return dtoList;</span>
    }

    private List&lt;EncounterEvent&gt; getAllVisibleEncounterEventMessages(
            EHRRequestContext requestContext, Long accountId, UUID conversationId) {
        try {
            // when UI is encounter aware -- this method can take the data type, or split into two methods
<span class="fc" id="L1986">            EHRSearch&lt;EncounterEvent&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, EncounterEvent.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>
<span class="fc" id="L1987">            ehrSearch.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>
<span class="fc" id="L1988">            ehrSearch.addFilter(new PKBFilter(Message.ENCOUNTER_ID, PKBFilter.Operator.EQUAL, conversationId));</span>

            // exclude messages of type ENCOUNTER_DETAILS as these are system generated
<span class="fc" id="L1991">            ehrSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L1992">                    Message.MessageType.ENCOUNTER_DETAILS.toString()));</span>

<span class="fc" id="L1994">            return beanFactory.getEhrRemote().queryTypedData(ehrSearch, requestContext);</span>
<span class="nc" id="L1995">        } catch (Exception e) {</span>
<span class="nc" id="L1996">            throw new RuntimeException(&quot;Exception while getting messages&quot;, e);</span>
        }
    }

    private Message getFirstEncounterInConversation(@NotNull LoggedInEHRRequestContext requestContext,
                                                    Long accountId, UUID conversationId) {
        try {
            // this should become two methods, or pass in the data type
<span class="fc" id="L2004">            EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);
<span class="fc" id="L2006">            ehrSearch.addFilter(new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.EQUAL,</span>
                    conversationId));

            // we need to exclude ENCOUNTER_DETAILS messages from this query because
            // these are system generated messages and not visible to the end user

<span class="fc" id="L2012">            ehrSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L2013">                    Message.MessageType.ENCOUNTER_DETAILS.toString()));</span>

<span class="fc" id="L2015">            ehrSearch.setLatestPerTypeFilter(&quot;date01&quot;, &quot;uniqueId&quot;);</span>

<span class="fc" id="L2017">            ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Asc);</span>
<span class="fc" id="L2018">            ehrSearch.setResultsMaxReturned(1);</span>
<span class="fc" id="L2019">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>

<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">            if (ehrList.isEmpty()) {</span>
<span class="nc" id="L2022">                return null;</span>
            }

<span class="fc" id="L2025">            return populateMessage(requestContext, ehrList.get(0));</span>
<span class="nc" id="L2026">        } catch (Exception e) {</span>
<span class="nc" id="L2027">            throw new RuntimeException(</span>
                    &quot;Exception while getting first message in the conversation-&quot;
                            + conversationId,
                    e);
        }
    }

    /*
    Temporarily duplicated with the method in EHREncounterBean
    At some point, EHREncounterBean will be removed....
     */
    private Message populateMessage(EHRRequestContext requestContext, EHRData ehrData) {
<span class="fc" id="L2039">        Class mappedClass = MESSAGE_AND_ENCOUNTER_DATATYPE_DTO_MAP.get(ehrData.getDataType());</span>
<span class="fc" id="L2040">        Message message = (Message) beanFactory.getEhrRemote().populateDTO(ehrData, mappedClass, requestContext);</span>

        // there are cases where real strings are empty or null
<span class="fc bfc" id="L2043" title="All 2 branches covered.">        if (isNotEmpty(message.getMessageTypeId())) {</span>
<span class="fc" id="L2044">            message.setMessageType(Message.MessageType.valueOf(message.getMessageTypeId()));</span>
        }

        // debugging PHR-1665
<span class="fc bfc" id="L2048" title="All 2 branches covered.">        if (message.getContent() == null) {</span>
<span class="fc" id="L2049">            message.setContent(&quot;&quot;);</span>
<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">            if (ehrData.isDecrypted()) {</span>
<span class="nc" id="L2051">                LOGGER.warn(&quot;PHR-1665: read null content! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
            }
        }
<span class="fc bfc" id="L2054" title="All 2 branches covered.">        if (message.getSubject() == null) {</span>
<span class="fc" id="L2055">            message.setSubject(&quot;&quot;);</span>
<span class="pc bpc" id="L2056" title="1 of 2 branches missed.">            if (ehrData.isDecrypted()) {</span>
<span class="nc" id="L2057">                LOGGER.warn(&quot;PHR-1665: read null subject! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
            }
        }

<span class="fc" id="L2061">        return message;</span>
    }

    private PKBPerson getPersonOnce(Map&lt;String, PKBPerson&gt; cache,
                                    String personId) {
<span class="fc bfc" id="L2066" title="All 2 branches covered.">        if (StringUtils.isEmpty(personId)) {</span>
<span class="fc" id="L2067">            return null;</span>
        }

<span class="fc" id="L2070">        PKBPerson found = cache.get(personId);</span>
<span class="fc bfc" id="L2071" title="All 2 branches covered.">        if (found == null) {</span>
<span class="fc" id="L2072">            found = beanFactory.getPKBPersonBean().findPKBPerson(parseLong(personId)).getOrNull();</span>

<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">            if (found != null) {</span>
<span class="fc" id="L2075">                cache.put(personId, found); // cache for next lookup</span>
            }
        }
<span class="fc" id="L2078">        return found;</span>
    }

    private Message getLatestVisibleMessage(@NotNull LoggedInEHRRequestContext requestContext, Encounter conv,
                                            Long currentPersonId, Long accountId) {
        // Drafts! If this is a draft written by someone else, we need to avoid
        // it.
        // If there aren't any visible messages in the conversation, hide it
        // entirely (though
        // this will mean fewer results returned than requested here...)
<span class="fc" id="L2088">        Message latestMessage = conv.getLatestMessage();</span>

<span class="fc" id="L2090">        String authorId = latestMessage.getOnBehalfAuthorId();</span>
<span class="pc bpc" id="L2091" title="3 of 4 branches missed.">        if ((authorId == null) || authorId.isEmpty()) {</span>
<span class="fc" id="L2092">            authorId = latestMessage.getSenderId();</span>
        }

<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">        String currentPersonIdString = currentPersonId == null ? null : currentPersonId.toString();</span>
        // show draft messages to author only
<span class="pc bpc" id="L2097" title="1 of 4 branches missed.">        if ((latestMessage.getMessageStatus() != null) &amp;&amp; latestMessage.getMessageStatus() == MessageStatus.INDRAFT</span>
<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">                &amp;&amp; (!authorId.equals(currentPersonIdString))) {</span>
<span class="nc bnc" id="L2099" title="All 2 branches missed.">            if (conv.getMessageCount() == 1) {</span>
<span class="nc" id="L2100">                return null; // conv is ONLY an invisible draft</span>
            }

            // return second-to-last message (there will be only one draft per
            // conversation...)
<span class="nc" id="L2105">            List&lt;Message&gt; messages = getMessages(requestContext, accountId, 1, // we just want one</span>
<span class="nc" id="L2106">                    conv.getMessageCount().intValue() - 2, // second to last in conversation by timestamp asc</span>
<span class="nc" id="L2107">                    conv.getEncounterUniqueId());</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">            if (messages.isEmpty()) {</span>
<span class="nc" id="L2109">                LOGGER.error(&quot;null result getting 2nd-to-last message in conv {}&quot;, conv.getEncounterUniqueId());</span>
<span class="nc" id="L2110">                return null;</span>
            } else {
<span class="nc" id="L2112">                return messages.get(0);</span>
            }
        } else {
<span class="fc" id="L2115">            return latestMessage;</span>
        }
    }

    private List&lt;InboxConversationDTO&gt; getConversationListForInbox(LoggedInEHRRequestContext requestContext,
                                                                   Long accountId, int pageSize, int offset,
                                                                   String filterPatientId, Instant filterFromDate,
                                                                   Instant filterToDate, ConversationWorkflowFilterDTO conversationWorkflowFilterDTO) {
        try {
<span class="fc" id="L2124">            long currentPersonId = requestContext.getAccessingUserId();</span>

<span class="fc" id="L2126">            List&lt;Encounter&gt; convList = getConversationList(requestContext, currentPersonId,</span>
                    accountId, pageSize, offset, filterPatientId, filterFromDate, filterToDate,
                    conversationWorkflowFilterDTO);
<span class="fc bfc" id="L2129" title="All 2 branches covered.">            if (convList.isEmpty()) {</span>
<span class="fc" id="L2130">                return emptyList();</span>
            }

<span class="fc" id="L2133">            return getInboxConversationDTOList(requestContext, currentPersonId, accountId, convList);</span>
<span class="nc" id="L2134">        } catch (Exception e) {</span>
<span class="nc" id="L2135">            throw new RuntimeException(&quot;Exception while executing getConversationListForInbox&quot;, e);</span>
        }
    }

    /**
     * This is only used for marking the message as Read
     *
     * @return message Id
     * @
     */
    public Long saveMessage(EHRRequestContext requestContext, long accountId, Message message) {
        try {
<span class="fc bfc" id="L2147" title="All 2 branches covered.">            if (message.getEncounterClass() == null) {</span>
<span class="fc" id="L2148">                message.setEncounterClass(EncounterClass.VIRTUAL);</span>
            }

<span class="fc" id="L2151">            EHRData ehrData = populateEHRDataForSave(requestContext, accountId, message);</span>
<span class="fc" id="L2152">            return beanFactory.getEhrRemote().saveEHRData(requestContext, ehrData);</span>
<span class="nc" id="L2153">        } catch (Exception e) {</span>
<span class="nc" id="L2154">            throw new RuntimeException(&quot;Exception while saving message&quot;, e);</span>
        }
    }

    // Used by conversation feature from web app which does not call update on any message/encounter
    // so safe to add a uniqueId for each message &amp; set migration version
    private EHRData populateEHRDataForSave(EHRRequestContext requestContext, long accountId, Message message) {

<span class="fc" id="L2162">        ensureMessageUniqueIdPopulated(message);</span>

<span class="fc bfc" id="L2164" title="All 2 branches covered.">        if (message.getMessageType() == null) {</span>
<span class="fc" id="L2165">            message.setMessageTypeId(null);</span>
        }

        // debugging PHR-1665
<span class="pc bpc" id="L2169" title="1 of 2 branches missed.">        if (message.getContent() == null) {</span>
<span class="nc" id="L2170">            message.setContent(&quot;&quot;);</span>
<span class="nc" id="L2171">            LOGGER.warn(&quot;PHR-1665: writing null content! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
        }
<span class="pc bpc" id="L2173" title="1 of 2 branches missed.">        if (message.getSubject() == null) {</span>
<span class="nc" id="L2174">            message.setSubject(&quot;&quot;);</span>
<span class="nc" id="L2175">            LOGGER.warn(&quot;PHR-1665: writing null subject! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
        }

<span class="fc" id="L2178">        EHRData ehrData = beanFactory.getEhrRemote().populateEHRData(message, accountId, message.getDataType(), requestContext);</span>
<span class="fc" id="L2179">        ehrData.setMigrationVersion(DTOMapping.getMigrationVersionFor(message));</span>
<span class="fc" id="L2180">        return ehrData;</span>
    }

    private void ensureMessageUniqueIdPopulated(Message message) {
<span class="fc" id="L2184">        UUID existingUniqueId = message.getBaseFields().getUniqueId();</span>
<span class="pc bpc" id="L2185" title="1 of 2 branches missed.">        if (existingUniqueId == null) {</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">            if (config.isExceptionForNoUniqueIdInMessageEnabled()) {</span>
<span class="nc" id="L2187">                throw new RuntimeException(&quot;PHRZ-146: uniqueId not populated in message&quot;);</span>
            } else {
                //noinspection NewExceptionWithoutArguments
<span class="nc" id="L2190">                LOGGER.error(&quot;PHRZ-146: uniqueId not populated in message&quot;, FrameFilter.filter(new Exception().fillInStackTrace()));</span>
            }
<span class="nc" id="L2192">            message.getBaseFields().generateNewRandomUniqueId();</span>
        }
<span class="fc" id="L2194">    }</span>

    public Long copyMessage(@NotNull LoggedInEHRRequestContext requestContext, long receiverId, long receiverAccountId, Message message,
                            List&lt;Attachment&gt; attachments, DocumentsByIdAndAccount documentIdMap) {
        try {
<span class="fc" id="L2199">            LOGGER.info(&quot;copyMessage start for userId-{}&quot;, receiverId);</span>
            // on-behalf user not supported in save anymore
<span class="fc" id="L2201">            message.setOnBehalfAuthorId(null);</span>

<span class="fc" id="L2203">            EHRData ehrData = populateEHRDataForSave(requestContext, receiverAccountId, message);</span>
<span class="fc" id="L2204">            long messageCopyId = beanFactory.getEhrRemote().saveEHRData(requestContext, ehrData);</span>
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">            if (attachments != null) {</span>
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">                if (documentIdMap == null) {</span>
<span class="nc" id="L2207">                    copyAttachments(requestContext, receiverId, receiverAccountId, attachments, messageCopyId);</span>
                } else {
<span class="fc" id="L2209">                    copyAttachments(requestContext, receiverId, receiverAccountId, attachments, messageCopyId, documentIdMap);</span>
                }
            }

<span class="fc" id="L2213">            LOGGER.info(&quot;copyMessage end for userId-{}&quot;, receiverId);</span>

<span class="fc" id="L2215">            return messageCopyId;</span>
<span class="nc" id="L2216">        } catch (Exception e) {</span>
<span class="nc" id="L2217">            throw new RuntimeException(Thread.currentThread().getName()</span>
                    + &quot; Exception while copying message&quot;, e);
        }
    }

    private void copyAttachments(@NotNull LoggedInEHRRequestContext context, long currentPersonId, long accountId,
                                 List&lt;Attachment&gt; attachments, Long messageId) {
<span class="fc bfc" id="L2224" title="All 2 branches covered.">        for (Attachment attachment : attachments) {</span>
<span class="fc" id="L2225">            UUID docIdOfCopy = chunkedDocManager.copyDocument(context, attachment.getDocMetadataId(), currentPersonId, accountId);</span>
<span class="fc" id="L2226">            chunkedDocManager.createAttachment(messageId, docIdOfCopy, attachment, currentPersonId, accountId);</span>
<span class="fc" id="L2227">        }</span>
<span class="fc" id="L2228">    }</span>

    private void copyAttachments(@NotNull LoggedInEHRRequestContext context, long currentPersonId, long accountId,
                                 List&lt;Attachment&gt; attachments, Long messageId, DocumentsByIdAndAccount documentIdMap) {
<span class="fc bfc" id="L2232" title="All 2 branches covered.">        for (Attachment attachment : attachments) {</span>
<span class="fc" id="L2233">            Optional&lt;UUID&gt; maybeDocIdOfCopy = documentIdMap.get(attachment.getDocMetadataId(), accountId);</span>
<span class="fc" id="L2234">            UUID docIdOfCopy = maybeDocIdOfCopy.orElseGet(() -&gt; chunkedDocManager.copyDocument(context, attachment.getDocMetadataId(), currentPersonId, accountId));</span>
<span class="fc" id="L2235">            chunkedDocManager.createAttachment(messageId, docIdOfCopy, attachment, currentPersonId, accountId);</span>
<span class="fc" id="L2236">        }</span>
<span class="fc" id="L2237">    }</span>

    @NotNull Long saveSingleMessage(LoggedInEHRRequestContext requestContext, String receiverId, long recieverAccountId, Message message,
                                    @Nullable List&lt;Attachment&gt; attachments, @Nullable DocumentsByIdAndAccount documentIdMap) {
        try {
<span class="fc" id="L2242">            LOGGER.info(&quot;saveSingleMessage start for userId-{}&quot;, receiverId);</span>
<span class="fc" id="L2243">            Long messageId = saveSingleMessageNoSupportForCopyingAttachements(requestContext, recieverAccountId, receiverId, message);</span>

<span class="fc bfc" id="L2245" title="All 2 branches covered.">            if (attachments != null) {</span>
                // since the documents are chunked they need to be copied in
                // chunks for other participants
                // for composer the attachments are already stored in account

<span class="fc" id="L2250">                long currentUserId = requestContext.getAccessingUserId();</span>
<span class="fc bfc" id="L2251" title="All 2 branches covered.">                if (currentUserId == parseLong(receiverId)) {</span>
<span class="fc" id="L2252">                    addAttachments(currentUserId, recieverAccountId, attachments, messageId);</span>
                } else {
<span class="fc bfc" id="L2254" title="All 2 branches covered.">                    if (documentIdMap == null) {</span>
<span class="fc" id="L2255">                        copyAttachments(requestContext, currentUserId, recieverAccountId, attachments, messageId);</span>
                    } else {
<span class="fc" id="L2257">                        copyAttachments(requestContext, currentUserId, recieverAccountId, attachments, messageId, documentIdMap);</span>
                    }
                }
            }

<span class="fc" id="L2262">            LOGGER.info(&quot;saveSingleMessage end for userId-{}&quot;, receiverId);</span>

<span class="fc" id="L2264">            return messageId;</span>
<span class="nc" id="L2265">        } catch (Exception e) {</span>
<span class="nc" id="L2266">            throw new RuntimeException(Thread.currentThread().getName()</span>
                    + &quot; Exception while saving message&quot;, e);
        }
    }

    private List&lt;Either&lt;MessageServiceException, MessageDetails&gt;&gt; saveMessagesNoSupportForCopyingAttachmentsOrDrafts(
            List&lt;Pair&lt;MessageDetailsWithinContext, List&lt;Message&gt;&gt;&gt; contextAndMessagesList, Map&lt;Long, Long&gt; idToAccountIdMap) {

<span class="fc" id="L2274">        var ehrDataTuplesAsOneList = contextAndMessagesList.stream().map(</span>
                pair -&gt; {
<span class="fc" id="L2276">                    var messageDetailsWithinContext = pair.getKey();</span>
<span class="fc" id="L2277">                    var messages = pair.getValue();</span>
<span class="fc" id="L2278">                    List&lt;Tuple2&lt;EHRData, EHRRequestContext&gt;&gt; currentEhrDataTupleList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2279">                    messages.forEach(</span>
                            message -&gt; {
<span class="fc" id="L2281">                                EHRData ehrData = populateEHRDataForSave(messageDetailsWithinContext.getLoggedOutEHRRequestContext(),</span>
<span class="fc" id="L2282">                                        idToAccountIdMap.get(parseLong(message.getReceiverId())), message);</span>
<span class="fc" id="L2283">                                currentEhrDataTupleList.add(Tuple.of(ehrData, messageDetailsWithinContext.getLoggedOutEHRRequestContext()));</span>
<span class="fc" id="L2284">                            });</span>
<span class="fc" id="L2285">                    return currentEhrDataTupleList;</span>
                })
<span class="fc" id="L2287">                .flatMap(Collection::stream)</span>
<span class="fc" id="L2288">                .collect(toList());</span>

<span class="fc" id="L2290">        beanFactory.getEhrRemote().saveEHRDataList(ehrDataTuplesAsOneList);</span>

<span class="fc" id="L2292">        String success = &quot;succesfully saved &quot; + contextAndMessagesList.size() + &quot; messages in bulk: &quot; +</span>
<span class="fc" id="L2293">                contextAndMessagesList.stream().map(pair -&gt; {</span>
<span class="fc" id="L2294">                    var messageMetaData = pair.getKey().getMessageDetailsAndContent().getMessageDetails().getMetadata();</span>
<span class="fc" id="L2295">                    return &quot;from user&quot; + messageMetaData.getSenderId() + &quot; to user(s)&quot;</span>
<span class="fc" id="L2296">                            + String.join(&quot;, &quot;, messageMetaData.getParticipantIdList());</span>
<span class="fc" id="L2297">                }).collect(Collectors.joining(&quot;; &quot;));</span>
<span class="fc" id="L2298">        LOGGER.info(success);</span>

        // we managed to save them all, no error, so we take from the input
<span class="fc" id="L2301">        return contextAndMessagesList.stream()</span>
<span class="fc" id="L2302">                .map(sucessfulMessagePair -&gt; Either</span>
<span class="fc" id="L2303">                        .&lt;MessageServiceException, MessageDetails&gt; right(sucessfulMessagePair.getKey().getMessageDetailsAndContent().getMessageDetails()))</span>
<span class="fc" id="L2304">                .collect(toList());</span>
    }

    public long saveSingleMessageNoSupportForCopyingAttachements(EHRRequestContext requestContext, Long accountId, String receiverId, Message message) {
        try {
<span class="fc" id="L2309">            LOGGER.info(&quot;saveSingleMessageNoSupportForCopyingAttachements start for userId-{}&quot;, receiverId);</span>
            // on-behalf user not supported in save anymore
<span class="fc" id="L2311">            message.setOnBehalfAuthorId(null);</span>

<span class="fc bfc" id="L2313" title="All 2 branches covered.">            if (message.getEncounterClass() == null) {</span>
<span class="fc" id="L2314">                message.setEncounterClass(EncounterClass.VIRTUAL);</span>
            }

<span class="fc" id="L2317">            Long messageId = null;</span>

<span class="fc" id="L2319">            message.setReceiverId(receiverId);</span>
            // If status is in draft don't override it
<span class="fc" id="L2321">            MessageStatus messageStatus = message.getMessageStatus();</span>
            // Can override if message status is not null and not INDRAFT
<span class="fc bfc" id="L2323" title="All 4 branches covered.">            if (messageStatus == null || messageStatus != MessageStatus.INDRAFT) {</span>
<span class="fc bfc" id="L2324" title="All 2 branches covered.">                if (message.getSenderId().equals(receiverId)) {</span>
<span class="fc" id="L2325">                    message.setMessageStatus(MessageStatus.SENT);</span>
                } else {
<span class="fc" id="L2327">                    message.setMessageStatus(MessageStatus.UNREAD);</span>
                }
            } else { // status is MessageStatus.INDRAFT) {
                // draft messages will be stored in sender's account itself
                // so sent or received timestamps do not matter
<span class="fc" id="L2332">                message.setMessageTimestamp(dateTimeService.now());</span>
            }

<span class="fc" id="L2335">            ensureMessageUniqueIdPopulated(message);</span>

<span class="fc" id="L2337">            EHRData ehrData = populateEHRDataForSave(requestContext, accountId, message);</span>
<span class="fc" id="L2338">            messageId = beanFactory.getEhrRemote().saveEHRData(requestContext, ehrData);</span>

<span class="fc" id="L2340">            LOGGER.info(&quot;saveSingleMessageNoSupportForCopyingAttachements end for userId-{}&quot;, receiverId);</span>

<span class="fc" id="L2342">            return messageId;</span>
<span class="nc" id="L2343">        } catch (Exception e) {</span>
<span class="nc" id="L2344">            throw new RuntimeException(Thread.currentThread().getName()</span>
                    + &quot; Exception while saving message&quot;, e);
        }
    }
    
    private List&lt;Either&lt;MessageServiceException, MessageDetails&gt;&gt; saveMessagesNoSupportForCopyingAttachmentsOrDrafts(List&lt;Pair&lt;MessageDetailsWithinContext, Message&gt;&gt; contextAndMessageList) {
<span class="fc" id="L2350">        Collection&lt;Message&gt; messages = contextAndMessageList.stream().map(Pair::getValue).collect(toList());</span>
<span class="pc bpc" id="L2351" title="1 of 2 branches missed.">        if (messages.stream().map(Message::getAttachments).anyMatch(CollectionUtils::isNotEmpty)) {</span>
<span class="nc" id="L2352">            throw new RuntimeException(&quot;Some messages containing attachments are trying to be bulk saved with method not supporting attachment copy&quot;);</span>
        }

<span class="fc" id="L2355">        Map&lt;Long, Long&gt; idToAccountIdMap = getIdToDefaultAccountIdMap(messages);</span>
        
<span class="fc" id="L2357">        List&lt;Either&lt;MessageServiceException, Pair&lt;MessageDetailsWithinContext, List&lt;Message&gt;&gt;&gt;&gt; messagesToSend = </span>
<span class="fc" id="L2358">                contextAndMessageList.stream().map( pair -&gt; { </span>
<span class="fc" id="L2359">                    var messageDetailsWithinContext = pair.getKey();</span>
<span class="fc" id="L2360">                    var message = pair.getValue();</span>
<span class="fc" id="L2361">                    List&lt;String&gt; participants = message.getParticipants().stream().filter(StringUtils::isNotEmpty).collect(toList());</span>
            
<span class="fc" id="L2363">                    var maybeIssue = getOptionalIssueFromMissingValueInMap(participants.stream()</span>
<span class="fc" id="L2364">                            .map(Long::parseLong).collect(toList()), idToAccountIdMap, &quot;default account id&quot;);</span>
                    
<span class="pc bpc" id="L2366" title="1 of 2 branches missed.">                    if(maybeIssue.isEmpty()) {</span>
                        // We need to save a copy of the message for each participant
<span class="fc" id="L2368">                        List&lt;Message&gt; currentMessageList = participants.stream().map(</span>
                                receiverId -&gt; {
<span class="fc" id="L2370">                                    Message currentMessage = (Message) message.clone();</span>
<span class="fc" id="L2371">                                    currentMessage.setReceiverId(receiverId);</span>

                                    // on-behalf user not supported in save anymore
<span class="fc" id="L2374">                                    currentMessage.setOnBehalfAuthorId(null);</span>

<span class="pc bpc" id="L2376" title="1 of 2 branches missed.">                                    if (currentMessage.getEncounterClass() == null) {</span>
<span class="fc" id="L2377">                                        currentMessage.setEncounterClass(EncounterClass.VIRTUAL);</span>
                                    }

<span class="fc bfc" id="L2380" title="All 2 branches covered.">                                    if (currentMessage.getSenderId().equals(receiverId)) {</span>
<span class="fc" id="L2381">                                        currentMessage.setMessageStatus(MessageStatus.SENT);</span>
                                    } else {
<span class="fc" id="L2383">                                        currentMessage.setMessageStatus(MessageStatus.UNREAD);</span>
                                    }
<span class="fc" id="L2385">                                    ensureMessageUniqueIdPopulated(currentMessage);</span>
<span class="fc" id="L2386">                                    return currentMessage;</span>
<span class="fc" id="L2387">                                }).collect(toList());</span>
<span class="fc" id="L2388">                        return Either.&lt;MessageServiceException, Pair&lt;MessageDetailsWithinContext, List&lt;Message&gt;&gt;&gt;</span>
<span class="fc" id="L2389">                                    right(Pair.of(messageDetailsWithinContext, currentMessageList));</span>
                    } else {
<span class="nc" id="L2391">                        return Either.&lt;MessageServiceException, Pair&lt;MessageDetailsWithinContext, List&lt;Message&gt;&gt;&gt;</span>
<span class="nc" id="L2392">                                left(new InconsistentDataException(maybeIssue.get(), messageDetailsWithinContext.getMessageDetailsAndContent().getMessageDetails()));</span>
                    }
<span class="fc" id="L2394">        }).collect(toList());</span>

<span class="fc" id="L2396">        return ListTransform.transformByPredicateAndReturnInSameOrder(messagesToSend, Either::isRight,</span>
<span class="fc" id="L2397">                rights -&gt; saveMessagesNoSupportForCopyingAttachmentsOrDrafts(rights.stream()</span>
<span class="fc" id="L2398">                        .map(Either::get)</span>
<span class="fc" id="L2399">                        .collect(Collectors.toList()),</span>
                        idToAccountIdMap),
<span class="nc" id="L2401">                lefts -&gt; lefts.stream().map(l -&gt; Either.&lt;MessageServiceException, MessageDetails&gt;left(l.getLeft())).collect(Collectors.toList()));</span>
    }

    public Long saveMessageNoSupportForCopyingAttachments(EHRRequestContext requestContext, Message message) {

<span class="pc bpc" id="L2406" title="1 of 2 branches missed.">        if (CollectionUtils.isNotEmpty(message.getAttachments())) {</span>
<span class="nc" id="L2407">            throw new RuntimeException(format(&quot;Not saving attachments for message-%d encounter-%s&quot;,message.getId(),message.getEncounterUniqueId(),toString()));</span>
        }

        try {
<span class="fc" id="L2411">            Long senderMessageId = message.getId();</span>
<span class="fc" id="L2412">            Map&lt;Long, Long&gt; idToAccountIdMap = getIdToDefaultAccountIdMap(message);</span>

            // Save the in draft message only in sender's account
<span class="pc bpc" id="L2415" title="1 of 2 branches missed.">            if (MessageStatus.INDRAFT == message.getMessageStatus()) {</span>
<span class="nc" id="L2416">                senderMessageId = saveSingleMessageNoSupportForCopyingAttachements(requestContext,</span>
<span class="nc" id="L2417">                        idToAccountIdMap.get(parseLong(message.getSenderId())), message.getSenderId(), message);</span>
            } else {
                // We need to save the message for all participants
<span class="fc bfc" id="L2420" title="All 2 branches covered.">                for (String receiverId : message.getParticipants()) {</span>
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">                    if (!StringUtils.isEmpty(receiverId)) {</span>
<span class="fc bfc" id="L2422" title="All 2 branches covered.">                        if (receiverId.equals(message.getSenderId())) {</span>
                            // it was a draft for the sender, reuse the draft to save it as a real message
<span class="fc" id="L2424">                            message.setId(senderMessageId);</span>
<span class="fc" id="L2425">                            senderMessageId = saveSingleMessageNoSupportForCopyingAttachements(requestContext, idToAccountIdMap.get(parseLong(receiverId)), receiverId, message);</span>
                        } else {
                            // For other participants explicitly set the message id to null
<span class="fc" id="L2428">                            message.setId(null);</span>
<span class="fc" id="L2429">                            saveSingleMessageNoSupportForCopyingAttachements(requestContext, idToAccountIdMap.get(parseLong(receiverId)), receiverId, message);</span>
                        }
                    }
<span class="fc" id="L2432">                }</span>
            }
<span class="fc" id="L2434">            return senderMessageId;</span>
<span class="nc" id="L2435">        } catch (Exception e) {</span>
<span class="nc" id="L2436">            throw new RuntimeException(&quot;Exception while saving message&quot;, e);</span>
        }
    }

    private Map&lt;Long, Long&gt; getIdToDefaultAccountIdMap(Message message){
<span class="fc" id="L2441">        return beanFactory.getPKBPersonBean().getDefaultAccountIds(</span>
<span class="fc" id="L2442">                message.getParticipants().stream().map(Long::parseLong).collect(Collectors.toSet()));</span>
    }
    
    private Map&lt;Long, Long&gt; getIdToDefaultAccountIdMap(Collection&lt;Message&gt; messages) {
<span class="fc" id="L2446">        Set&lt;Long&gt; participantIds = messages.stream().map(Message::getParticipants)</span>
<span class="fc" id="L2447">                .flatMap(List::stream).map(Long::parseLong).collect(Collectors.toSet());</span>
<span class="fc" id="L2448">        return beanFactory.getPKBPersonBean().getDefaultAccountIds(participantIds);</span>
    }

    /**
     * Creates the attachment to the message document
     *
     * @
     */
    private void addAttachments(long currentPersonId, long accountId, List&lt;Attachment&gt; attachments, Long messageId) {
<span class="fc" id="L2457">        chunkedDocManager.createAttachments(messageId, attachments, currentPersonId, accountId);</span>
<span class="fc" id="L2458">    }</span>

    // Used by methods focusing on saving/updating Encounter (Not virtual conversation)
    // TODO merge the methods eventually
    private List&lt;EHRData&gt; populateEHRDataList(EHRRequestContext requestContext, UUID encounterUniqueId,
                                              List&lt;Message&gt; messagesOrNull, Long accountId) {
<span class="fc" id="L2464">        List&lt;EHRData&gt; ehrDataList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L2466" title="All 2 branches covered.">        for (Message message : messagesOrNull) {</span>
<span class="pc bpc" id="L2467" title="1 of 2 branches missed.">            if (message.getMessageType() != null) {</span>
<span class="fc" id="L2468">                message.setMessageTypeId(message.getMessageType().toString());</span>
            }
<span class="fc" id="L2470">            ensureMessageUniqueIdPopulated(message);</span>
<span class="fc" id="L2471">            message.setEncounterUniqueId(encounterUniqueId);</span>

            // debugging PHR-1665
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">            if (message.getContent() == null) {</span>
<span class="nc" id="L2475">                message.setContent(&quot;&quot;);</span>
<span class="nc" id="L2476">                LOGGER.warn(&quot;PHR-1665: writing null content! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
            }
<span class="pc bpc" id="L2478" title="1 of 2 branches missed.">            if (message.getSubject() == null) {</span>
<span class="nc" id="L2479">                message.setSubject(&quot;&quot;);</span>
<span class="nc" id="L2480">                LOGGER.warn(&quot;PHR-1665: writing null content! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
            }

<span class="fc" id="L2483">            EHRData ehrData = beanFactory.getEhrRemote().populateEHRData(message, accountId, message.getDataType(), requestContext);</span>
<span class="fc" id="L2484">            ehrDataList.add(ehrData);</span>
<span class="fc" id="L2485">        }</span>
<span class="fc" id="L2486">        return ehrDataList;</span>
    }

    public UUID updateEncounter(EHRRequestContext requestContext, String patientId, UUID encounterUniqueId,
                                List&lt;Message&gt; newMessagesOrNull) {
        try {
<span class="fc" id="L2492">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong(patientId));</span>
<span class="fc" id="L2493">            List&lt;EHRData&gt; ehrDataList = populateEHRDataList(requestContext, encounterUniqueId, newMessagesOrNull, accountId);</span>
<span class="fc" id="L2494">            beanFactory.getEhrRemote().saveEHRDataList(requestContext, ehrDataList);</span>
<span class="fc" id="L2495">            return encounterUniqueId;</span>
<span class="nc" id="L2496">        } catch (Exception e) {</span>
<span class="nc" id="L2497">            throw new RuntimeException(&quot;Exception while updating encounter&quot;, e);</span>
        }
    }

    public UUID saveEncounter(EHRRequestContext requestContext, String patientId, List&lt;Message&gt; messagesOrNull) {
        try {
<span class="fc" id="L2503">            UUID uniqueId = uuidProvider.randomUUID();</span>
<span class="fc" id="L2504">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong(patientId));</span>
<span class="fc" id="L2505">            List&lt;EHRData&gt; ehrDataList = populateEHRDataList(requestContext, uniqueId, messagesOrNull, accountId);</span>
<span class="fc" id="L2506">            beanFactory.getEhrRemote().saveEHRDataList(requestContext, ehrDataList);</span>
<span class="fc" id="L2507">            return uniqueId;</span>
<span class="nc" id="L2508">        } catch (Exception e) {</span>
<span class="nc" id="L2509">            throw new RuntimeException(&quot;Exception while saving encounter&quot;, e);</span>
        }
    }

    public Long saveMessageAsRead(EHRRequestContext requestContext, long accountId, Message message) {
<span class="fc" id="L2514">        message.setMessageStatus(MessageStatus.READ);</span>
<span class="fc" id="L2515">        message.setFirstReadTimestamp(dateTimeService.now());</span>
<span class="fc" id="L2516">        return saveMessage(requestContext, accountId, message);</span>
    }

    public @NotNull Long saveSingleMessage(LoggedInEHRRequestContext requestContext, String receiverId, long recieverAccountId, Message message,
                                           @Nullable List&lt;Attachment&gt; attachments) {
<span class="fc" id="L2521">        return saveSingleMessage(requestContext, receiverId, recieverAccountId, message, attachments, null);</span>
    }

    // Start a conversation with multiple participants
    // or reply to an existing conversation with an updated participant list
    public Long saveMessage(LoggedInEHRRequestContext requestContext, Message message, List&lt;Attachment&gt; attachments) {
        try {
            // Can be null or if INDRAFT then a valid id
<span class="fc" id="L2529">            Long senderMessageId = message.getId();</span>

            // Save the in draft message only in sender's account
<span class="fc bfc" id="L2532" title="All 2 branches covered.">            if (MessageStatus.INDRAFT == message.getMessageStatus()) {</span>
<span class="fc" id="L2533">                long senderDefaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong(message.getSenderId()));</span>
<span class="fc" id="L2534">                senderMessageId = saveSingleMessage(requestContext, message.getSenderId(), senderDefaultAccountId, message, attachments);</span>
<span class="fc" id="L2535">            } else {</span>
<span class="fc" id="L2536">                var participantDefaultAccountIds = getParticipantDefaultAccountIds(message.getParticipants());</span>
                // This is a sent message to save it for all recipients
<span class="fc bfc" id="L2538" title="All 2 branches covered.">                for (String receiverId : message.getParticipants()) {</span>
<span class="pc bpc" id="L2539" title="1 of 2 branches missed.">                    if (isNotBlank(receiverId)) {</span>
<span class="fc" id="L2540">                        long rid = parseLong(receiverId);</span>
<span class="pc bpc" id="L2541" title="1 of 2 branches missed.">                        if (receiverId.equals(message.getSenderId())) {</span>
                            // if this was indraft message then do not create a
                            // New message
                            // use the original message id becuase it will be
                            // set to null for others
<span class="nc" id="L2546">                            message.setId(senderMessageId);</span>
<span class="nc" id="L2547">                            senderMessageId = saveSingleMessage(requestContext, receiverId, participantDefaultAccountIds.get(rid), message, attachments);</span>
                        } else {
                            // For other participants explicitly set the message
                            // id to null
<span class="fc" id="L2551">                            message.setId(null);</span>
<span class="fc" id="L2552">                            saveSingleMessage(requestContext, receiverId, participantDefaultAccountIds.get(rid), message, attachments);</span>
                        }
                    }
<span class="fc" id="L2555">                }</span>
            }
<span class="fc" id="L2557">            return senderMessageId;</span>
<span class="nc" id="L2558">        } catch (Exception e) {</span>
<span class="nc" id="L2559">            throw new RuntimeException(&quot;Exception while saving message&quot;, e);</span>
        }
    }

    private Map&lt;Long, Long&gt; getParticipantDefaultAccountIds(List&lt;String&gt; participants) {
<span class="fc" id="L2564">        var participantIds = getParticipantStream(participants).collect(toSet());</span>
<span class="fc" id="L2565">        return beanFactory.getPKBPersonBean().getDefaultAccountIds(participantIds);</span>
    }

    private Stream&lt;Long&gt; getParticipantStream(List&lt;String&gt; participants) {
<span class="fc" id="L2569">        return participants</span>
<span class="fc" id="L2570">                .stream()</span>
<span class="fc" id="L2571">                .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L2572">                .map(Long::parseLong)</span>
<span class="fc" id="L2573">                .distinct();</span>
    }

    private List&lt;PKBPerson&gt; getParticipantsAsPersonList(List&lt;String&gt; participants, Map&lt;Long, PKBPerson&gt; personMap) {
<span class="pc bpc" id="L2577" title="1 of 2 branches missed.">        if (isEmpty(participants)) {</span>
<span class="nc" id="L2578">            return emptyList();</span>
        }
<span class="fc" id="L2580">        return getParticipantStream(participants)</span>
<span class="fc" id="L2581">                .map(personMap::get)</span>
<span class="fc" id="L2582">                .filter(Objects::nonNull)</span>
<span class="fc" id="L2583">                .sorted(Comparator.comparing(PKBPerson::getId))</span>
<span class="fc" id="L2584">                .collect(toList());</span>
    }

    /**
     * Sort: encounters are kept with given sorting. Messages are sorted old -&gt; new.
     *
     * @param messagesInEncounter This MAY be single latest message per encounter; sometimes all messages
     */
    private List&lt;Encounter&gt; populateEncounters(List&lt;Message&gt; messagesInEncounter, Map&lt;UUID, Long&gt; encounterToMessageCountMap, boolean fetchParticipants) throws ParseException {
<span class="fc" id="L2593">        List&lt;Encounter&gt; encounterList = new ArrayList&lt;&gt;(messagesInEncounter.size());</span>
<span class="fc" id="L2594">        List&lt;UUID&gt; encounterUniqueIdListSorted = new ArrayList&lt;&gt;(messagesInEncounter.size());</span>
<span class="fc" id="L2595">        Map&lt;UUID, Encounter&gt; uniqueIdToEncounterMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2596">        int index = 0;</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">        for (Message message : messagesInEncounter) {</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">            if (message.getMessageTypeId() != null) {</span>
<span class="fc" id="L2599">                message.setMessageType(Message.MessageType.valueOf(message.getMessageTypeId()));</span>
            }

<span class="fc" id="L2602">            UUID encounterUniqueId = message.getEncounterUniqueId();</span>
<span class="fc" id="L2603">            Encounter encounter = uniqueIdToEncounterMap.get(encounterUniqueId);</span>

<span class="fc bfc" id="L2605" title="All 2 branches covered.">            if (encounter == null) {</span>
<span class="fc" id="L2606">                encounter = new Encounter(new SourceDetails());</span>
<span class="fc" id="L2607">                uniqueIdToEncounterMap.put(encounterUniqueId, encounter);</span>
<span class="fc" id="L2608">                encounterUniqueIdListSorted.add(index++, encounterUniqueId);</span>
            }

<span class="fc" id="L2611">            encounter.setEncounterUniqueId(encounterUniqueId);</span>

<span class="pc bpc" id="L2613" title="1 of 4 branches missed.">            if ((message.getMessageType() == null) || message.getMessageType() != Message.MessageType.ENCOUNTER_DETAILS) {</span>
<span class="fc" id="L2614">                encounter.getMessages().add(message);</span>
            }

<span class="pc bpc" id="L2617" title="1 of 4 branches missed.">            if ((message.getMessageType() != null) &amp;&amp; message.getMessageType() == Message.MessageType.ENCOUNTER_DETAILS) {</span>
<span class="nc" id="L2618">                encounter.setEncounterDetailsMessage(message);</span>
            }

<span class="fc" id="L2621">        }</span>

<span class="fc" id="L2623">        index = 0;</span>
        // This way we will maintain the sorted order in which messages were fetched
<span class="fc bfc" id="L2625" title="All 2 branches covered.">        for (UUID uniqueId : encounterUniqueIdListSorted) {</span>
<span class="fc" id="L2626">            encounterList.add(index, uniqueIdToEncounterMap.get(uniqueId));</span>
<span class="fc" id="L2627">        }</span>


        // sort messages: oldest to newest (by persisted date)
<span class="fc bfc" id="L2631" title="All 2 branches covered.">        for (Encounter enc : encounterList) {</span>
<span class="fc" id="L2632">            enc.getMessages().sort(Comparator.comparing(m -&gt; m.getBaseFields().getPersistedDate()));</span>

            // set latest message, and set meta details in encounter based on that (or enc details msg if we have one)
<span class="pc bpc" id="L2635" title="1 of 2 branches missed.">            if (CollectionUtils.isNotEmpty(enc.getMessages())) {</span>
<span class="fc" id="L2636">                Message latestMessage = enc.getMessages().get(enc.getMessages().size() - 1);</span>
<span class="fc" id="L2637">                enc.setLatestMessage(latestMessage);</span>
            }
<span class="fc" id="L2639">        }</span>

<span class="fc" id="L2641">        var personMap = getParticipantMap(encounterList, enc -&gt; {</span>
<span class="fc" id="L2642">            var edm = getEncounterDetailMessage(enc);</span>
<span class="pc bpc" id="L2643" title="1 of 2 branches missed.">            if (edm == null) {</span>
<span class="nc" id="L2644">                return emptyList();</span>
            }
<span class="fc" id="L2646">            return edm.getParticipants();</span>
        });


        // sort messages: oldest to newest (by persisted date)
<span class="fc bfc" id="L2651" title="All 2 branches covered.">        for (Encounter enc : encounterList) {</span>
<span class="fc" id="L2652">            Message encounterDetailsMsg = getEncounterDetailMessage(enc);</span>
<span class="pc bpc" id="L2653" title="1 of 2 branches missed.">            if (encounterDetailsMsg != null) {</span>
<span class="fc" id="L2654">                enc.setParticipants(encounterDetailsMsg.getParticipants());</span>
<span class="pc bpc" id="L2655" title="1 of 4 branches missed.">                if (fetchParticipants &amp;&amp; (encounterDetailsMsg.getParticipants() != null)) {</span>
<span class="fc" id="L2656">                    var participantList = getParticipantsAsPersonList(encounterDetailsMsg.getParticipants(), personMap);</span>
<span class="fc" id="L2657">                    enc.setParticipantsPKB(participantList);</span>
                }
<span class="fc" id="L2659">                enc.setParticipantsNonPKB(encounterDetailsMsg.getParticipantsNonPKB());</span>
<span class="fc" id="L2660">                enc.setStartDate(encounterDetailsMsg.getStartDate());</span>
<span class="fc" id="L2661">                enc.setEndDate(encounterDetailsMsg.getEndDate());</span>
<span class="fc" id="L2662">                enc.setEncounterStatus(encounterDetailsMsg.getEncounterStatus());</span>
<span class="fc" id="L2663">                enc.setEncounterClass(encounterDetailsMsg.getEncounterClass());</span>
<span class="fc" id="L2664">                enc.getBaseFields().setEnteredDate(encounterDetailsMsg.getBaseFields().getEnteredDate());</span>
<span class="fc" id="L2665">                enc.getBaseFields().setPersistedDate(encounterDetailsMsg.getBaseFields().getPersistedDate());</span>
<span class="fc" id="L2666">                enc.getBaseFields().setUniqueId(encounterDetailsMsg.getBaseFields().getUniqueId());</span>

<span class="fc" id="L2668">                encounterDetailsMsg.getBaseFields().copyConsentFlags(enc.getBaseFields());</span>

<span class="fc" id="L2670">                enc.setAboutPatientId(encounterDetailsMsg.getPatientId());</span>
<span class="fc" id="L2671">                enc.setIndication(encounterDetailsMsg.getIndication());</span>
<span class="fc" id="L2672">                enc.setExternalMessageId(encounterDetailsMsg.getExternalMessageId());</span>
<span class="fc" id="L2673">                enc.setExternalEncounterId(encounterDetailsMsg.getExternalEncounterId());</span>
<span class="fc" id="L2674">                enc.setReasonCode(encounterDetailsMsg.getReasonCode());</span>
<span class="fc" id="L2675">                enc.setId(encounterDetailsMsg.getId());</span>
<span class="fc" id="L2676">                enc.getSource().setRoute(encounterDetailsMsg.getSource().getRoute());</span>

<span class="fc bfc" id="L2678" title="All 2 branches covered.">                if (encounterToMessageCountMap != null) {</span>
<span class="fc" id="L2679">                    enc.setMessageCount(encounterToMessageCountMap.get(enc.getEncounterUniqueId()));</span>
                }
            }
<span class="fc" id="L2682">        }</span>

<span class="fc" id="L2684">        return encounterList;</span>
    }

    private Map&lt;Long, PKBPerson&gt; getParticipantMap(List&lt;Encounter&gt; encounterList, Function&lt;Encounter, List&lt;String&gt;&gt; participantListProvider) {
<span class="pc bpc" id="L2688" title="1 of 2 branches missed.">        if (isEmpty(encounterList)) {</span>
<span class="nc" id="L2689">            return emptyMap();</span>
        }
<span class="fc" id="L2691">        var participantIds = encounterList.stream()</span>
<span class="fc" id="L2692">                .map(participantListProvider)</span>
<span class="fc" id="L2693">                .filter(CollectionUtils::isNotEmpty)</span>
<span class="fc" id="L2694">                .flatMap(Collection::stream)</span>
<span class="fc" id="L2695">                .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L2696">                .map(Long::parseLong)</span>
<span class="fc" id="L2697">                .collect(toSet());</span>

<span class="fc" id="L2699">        return beanFactory.getPKBPersonBean().findPKBPersonMap(participantIds);</span>
    }

    private Message getEncounterDetailMessage(Encounter enc) {
<span class="pc bpc" id="L2703" title="1 of 2 branches missed.">        return enc.getEncounterDetailsMessage() != null ? enc.getEncounterDetailsMessage() : enc.getLatestMessage();</span>
    }

    private List&lt;Encounter&gt; getAllEncounters(@NotNull LoggedInEHRRequestContext requestContext, String patientId, Instant updatedSince,
                                             boolean fetchMessages, List&lt;Long&gt; codeIdsOrNull, Set&lt;EncounterClass&gt; encounterClassFilters) {
        try {

<span class="fc" id="L2710">            List&lt;Encounter&gt; encounters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2711">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong(patientId));</span>

<span class="fc" id="L2713">            doSyncUploadedData(requestContext, accountId);</span>

<span class="pc bpc" id="L2715" title="1 of 4 branches missed.">            if (codeIdsOrNull != null &amp;&amp; codeIdsOrNull.isEmpty()) {</span>
                // return empty list
<span class="nc" id="L2717">                return new ArrayList&lt;&gt;();</span>
            }

<span class="fc" id="L2720">            EHRSearch&lt;Message&gt; ehrSearchMsg = new EHRSearch&lt;&gt;(Optional.ofNullable(accountId)</span>
<span class="pc" id="L2721">                    .orElseThrow(() -&gt; new IllegalStateException(&quot;Missing default account id&quot;)),</span>
                    Message.class,
                    Message.MS_PATH_MESSAGE);

<span class="fc bfc" id="L2725" title="All 2 branches covered.">            if (codeIdsOrNull != null) {</span>
<span class="fc" id="L2726">                ehrSearchMsg.addFilter(new PKBFilter(ENCOUNTER_REASON_CODE_ID, PKBFilter.Operator.IN, codeIdsOrNull));</span>
            }

<span class="pc bpc" id="L2729" title="1 of 2 branches missed.">            if (updatedSince != null) {</span>
<span class="nc" id="L2730">                ehrSearchMsg.addFilter(new PKBFilter(EHRData.ENTERED_DATE, PKBFilter.Operator.GREATER, updatedSince));</span>
            }

<span class="fc" id="L2733">            ehrSearchMsg.setOrderBy(&quot;persistedDate&quot;, EHRSearch.OrderByDirection.Desc);</span>

<span class="pc bpc" id="L2735" title="1 of 2 branches missed.">            if (CollectionUtils.isNotEmpty(encounterClassFilters)) {</span>

<span class="nc" id="L2737">                List&lt;String&gt; filters = encounterClassFilters.stream().map(EncounterClass::toString).collect(toList());</span>

<span class="nc" id="L2739">                ehrSearchMsg.addFilter(new PKBFilter(&quot;string09&quot;, PKBFilter.Operator.IN, filters));</span>

            }
            // if messages are not needed only fetch latest by date
<span class="pc bpc" id="L2743" title="1 of 2 branches missed.">            if (fetchMessages) {</span>
<span class="fc" id="L2744">                ehrSearchMsg.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID); // Latest version of each message in the encounter</span>
            } else {
<span class="nc" id="L2746">                ehrSearchMsg.setLatestPerTypeFilter(EHRData.ENTERED_DATE, Message.ENCOUNTER_UNIQUE_ID_COLUMN); // Latest message per encounter</span>
            }

            // separate search for encounters; copy filters &amp; limits etc. from the main search
<span class="fc" id="L2750">            EHRSearch&lt;EncounterEvent&gt; ehrSearchEncEvent = new EHRSearch&lt;&gt;(ehrSearchMsg, EncounterEvent.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>

<span class="fc" id="L2752">            List&lt;EHRData&gt; ehrDataList = beanFactory.getEhrRemote().queryAndDecryptEHRData(newArrayList(ehrSearchMsg, ehrSearchEncEvent), requestContext);</span>

<span class="fc" id="L2754">            List&lt;Message&gt; messages = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2755" title="All 2 branches covered.">            if (CollectionUtils.isNotEmpty(ehrDataList)) {</span>
<span class="fc" id="L2756">                messages = populateMessagesAndEncounterEvents(requestContext, ehrDataList);</span>
            }

<span class="fc" id="L2759">            List&lt;UUID&gt; encounterUniqueIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2760">            Map&lt;Long, List&lt;Attachment&gt;&gt; attachmentMap = getAttachments(messages.stream().map(Message::getId).collect(toList()));</span>
<span class="fc bfc" id="L2761" title="All 2 branches covered.">            for (Message message : messages) {</span>
<span class="fc" id="L2762">                encounterUniqueIds.add(message.getEncounterUniqueId());</span>
<span class="fc" id="L2763">                message.setAttachments(attachmentMap.getOrDefault(message.getId(), emptyList()));</span>
<span class="fc" id="L2764">            }</span>
<span class="fc bfc" id="L2765" title="All 2 branches covered.">            if (CollectionUtils.isNotEmpty(encounterUniqueIds)) {</span>
<span class="fc" id="L2766">                Map&lt;UUID, Long&gt; encounterToCountMap = getEncounterToMessageCountMap(accountId,</span>
                        encounterUniqueIds, requestContext);

<span class="fc" id="L2769">                encounters = populateEncounters(messages, encounterToCountMap, true /*fetchParticipants*/);</span>
            }
<span class="fc" id="L2771">            return encounters;</span>
<span class="nc" id="L2772">        } catch (Exception e) {</span>
<span class="nc" id="L2773">            throw new RuntimeException(e);</span>
        }
    }

    private List&lt;Message&gt; populateMessagesAndEncounterEvents(EHRRequestContext requestContext, List&lt;EHRData&gt; ehrList) {

<span class="fc" id="L2779">        List&lt;Message&gt; messages = populateMessageAndEncounterEventDTOs(requestContext, ehrList);</span>
<span class="fc bfc" id="L2780" title="All 2 branches covered.">        for (Message message : messages) {</span>
            // there are cases where real strings are empty or null
<span class="fc bfc" id="L2782" title="All 2 branches covered.">            if (StringUtils.isNotEmpty(message.getMessageTypeId())) {</span>
<span class="fc" id="L2783">                message.setMessageType(Message.MessageType.valueOf(message.getMessageTypeId()));</span>
            }

            // debugging PHR-1665
<span class="fc bfc" id="L2787" title="All 2 branches covered.">            if (message.getContent() == null) {</span>
<span class="fc" id="L2788">                message.setContent(&quot;&quot;);</span>
<span class="fc" id="L2789">                LOGGER.warn(&quot;PHR-1665: read null content! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
            }
<span class="fc bfc" id="L2791" title="All 2 branches covered.">            if (message.getSubject() == null) {</span>
<span class="fc" id="L2792">                message.setSubject(&quot;&quot;);</span>
<span class="fc" id="L2793">                LOGGER.warn(&quot;PHR-1665: read null subject! msg {}/{}/{}&quot;, message.getId(), message.getEncounterUniqueId(), message.getMessageTimestamp());</span>
            }
<span class="fc" id="L2795">        }</span>
<span class="fc" id="L2796">        return messages;</span>
    }

    private List&lt;Message&gt; populateMessageAndEncounterEventDTOs(EHRRequestContext requestContext, List&lt;EHRData&gt; data) {
<span class="fc" id="L2800">        List&lt;IBaseDTO&gt; baseDtos = populateDTOsMultipleDataTypes(requestContext, data, MESSAGE_AND_ENCOUNTER_DATATYPE_DTO_MAP);</span>
<span class="fc" id="L2801">        return baseDtos.stream()</span>
<span class="fc" id="L2802">                .map(b -&gt; (Message) b)</span>
<span class="fc" id="L2803">                .collect(toList());</span>
    }

    private List&lt;IBaseDTO&gt; populateDTOsMultipleDataTypes(EHRRequestContext requestContext, List&lt;EHRData&gt; data, Map&lt;MenuDataType, Class&gt; dataTypeToClass) {
        // convert in lists grouped by data type / class
<span class="fc" id="L2808">        Map&lt;MenuDataType, List&lt;EHRData&gt;&gt; grouped = data.stream().collect(groupingBy(EHRData::getDataType));</span>
<span class="fc" id="L2809">        Map&lt;Long, IBaseDTO&gt; dtosById = new HashMap&lt;&gt;(data.size());</span>
<span class="fc bfc" id="L2810" title="All 2 branches covered.">        for (Map.Entry&lt;MenuDataType, List&lt;EHRData&gt;&gt; group : grouped.entrySet()) {</span>
<span class="fc" id="L2811">            Class mappedClass = dataTypeToClass.get(group.getKey());</span>
<span class="fc" id="L2812">            List&lt;IBaseDTO&gt; dtoList = (List&lt;IBaseDTO&gt;) beanFactory.getEhrRemote().populateDTOList(group.getValue(), mappedClass, requestContext);</span>
<span class="fc" id="L2813">            dtoList.forEach(d -&gt; dtosById.put(d.getId(), d));</span>
<span class="fc" id="L2814">        }</span>

        // return DTOs in the same order as the orig EHRData list
<span class="fc" id="L2817">        return data.stream()</span>
<span class="fc" id="L2818">                .map(e -&gt; dtosById.get(e.getId()))</span>
<span class="fc" id="L2819">                .collect(toList());</span>
    }

    public List&lt;Message&gt; getMessages(@NotNull LoggedInEHRRequestContext requestContext, Long accountId,
                                     int pageSize, int offset, UUID conversationId) {
        try {
            // when UI is encounter aware -- this method can take the data type, or split into two methods
<span class="fc" id="L2826">            EHRSearch ehrMessageSearch = new EHRSearch&lt;&gt;(accountId, Message.class, Message.MS_PATH_MESSAGE);</span>
<span class="fc" id="L2827">            ehrMessageSearch.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>
<span class="fc" id="L2828">            ehrMessageSearch.addFilter(new PKBFilter(Message.ENCOUNTER_ID, PKBFilter.Operator.EQUAL, conversationId));</span>

            // exclude messages of type ENCOUNTER_DETAILS as these are system generated
<span class="fc" id="L2831">            ehrMessageSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, PKBFilter.Operator.NOT_EQUAL_OR_NULL,</span>
<span class="fc" id="L2832">                    Message.MessageType.ENCOUNTER_DETAILS.toString()));</span>

            // if user not in own account then exclude draft messages
<span class="fc bfc" id="L2835" title="All 2 branches covered.">            if (!requestContext.isUserInOwnAccount()) {</span>
<span class="fc" id="L2836">                ehrMessageSearch.addFilter(new PKBFilter(&quot;string04&quot;, PKBFilter.Operator.NOT_EQUAL_OR_NULL, &quot;INDRAFT&quot;));</span>
            }

<span class="fc" id="L2839">            ehrMessageSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Asc);</span>
<span class="fc" id="L2840">            ehrMessageSearch.setRequestContext(requestContext.withConsentStatus(requestContext.getConsentStatus().withRequired(false)));</span>

<span class="fc" id="L2842">            EHRSearch&lt;EncounterEvent&gt; ehrEncounterEventSearch = new EHRSearch&lt;&gt;(ehrMessageSearch, EncounterEvent.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>
<span class="fc" id="L2843">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(newArrayList(ehrMessageSearch, ehrEncounterEventSearch), requestContext, pageSize, offset);</span>
<span class="fc" id="L2844">            List&lt;Message&gt; messages = populateMessagesAndEncounterEvents(requestContext, ehrList);</span>

<span class="fc" id="L2846">            Map&lt;Long, String&gt; failedReceiversMap = getFailedReceivers(requestContext,</span>
                    accountId, conversationId);
<span class="fc" id="L2848">            populateAttachmentsAndFailedReceivers(messages, failedReceiversMap);</span>
<span class="fc" id="L2849">            return messages;</span>
<span class="nc" id="L2850">        } catch (Exception e) {</span>
<span class="nc" id="L2851">            throw new RuntimeException(&quot;Exception while getting messages&quot;, e);</span>
        }
    }

    // Only used to populate messages that have already been filtered on
    // privateFlag
    private Map&lt;Long, String&gt; getFailedReceivers(@NotNull LoggedInEHRRequestContext requestContext, Long accountId,
                                                 UUID conversationId) {
<span class="fc" id="L2859">        EHRSearch&lt;FailedMessageDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, FailedMessageDTO.class,</span>
                FailedMessageDTO.MS_PATH);
<span class="fc" id="L2861">        ehrSearch.addFilter(new PKBFilter(&quot;conversationId&quot;, PKBFilter.Operator.EQUAL, conversationId));</span>
<span class="fc" id="L2862">        List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>
<span class="fc" id="L2863">        List&lt;FailedMessageDTO&gt; failedMessages = beanFactory.getEhrRemote().populateDTOList(ehrList, FailedMessageDTO.class, requestContext);</span>

<span class="fc" id="L2865">        return gatherFailedMessages(failedMessages);</span>
    }

    private void populateAttachmentsAndFailedReceivers(List&lt;Message&gt; messages, Map&lt;Long, String&gt; failedReceiversMap)
            throws ParseException {
<span class="fc" id="L2870">        Map&lt;Long, List&lt;Attachment&gt;&gt; attachmentMap = getAttachments(messages.stream().map(Message::getId).collect(toList()));</span>
<span class="fc bfc" id="L2871" title="All 2 branches covered.">        for (Message message : messages) {</span>
<span class="fc" id="L2872">            message.setFailedReceivers(CSVtoList(failedReceiversMap</span>
<span class="fc" id="L2873">                    .get(message.getId())));</span>
<span class="fc" id="L2874">            List&lt;Attachment&gt; attachments = attachmentMap.get(message.getId());</span>
<span class="fc bfc" id="L2875" title="All 2 branches covered.">            if (isEmpty(attachments)) {</span>
<span class="fc" id="L2876">                message.setAttachmentCount(0L);</span>
            } else {
<span class="fc" id="L2878">                message.setAttachments(attachments);</span>
<span class="fc" id="L2879">                message.setAttachmentCount((long) attachments.size());</span>
            }
<span class="fc" id="L2881">        }</span>
<span class="fc" id="L2882">    }</span>

    private List&lt;String&gt; CSVtoList(String csv) {
<span class="pc bpc" id="L2885" title="1 of 2 branches missed.">        if (csv == null) {</span>
<span class="fc" id="L2886">            return null;</span>
        }
<span class="nc bnc" id="L2888" title="All 2 branches missed.">        if (csv.isEmpty()) {</span>
<span class="nc" id="L2889">            return new LinkedList&lt;&gt;();</span>
        }
<span class="nc" id="L2891">        return new LinkedList&lt;&gt;(Arrays.asList(csv.split(&quot;,&quot;)));</span>
    }

    private Map&lt;Long, String&gt; gatherFailedMessages(List&lt;FailedMessageDTO&gt; failedMessages) {
        Long messageId;
        String failedReceivers;
        String receiverId;
<span class="fc" id="L2898">        Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L2900" title="1 of 2 branches missed.">        for (FailedMessageDTO failedMessage : failedMessages) {</span>
<span class="nc" id="L2901">            messageId = failedMessage.getMessageId();</span>
<span class="nc" id="L2902">            failedReceivers = map.get(messageId);</span>
<span class="nc" id="L2903">            receiverId = failedMessage.getReceiverId();</span>
<span class="nc bnc" id="L2904" title="All 2 branches missed.">            if (failedReceivers == null) {</span>
<span class="nc" id="L2905">                failedReceivers = receiverId;</span>
            } else {
<span class="nc" id="L2907">                failedReceivers = failedReceivers + &quot;,&quot; + receiverId;</span>
            }
<span class="nc" id="L2909">            map.put(messageId, failedReceivers);</span>
<span class="nc" id="L2910">        }</span>

<span class="fc" id="L2912">        return map;</span>
    }

    private List&lt;Message&gt; getMessagesInConversations(@NotNull LoggedInEHRRequestContext requestContext, Long userId,
                                                     Long accountId, List&lt;UUID&gt; conversationIds) {
        try {
<span class="fc" id="L2918">            EHRSearch&lt;?&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);
<span class="fc" id="L2920">            ehrSearch.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>
<span class="fc" id="L2921">            ehrSearch.addFilter(new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.IN, conversationIds));</span>

<span class="fc" id="L2923">            var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
<span class="pc bpc" id="L2924" title="1 of 2 branches missed.">            if (!Objects.equals(defaultAccountId, accountId)) {</span>
<span class="nc" id="L2925">                ehrSearch.addFilter(new PKBFilter(&quot;boolean01&quot;, PKBFilter.Operator.FALSE_OR_IS_NULL, null));</span>
            }

<span class="fc" id="L2928">            ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Asc);</span>
<span class="fc" id="L2929">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>
<span class="fc" id="L2930">            List&lt;Message&gt; messages = populateMessagesAndEncounterEvents(requestContext, ehrList);</span>

<span class="fc" id="L2932">            Map&lt;Long, String&gt; failedReceiversMap = getFailedReceivers(requestContext, accountId, conversationIds);</span>
<span class="fc" id="L2933">            populateAttachmentsAndFailedReceivers(messages, failedReceiversMap);</span>
<span class="fc" id="L2934">            return messages;</span>
<span class="nc" id="L2935">        } catch (Exception e) {</span>
<span class="nc" id="L2936">            throw new RuntimeException(&quot;Exception while getting messages&quot;, e);</span>
        }
    }

    // Only used to populate messages that have already been filtered on
    // privateFlag
    private Map&lt;Long, String&gt; getFailedReceivers(@NotNull LoggedInEHRRequestContext requestContext, Long accountId,
                                                 List&lt;UUID&gt; conversationIds) {

<span class="fc" id="L2945">        EHRSearch&lt;FailedMessageDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, FailedMessageDTO.class, Allergy.MS_PATH);</span>
<span class="fc" id="L2946">        ehrSearch.addFilter(new PKBFilter(&quot;conversationId&quot;, PKBFilter.Operator.IN, conversationIds));</span>
<span class="fc" id="L2947">        List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>
<span class="fc" id="L2948">        List&lt;FailedMessageDTO&gt; failedMessages = beanFactory.getEhrRemote().populateDTOList(ehrList, FailedMessageDTO.class, requestContext);</span>

<span class="fc" id="L2950">        return gatherFailedMessages(failedMessages);</span>
    }

    private List&lt;Encounter&gt; getConversationList(@NotNull LoggedInEHRRequestContext requestContext, Long userId,
                                                Long accountId, int pageSize, int offset, String filterPatientId,
                                                Instant filterFromDate, Instant filterToDate,
                                                ConversationWorkflowFilterDTO conversationWorkflowFilterDTO) {
        try {
            // a little timing -- debugging 2016-08-19
<span class="fc" id="L2959">            StringBuilder logSb = new StringBuilder(&quot;TIMING: getConversationList() &quot;).append(userId).append(&quot;/&quot;).append(pageSize);</span>
<span class="fc" id="L2960">            long startMillis = System.currentTimeMillis();</span>

<span class="fc" id="L2962">            ArrayList&lt;EHRSearch&lt;?&gt;&gt; convListSearches = getConversationListSearches(requestContext, userId, accountId, filterPatientId, filterFromDate, filterToDate,</span>
                    conversationWorkflowFilterDTO);
<span class="fc" id="L2964">            List&lt;EHRData&gt; allLatest = beanFactory.getEhrRemote().queryAndDecryptEHRData(convListSearches, requestContext, pageSize, offset);</span>
<span class="fc bfc" id="L2965" title="All 2 branches covered.">            if (isEmpty(allLatest)) {</span>
<span class="fc" id="L2966">                return new ArrayList&lt;&gt;();</span>
            }

<span class="fc" id="L2969">            List&lt;Message&gt; lastMessages = populateMessagesAndEncounterEvents(requestContext, allLatest);</span>
<span class="fc" id="L2970">            logSb.append(String.format(&quot;, populatedMessages %s&quot;, System.currentTimeMillis() - startMillis));</span>
<span class="pc bpc" id="L2971" title="1 of 2 branches missed.">            if (isEmpty(lastMessages)) {</span>
<span class="nc" id="L2972">                return new ArrayList&lt;&gt;();</span>
            }

<span class="fc" id="L2975">            List&lt;UUID&gt; conversationIds = lastMessages.stream().map(Message::getEncounterUniqueId).collect(toList());</span>
<span class="fc" id="L2976">            Map&lt;UUID, Long&gt; conversationToCountMap = getEncounterToMessageCountMap(</span>
<span class="fc" id="L2977">                    accountId, conversationIds, requestContext.withoutAccessLog());</span>
<span class="fc" id="L2978">            logSb.append(String.format(&quot;, got count map %s&quot;, System.currentTimeMillis() - startMillis));</span>
<span class="fc" id="L2979">            List&lt;Encounter&gt; encounterList = populateAndChainConversations(lastMessages, conversationToCountMap);</span>
<span class="fc" id="L2980">            logSb.append(String.format(&quot;, chained convos %s&quot;, System.currentTimeMillis() - startMillis));</span>
<span class="fc" id="L2981">            LOGGER.warn(logSb.toString());</span>

<span class="fc" id="L2983">            return encounterList;</span>
<span class="nc" id="L2984">        } catch (Exception e) {</span>
<span class="nc" id="L2985">            throw new RuntimeException(</span>
                    &quot;Exception while getting conversation list&quot;, e);
        }
    }

    private List&lt;Encounter&gt; populateAndChainConversations(
            List&lt;Message&gt; latestMessagesInConversation,
            Map&lt;UUID, Long&gt; conversationToMessageCountMap)
            throws ParseException {
<span class="fc" id="L2994">        List&lt;Encounter&gt; conversationlist = new ArrayList&lt;&gt;();</span>
        Encounter conversation;
<span class="fc" id="L2996">        UUID prevId = null;</span>
<span class="fc" id="L2997">        UUID currId = null;</span>
<span class="fc" id="L2998">        int index = 0;</span>
<span class="fc" id="L2999">        int prevIndex = -1;</span>
<span class="fc bfc" id="L3000" title="All 2 branches covered.">        for (Message message : latestMessagesInConversation) {</span>
<span class="fc" id="L3001">            currId = message.getEncounterUniqueId();</span>
<span class="fc" id="L3002">            conversation = new Encounter(message.getSource());</span>
<span class="fc" id="L3003">            conversation.setLatestMessage(message);</span>
<span class="fc" id="L3004">            conversation.setEncounterUniqueId(currId);</span>
<span class="fc" id="L3005">            conversation.setMenuDataType(message.getDataType());</span>
<span class="fc" id="L3006">            Long countFromQuery = conversationToMessageCountMap.get(currId);</span>
<span class="pc bpc" id="L3007" title="1 of 2 branches missed.">            if (countFromQuery != null) {</span>
<span class="fc" id="L3008">                conversation.setMessageCount(countFromQuery);</span>
            } else {
<span class="nc" id="L3010">                LOGGER.error(&quot;Message count query failed! null count for uniqueId {}&quot;, currId);</span>
<span class="nc" id="L3011">                conversation.setMessageCount(1L);</span>
            }
<span class="fc" id="L3013">            conversation.setParticipants(message.getParticipants());</span>
<span class="fc" id="L3014">            conversation.setEncounterClass(message.getEncounterClass());</span>

<span class="fc" id="L3016">            conversation.setPreviousConversationId(prevId);</span>
<span class="fc" id="L3017">            conversationlist.add(index++, conversation);</span>
<span class="fc" id="L3018">            prevIndex = index - 2;</span>
<span class="fc bfc" id="L3019" title="All 2 branches covered.">            if (prevIndex &gt;= 0) {</span>
<span class="fc" id="L3020">                conversationlist.get(prevIndex).setNextConversationId(currId);</span>
            }
<span class="fc" id="L3022">            prevId = currId;</span>
<span class="fc" id="L3023">        }</span>
<span class="fc" id="L3024">        return conversationlist;</span>
    }

    private ArrayList&lt;EHRSearch&lt;?&gt;&gt; getConversationListSearches(EHRRequestContext requestContext, Long userId,
                                                                Long accountId, String filterPatientId, Instant filterFromDate, Instant filterToDate, ConversationWorkflowFilterDTO conversationWorkflowFilterDTO) {
<span class="fc" id="L3029">        EHRSearch&lt;Message&gt; allVisibleConversationIdsSearch = allVisibleMessageConversationIdsSearch(userId, accountId, filterPatientId, conversationWorkflowFilterDTO);</span>
<span class="fc" id="L3030">        List&lt;EHRData&gt; allVisibleConversationIds = beanFactory.getEhrRemote().queryEHRData(allVisibleConversationIdsSearch, requestContext.withoutAccessLog());</span>
<span class="fc" id="L3031">        List&lt;UUID&gt; distinctMessageConversationIdsArray = allVisibleConversationIds.stream().map(EHRData::getUuid01).filter(Objects::nonNull)</span>
<span class="fc" id="L3032">                .distinct()</span>
<span class="fc" id="L3033">                .collect(Collectors.toList());</span>

<span class="fc" id="L3035">        var searches = new ArrayList&lt;EHRSearch&lt;?&gt;&gt;();</span>

<span class="fc" id="L3037">        EHRSearch&lt;EncounterEvent&gt; allLatestEncounterSearch = allLatestMessagesOrEncounter(requestContext, EncounterEvent.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT, userId,</span>
                accountId,
                filterPatientId, filterFromDate, filterToDate, null, true);
<span class="fc" id="L3040">        searches.add(allLatestEncounterSearch);</span>

<span class="fc" id="L3042">        List&lt;List&lt;UUID&gt;&gt; partitionedConversationIds = Lists.partition(distinctMessageConversationIdsArray, config.getInboxConversationSearchBatchSize());</span>
<span class="fc" id="L3043">        partitionedConversationIds.forEach(distinctMessageConversationIdSubset -&gt; {</span>
<span class="fc" id="L3044">            EHRSearch&lt;Message&gt; allLatestMessagesSearch = allLatestMessagesOrEncounter(requestContext, Message.class, Message.MS_PATH_MESSAGE, userId, accountId, filterPatientId,</span>
                    filterFromDate,
                    filterToDate, new HashSet&lt;&gt;(distinctMessageConversationIdSubset), false);

<span class="fc" id="L3048">            allLatestMessagesSearch.setRequestContext(requestContext.withConsentStatus(requestContext.getConsentStatus().withRequired(false)));</span>

<span class="fc" id="L3050">            searches.add(allLatestMessagesSearch);</span>
<span class="fc" id="L3051">        });</span>
<span class="fc" id="L3052">        return searches;</span>
    }

    private EHRSearch&lt;Message&gt; allVisibleMessageConversationIdsSearch(
            Long userId,
            Long accountId,
            String filterPatientId,
            ConversationWorkflowFilterDTO conversationWorkflowFilterDTO) {

<span class="fc" id="L3061">        EHRSearch&lt;Message&gt; allVisibleConversationIds = new EHRSearch&lt;&gt;(accountId, Message.class, Message.MS_PATH_MESSAGE);</span>

        // don't fetch private messages
<span class="fc" id="L3064">        var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
<span class="fc bfc" id="L3065" title="All 2 branches covered.">        if (!Objects.equals(defaultAccountId, accountId)) {</span>
<span class="fc" id="L3066">            allVisibleConversationIds.addFilter(new PKBFilter(&quot;privateMessage&quot;,</span>
                    PKBFilter.Operator.FALSE_OR_IS_NULL, null));
        }

<span class="fc bfc" id="L3070" title="All 2 branches covered.">        if (filterPatientId != null) {</span>
            //migratePatientIdToString03(userId,accountId);
            // Pravina : migration moved as a background process after login
<span class="fc" id="L3073">            allVisibleConversationIds.addFilter(new PKBFilter(&quot;string03&quot;,</span>
                    PKBFilter.Operator.EQUAL, filterPatientId));
        }

<span class="fc" id="L3077">        allVisibleConversationIds.setLatestPerTypeFilter(&quot;date01&quot;, Message.ENCOUNTER_UNIQUE_ID_COLUMN, EHRSearch.OrderByDirection.Asc);</span>
<span class="fc" id="L3078">        allVisibleConversationIds.addFilter(new PKBFilter(&quot;deleted&quot;, PKBFilter.Operator.EQUAL, false, true/*applyWhenChoosingLatest*/));</span>
<span class="fc" id="L3079">        allVisibleConversationIds.setUseParticipantFilter();</span>
<span class="fc" id="L3080">        allVisibleConversationIds.setConversationWorkflowFilter(conversationWorkflowFilterDTO);</span>
<span class="fc" id="L3081">        return allVisibleConversationIds;</span>
    }

    private &lt;D&gt; EHRSearch&lt;D&gt; allLatestMessagesOrEncounter(
            EHRRequestContext requestContext,
            Class&lt;D&gt; dtoClass,
            MenuDataType dataType,
            Long userId,
            Long accountId,
            String filterPatientId,
            Instant filterFromDate,
            Instant filterToDate,
            Set&lt;UUID&gt; conversationIds,
            boolean visibleOnly) {

<span class="fc" id="L3096">        EHRSearch&lt;D&gt; allLatestMessagesSearch = new EHRSearch&lt;&gt;(accountId, dtoClass, dataType);</span>
<span class="fc" id="L3097">        allLatestMessagesSearch.addFields(&quot;datatype&quot;);</span>

        // don't fetch private messages
<span class="fc" id="L3100">        var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
<span class="fc bfc" id="L3101" title="All 2 branches covered.">        if (!Objects.equals(defaultAccountId, accountId)) {</span>
<span class="fc" id="L3102">            allLatestMessagesSearch.addFilter(new PKBFilter(&quot;privateMessage&quot;,</span>
                    PKBFilter.Operator.FALSE_OR_IS_NULL, null));
        }

<span class="fc" id="L3106">        getPatientIdFilter(accountId, userId, filterPatientId).ifPresent(id -&gt; allLatestMessagesSearch.addFilter(new PKBFilter(&quot;string03&quot;,</span>
                PKBFilter.Operator.EQUAL, id)));

<span class="fc bfc" id="L3109" title="All 2 branches covered.">        if (filterFromDate != null) {</span>
<span class="fc" id="L3110">            allLatestMessagesSearch.addFilter(new PKBFilter(&quot;date01&quot;,</span>
                    PKBFilter.Operator.GREATER_OR_EQUAL, filterFromDate));
        }

<span class="fc bfc" id="L3114" title="All 2 branches covered.">        if (filterToDate != null) {</span>
<span class="fc" id="L3115">            allLatestMessagesSearch.addFilter(new PKBFilter(&quot;date01&quot;,</span>
                    PKBFilter.Operator.LESS_OR_EQUAL, filterToDate));
        }

        //			 ehrSearch.addFilter(new PKBFilter(&quot;string09&quot;,
        //					PKBFilter.Operator.EQUAL, EncounterClass.VIRTUAL.toString()));

        // The conversationList is constructed by pulling out the most recent message
        // in a given conversation (grouped together by encounterUniqueId)
        // It is not yet aware of ENCOUNTER_DETAILS type messages and without this filter,
        // these will be retrieved , so we need to exclude
        // these from the query until further notice.
        // TODO: Include this handling in a discussion on handling Encounters in general
        // ehrSearch.addFilter(new PKBFilter(Message.MESSAGE_TYPE_ID, Operator.NOT_EQUAL_OR_NULL,
        //                     MessageType.ENCOUNTER_DETAILS.toString()));

<span class="fc" id="L3131">        allLatestMessagesSearch.setLatestPerTypeFilter(&quot;date01&quot;, &quot;uuid01&quot;, EHRSearch.OrderByDirection.Desc, visibleOnly);</span>

<span class="fc" id="L3133">        allLatestMessagesSearch.addFilter(new PKBFilter(&quot;deleted&quot;, PKBFilter.Operator.EQUAL, false, true/*applyWhenChoosingLatest*/));</span>

<span class="fc bfc" id="L3135" title="All 2 branches covered.">        if (!requestContext.isUserInOwnAccount()) {</span>
<span class="fc" id="L3136">            allLatestMessagesSearch.addFilter(new PKBFilter(&quot;string04&quot;, PKBFilter.Operator.NOT_EQUAL_OR_NULL, &quot;INDRAFT&quot;));</span>
        }

<span class="fc bfc" id="L3139" title="All 2 branches covered.">        if (conversationIds != null) {</span>
<span class="pc bpc" id="L3140" title="1 of 2 branches missed.">            if (conversationIds.isEmpty()) {</span>
                // need to add the else matcher as IN does not work for empty collections
<span class="nc" id="L3142">                allLatestMessagesSearch.addFilter(new PKBFilter(&quot;id&quot;, PKBFilter.Operator.IS_NULL, null));</span>
            } else {
<span class="fc" id="L3144">                allLatestMessagesSearch.addFilter(new PKBFilter(Message.ENCOUNTER_ID, PKBFilter.Operator.IN, conversationIds));</span>
            }
        }

        // According to latest message id on each conversation list
<span class="fc" id="L3149">        allLatestMessagesSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Desc);</span>

<span class="fc" id="L3151">        return allLatestMessagesSearch;</span>
    }

    private Optional&lt;String&gt; getPatientIdFilter(@NotNull Long accountId, Long requestingUserId, @Nullable String filterPatientIdOrNull) {

<span class="fc bfc" id="L3156" title="All 2 branches covered.">        if (filterPatientIdOrNull != null) {</span>
<span class="fc" id="L3157">            return Optional.of(filterPatientIdOrNull);</span>
        } else {
<span class="fc" id="L3159">            Long accountOwnerId = beanFactory.getPKBPersonBean().getAccountOwnerId(accountId);</span>
<span class="pc bpc" id="L3160" title="1 of 4 branches missed.">            if (accountOwnerId != null &amp;&amp; !accountOwnerId.equals(requestingUserId)) {</span>
<span class="fc" id="L3161">                return Optional.of(accountOwnerId.toString());</span>
            }
        }

<span class="fc" id="L3165">        return Optional.empty();</span>
    }

    private List&lt;ApiConversationDTO&gt; getConversationListForApi(@NotNull LoggedInEHRRequestContext requestContext, Long userId,
                                                               Long accountId, boolean sortDescending, Instant fromDateOrNull,
                                                               Instant toDateOrNull, int pageSize, int offset) {
        try {
<span class="fc" id="L3172">            List&lt;ApiConversationDTO&gt; dtoList = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L3174">            EHRSearch&lt;Message&gt; ehrSearchMsg = new EHRSearch&lt;&gt;(accountId, Message.class, Message.MS_PATH_MESSAGE);</span>
<span class="fc" id="L3175">            ehrSearchMsg.setResultsMaxReturned(pageSize);</span>
<span class="fc" id="L3176">            ehrSearchMsg.setResultsStartPosition(offset);</span>

<span class="fc" id="L3178">            var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
<span class="pc bpc" id="L3179" title="1 of 2 branches missed.">            if (!Objects.equals(accountId, defaultAccountId)) {</span>
<span class="nc" id="L3180">                ehrSearchMsg.addFilter(new PKBFilter(&quot;boolean&quot;, PKBFilter.Operator.NOT_EQUAL, Boolean.TRUE));</span>
            }

<span class="pc bpc" id="L3183" title="1 of 2 branches missed.">            if (fromDateOrNull != null) {</span>
<span class="fc" id="L3184">                ehrSearchMsg.addFilter(new PKBFilter(&quot;date01&quot;, PKBFilter.Operator.GREATER, fromDateOrNull));</span>
            }

<span class="pc bpc" id="L3187" title="1 of 2 branches missed.">            if (toDateOrNull != null) {</span>
<span class="nc" id="L3188">                ehrSearchMsg.addFilter(new PKBFilter(&quot;date01&quot;, PKBFilter.Operator.LESS, toDateOrNull));</span>
            }

<span class="pc bpc" id="L3191" title="1 of 2 branches missed.">            if (sortDescending) {</span>
<span class="nc" id="L3192">                ehrSearchMsg.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Desc);</span>
            } else {
<span class="fc" id="L3194">                ehrSearchMsg.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Asc);</span>
            }

<span class="fc" id="L3197">            ehrSearchMsg.addFilter(new PKBFilter(&quot;string09&quot;,</span>
<span class="fc" id="L3198">                    PKBFilter.Operator.EQUAL, EncounterClass.VIRTUAL.toString()));</span>
<span class="fc" id="L3199">            ehrSearchMsg.setLatestPerTypeFilter(&quot;date01&quot;, Message.ENCOUNTER_ID);</span>

            // separate search for encounters; copy filters &amp; limits etc. from the main search
<span class="fc" id="L3202">            EHRSearch&lt;EncounterEvent&gt; ehrSearchEncEvent = new EHRSearch&lt;&gt;(ehrSearchMsg, EncounterEvent.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>

<span class="fc" id="L3204">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(newArrayList(ehrSearchMsg, ehrSearchEncEvent), requestContext);</span>
<span class="fc" id="L3205">            List&lt;Message&gt; messages = populateMessagesAndEncounterEvents(requestContext, ehrList);</span>
<span class="fc" id="L3206">            List&lt;UUID&gt; conversationIds = messages.stream().map(Message::getEncounterUniqueId).collect(toList());</span>

<span class="fc bfc" id="L3208" title="All 2 branches covered.">            if (conversationIds.isEmpty()) {</span>
<span class="fc" id="L3209">                return dtoList;</span>
            }

<span class="fc" id="L3212">            Map&lt;UUID, Long&gt; conversationToCountMap = getEncounterToMessageCountMap(</span>
                    accountId, conversationIds, requestContext);
<span class="fc" id="L3214">            List&lt;Encounter&gt; results = populateAndChainConversations(messages, conversationToCountMap);</span>

<span class="pc bpc" id="L3216" title="1 of 2 branches missed.">            if (CollectionUtils.isNotEmpty(conversationIds)) {</span>
<span class="fc" id="L3217">                messages = getMessagesInConversations(requestContext, userId, accountId, conversationIds);</span>
            }

<span class="fc" id="L3220">            var personMap = getParticipantMap(results, Encounter::getParticipants);</span>


<span class="fc bfc" id="L3223" title="All 2 branches covered.">            for (Encounter conversation : results) {</span>
<span class="fc" id="L3224">                ApiConversationDTO dto = new ApiConversationDTO();</span>
<span class="fc" id="L3225">                dto.setId(conversation.getEncounterUniqueId());</span>
<span class="fc" id="L3226">                dto.setLatestMessageId(conversation.getLatestMessage().getId());</span>
<span class="fc" id="L3227">                dto.setMessageCount(conversation.getMessageCount());</span>
<span class="fc" id="L3228">                dto.setMessages(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L3229">                messages.stream().filter(message -&gt; message.getEncounterUniqueId().equals(dto.getId())).forEach(message -&gt; dto.getMessages().add(message));</span>

<span class="pc bpc" id="L3231" title="1 of 2 branches missed.">                if (dto.getMessageCount() != dto.getMessages().size()) {</span>
<span class="nc" id="L3232">                    LOGGER.error(&quot;error getting conversation data: message count doesn't match count of messages for conversation {}&quot;,</span>
<span class="nc" id="L3233">                            conversation.getEncounterUniqueId());</span>
                }

<span class="fc" id="L3236">                var participantList = getParticipantsAsPersonList(conversation.getParticipants(), personMap);</span>
<span class="fc" id="L3237">                dto.setParticipants(participantList);</span>
<span class="fc" id="L3238">                dtoList.add(dto);</span>
<span class="fc" id="L3239">            }</span>

<span class="fc" id="L3241">            return dtoList;</span>

<span class="nc" id="L3243">        } catch (Exception e) {</span>
<span class="nc" id="L3244">            throw new RuntimeException(</span>
                    &quot;Exception while getting conversation list&quot;, e);
        }
    }

    private Encounter getEncounterByFilter(@NotNull LoggedInEHRRequestContext requestContext, String userId,
                                           UUID filterValue, boolean fetchParticipants, PKBFilter filter) {
        try {
<span class="fc" id="L3252">            List&lt;Encounter&gt; encounters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3253">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong((userId)));</span>
<span class="fc" id="L3254">            EHRSearch&lt;Message&gt; search = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);

<span class="fc" id="L3257">            search.addFilter(filter);</span>
            // get the latest by uniqueId
<span class="fc" id="L3259">            search.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>

<span class="fc" id="L3261">            List&lt;EHRData&gt; ehrDataList = beanFactory.getEhrRemote().queryAndDecryptEHRData(search, requestContext);</span>
<span class="fc bfc" id="L3262" title="All 2 branches covered.">            if (ehrDataList.isEmpty()) {</span>
<span class="fc" id="L3263">                return null;</span>
            }

<span class="fc" id="L3266">            List&lt;Message&gt; messages = populateMessagesAndEncounterEvents(requestContext, ehrDataList);</span>

<span class="fc" id="L3268">            List&lt;UUID&gt; encounterUniqueIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3269">            encounterUniqueIds.add(filterValue);</span>

<span class="fc" id="L3271">            Map&lt;UUID, Long&gt; encounterToCountMap = getEncounterToMessageCountMap(accountId,</span>
                    encounterUniqueIds, requestContext);
<span class="fc" id="L3273">            encounters = populateEncounters(messages, encounterToCountMap, fetchParticipants);</span>

<span class="fc" id="L3275">            return encounters.get(0);</span>
<span class="nc" id="L3276">        } catch (Exception e) {</span>
<span class="nc" id="L3277">            throw new RuntimeException(&quot;Exception while fetching encounter by conversation unique ID&quot; + filterValue, e);</span>
        }
    }

    @Nullable
    private Encounter getEncounterByEncounterEventUniqueId(@NotNull LoggedInEHRRequestContext requestContext, String userId, UUID encounterEventUniqueId, boolean fetchParticipants) {
<span class="fc" id="L3283">        return getEncounterByFilter(requestContext, userId, encounterEventUniqueId, fetchParticipants, new PKBFilter(&quot;uniqueId&quot;, PKBFilter.Operator.EQUAL, encounterEventUniqueId));</span>
    }

    @Nullable
    private Encounter getEncounterByConversationUniqueId(@NotNull LoggedInEHRRequestContext requestContext, String userId, UUID convUniqueId, boolean fetchParticipants) {
<span class="fc" id="L3288">        return getEncounterByFilter(requestContext, userId, convUniqueId, fetchParticipants, new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.EQUAL, convUniqueId));</span>
    }

    @Nullable
    public Encounter getEncounterByExternalEncounterId(@NotNull LoggedInEHRRequestContext requestContext, String patientId,
                                                       String externalEncounterId, long oid, boolean fetchParticipants) {

        try {
<span class="fc" id="L3296">            List&lt;Encounter&gt; encounters = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L3298">            Long accountId = beanFactory.getPKBPersonBean().getDefaultAccountId(parseLong((patientId)));</span>

<span class="fc" id="L3300">            EHRSearch&lt;Message&gt; search = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);

<span class="fc" id="L3303">            search.addFilter(new PKBFilter(Message.EXTERNAL_ENCOUNTER_ID, PKBFilter.Operator.EQUAL, externalEncounterId));</span>
<span class="fc" id="L3304">            search.addFilter(new PKBFilter(SourceDetails.EHRQUERY_ORG_ID, PKBFilter.Operator.EQUAL, oid));</span>
<span class="fc" id="L3305">            List&lt;EHRData&gt; ehrDataList = beanFactory.getEhrRemote().queryAndDecryptEHRData(search, requestContext);</span>
<span class="fc bfc" id="L3306" title="All 2 branches covered.">            if (ehrDataList.isEmpty()) {</span>
<span class="fc" id="L3307">                return null;</span>
            }

<span class="fc" id="L3310">            List&lt;Message&gt; messages = populateMessagesAndEncounterEvents(requestContext, ehrDataList);</span>

<span class="fc" id="L3312">            encounters = populateEncounters(messages, null, fetchParticipants);</span>

<span class="fc" id="L3314">            return encounters.get(0);</span>
<span class="nc" id="L3315">        } catch (Exception e) {</span>
<span class="nc" id="L3316">            throw new RuntimeException(&quot;Exception while fetching encounter by unique ID &quot; + externalEncounterId, e);</span>
        }
    }

    public Tuple2&lt;@Nullable UUID, Integer&gt; deleteEncountersByExternalDocumentId(@NotNull EHRRequestContext requestContext, Long accountId, SourceDetails deletedBy,
                                                                                String externalDocumentId, Org sourceOrg) {

<span class="fc" id="L3323">        EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, Message.class, EncounterEvent.MS_PATH_ENCOUNTER_EVENT);</span>

<span class="fc" id="L3325">        ehrSearch.addFilter(new PKBFilter(Message.EXTERNAL_MESSAGE_ID, PKBFilter.Operator.EQUAL, externalDocumentId));</span>
<span class="fc" id="L3326">        ehrSearch.addFilter(new PKBFilter(EHRData.SOURCE_ORG_ID, PKBFilter.Operator.EQUAL, sourceOrg.getId()));</span>

<span class="fc" id="L3328">        List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryEHRData(ehrSearch, requestContext);</span>
<span class="fc" id="L3329">        List&lt;Message&gt; messages = populateMessagesAndEncounterEvents(requestContext, ehrList);</span>

<span class="fc" id="L3331">        List&lt;EncounterEvent&gt; deleted = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L3333">        Set&lt;UUID&gt; distinctEncounterUniqueIds = new HashSet&lt;&gt;();</span>

<span class="fc" id="L3335">        messages.stream()</span>
<span class="fc bfc" id="L3336" title="All 2 branches covered.">                .filter(message -&gt; message.getSource().getRoute() == Route.HL7_API)</span>
<span class="fc" id="L3337">                .forEach(message -&gt; {</span>
<span class="fc" id="L3338">                    beanFactory.getEhrRemote().deleteEHRData(message.getId());</span>
<span class="fc" id="L3339">                    deleted.add((EncounterEvent) message);</span>
<span class="fc" id="L3340">                    distinctEncounterUniqueIds.add(message.getEncounterUniqueId());</span>
<span class="fc" id="L3341">                });</span>

<span class="pc bpc" id="L3343" title="1 of 2 branches missed.">        if (distinctEncounterUniqueIds.size() &gt; 1) {</span>
<span class="nc" id="L3344">            hl7DocumentDeletionErrorCounter.inc();</span>
<span class="nc" id="L3345">            throw new RuntimeException(String.format(&quot;Deleting a document for externalDocumentId %s matched documents across multiple conversations&quot;, externalDocumentId));</span>
        }

<span class="fc" id="L3348">        LOGGER.info(&quot;Deleted {} messages for externalDocumentId {} in account {}&quot;, deleted.size(), externalDocumentId, accountId);</span>

<span class="fc bfc" id="L3350" title="All 2 branches covered.">        if (CollectionUtils.isNotEmpty(deleted)) {</span>
<span class="fc" id="L3351">            return Tuple.of(deleted.get(0).getEncounterUniqueId(), deleted.size());</span>
        }

<span class="fc" id="L3354">        hl7DocumentDeletionErrorCounter.inc();</span>
<span class="fc" id="L3355">        return Tuple.of(null, 0);</span>
    }

    private List&lt;IBaseDTO&gt; getActivityList(LoggedInEHRRequestContext requestContext,
                                           Long userId, Long accountId,
                                           int pageSize, int offset) {
        try {
<span class="fc" id="L3362">            EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
<span class="fc" id="L3363">                    Sets.immutableEnumSet(Message.MS_PATH_MESSAGE, EncounterEvent.MS_PATH_ENCOUNTER_EVENT, AppointmentDTO.MS_PATH, TestResultDTO.MS_PATH));</span>

            // don't fetch private messages
<span class="fc" id="L3366">            var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">            if (!Objects.equals(defaultAccountId, accountId)) {</span>
<span class="nc" id="L3368">                ehrSearch.addFilter(new PKBFilter(&quot;boolean01&quot;, PKBFilter.Operator.FALSE_OR_IS_NULL, null));</span>
            }

<span class="fc" id="L3371">            ehrSearch.addFilter(new PKBFilter(&quot;string04&quot;, PKBFilter.Operator.NOT_EQUAL_OR_NULL, MessageStatus.INDRAFT.toString()));</span>

<span class="fc" id="L3373">            ehrSearch.setIncludeDeleted(false); //just to make it explicit</span>
<span class="fc" id="L3374">            ehrSearch.setResultsMaxReturned(pageSize);</span>
<span class="fc" id="L3375">            ehrSearch.setResultsStartPosition(offset);</span>
<span class="fc" id="L3376">            ehrSearch.setOrderBy(&quot;enteredDate&quot;, EHRSearch.OrderByDirection.Desc);</span>

<span class="fc" id="L3378">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>

<span class="fc bfc" id="L3380" title="All 2 branches covered.">            if (isEmpty(ehrList)) {</span>
<span class="fc" id="L3381">                return new ArrayList&lt;&gt;();</span>
            }

<span class="fc" id="L3384">            Map&lt;MenuDataType, Class&gt; typeToClassMapping = new EnumMap&lt;&gt;(MenuDataType.class);</span>
<span class="fc" id="L3385">            typeToClassMapping.put(Message.MS_PATH_MESSAGE, Message.class);</span>
<span class="fc" id="L3386">            typeToClassMapping.put(EncounterEvent.MS_PATH_ENCOUNTER_EVENT, EncounterEvent.class);</span>
<span class="fc" id="L3387">            typeToClassMapping.put(AppointmentDTO.MS_PATH, AppointmentDTO.class);</span>
<span class="fc" id="L3388">            typeToClassMapping.put(TestResultDTO.MS_PATH, TestResultDTO.class);</span>

<span class="fc" id="L3390">            List&lt;IBaseDTO&gt; dtos = populateDTOsMultipleDataTypes(requestContext, ehrList, typeToClassMapping);</span>
<span class="fc" id="L3391">            return dtos.stream()</span>
<span class="fc bfc" id="L3392" title="All 2 branches covered.">                    .filter(dto -&gt; !isLabResultHiddenFromGlasgowPatient(dto, requestContext))</span>
<span class="fc" id="L3393">                    .collect(toList());</span>
<span class="nc" id="L3394">        } catch (Exception e) {</span>
<span class="nc" id="L3395">            LOGGER.error(e.getMessage());</span>
<span class="nc" id="L3396">            throw new RuntimeException(&quot;Exception while getting activity list&quot;, e);</span>
        }
    }

    /**
     * Horrible temporary kludge for SciStore 8/2/2016
     * From PHR-460 and PHR-2107
     */
    private boolean isLabResultHiddenFromGlasgowPatient(IBaseDTO dto, LoggedInEHRRequestContext requestContext) {
<span class="fc bfc" id="L3405" title="All 2 branches covered.">        if (!requestContext.getAccessingUser().isPatient()) {</span>
<span class="fc" id="L3406">            return false;</span>
        }

<span class="fc bfc" id="L3409" title="All 2 branches covered.">        if (dto instanceof TestResultDTO) {</span>
<span class="fc" id="L3410">            Long loincTestId = ((TestResultDTO) dto).getLoincTestId();</span>
<span class="fc" id="L3411">            String sourceText = dto.getSource().getText();</span>

<span class="fc bfc" id="L3413" title="All 4 branches covered.">            return !getSciStoreLoincIdWhitelist().contains(loincTestId) &amp;&amp; SCISTORE_SOURCE_TEXT.equals(sourceText);</span>
        }
<span class="fc" id="L3415">        return false;</span>
    }

    private List&lt;Long&gt; getSciStoreLoincIdWhitelist() {
<span class="fc" id="L3419">        ZonedDateTime zdt = dateTimeService.nowZonedDateTime();</span>
<span class="fc bfc" id="L3420" title="All 2 branches covered.">        if (isLoincWhitelistUpdateNeeded(zdt)) {</span>
<span class="fc" id="L3421">            synchronized (EncounterManager.class) {</span>
<span class="pc bpc" id="L3422" title="1 of 2 branches missed.">                if (isLoincWhitelistUpdateNeeded(zdt)) {</span>
<span class="fc" id="L3423">                    List&lt;Long&gt; results = loincTestRepository.findLoincIdsForWhitelist(SCISTORE_LOINC_WHITELIST);</span>
<span class="fc" id="L3424">                    nextCacheUpdate = zdt.plusHours(23L).plusMinutes(50L);</span>
<span class="fc" id="L3425">                    scistoreLoincIdWhitelist = unmodifiableList(results);</span>
                }
<span class="fc" id="L3427">            }</span>
        }
<span class="fc" id="L3429">        return scistoreLoincIdWhitelist;</span>
    }

    private boolean isLoincWhitelistUpdateNeeded(ZonedDateTime zdt) {
<span class="fc bfc" id="L3433" title="All 4 branches covered.">        return scistoreLoincIdWhitelist == null || zdt.isAfter(nextCacheUpdate);</span>
    }

    public void clearLoincIdState() {
<span class="fc" id="L3437">        scistoreLoincIdWhitelist = null;</span>
<span class="fc" id="L3438">        nextCacheUpdate = null;</span>
<span class="fc" id="L3439">        LOGGER.info(&quot;Cleared internal loinc id whitelist states&quot;);</span>
<span class="fc" id="L3440">    }</span>

    public long getConversationCount(@NotNull LoggedInEHRRequestContext requestContext, Long userId, Long accountId,
                                     String filterPatientIdOrNull, Instant fromDateOrNull, Instant toDateOrNull, ConversationWorkflowFilterDTO conversationWorkflowFilterDTO) {
        try {
<span class="fc" id="L3445">            doSyncUploadedData(requestContext, accountId);</span>
<span class="fc" id="L3446">            ArrayList&lt;EHRSearch&lt;?&gt;&gt; searches = getConversationListSearches(requestContext, userId, accountId, filterPatientIdOrNull, fromDateOrNull, toDateOrNull,</span>
                    conversationWorkflowFilterDTO);
<span class="fc" id="L3448">            return searches.stream().mapToLong(search -&gt; beanFactory.getEhrRemote().countEHRData(search, requestContext)).sum();</span>
<span class="nc" id="L3449">        } catch (Exception e) {</span>
<span class="nc" id="L3450">            throw new RuntimeException(&quot;Exception while getting conversation count for user-&quot; + userId, e);</span>
        }
    }

    private List&lt;ActivityDTO&gt; getActivityListAsActivities(LoggedInEHRRequestContext requestContext, List&lt;IBaseDTO&gt; activityList) {
<span class="fc" id="L3455">        List&lt;ActivityDTO&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3456" title="All 2 branches covered.">        for (IBaseDTO notification : activityList) {</span>
<span class="pc bpc" id="L3457" title="1 of 2 branches missed.">            if (!isLabResultHiddenFromGlasgowPatient(notification, requestContext)) {</span>
<span class="fc" id="L3458">                ActivityDTO activityDTO = toActivity(requestContext, notification);</span>
<span class="fc" id="L3459">                result.add(activityDTO);</span>
            }
<span class="fc" id="L3461">        }</span>
<span class="fc" id="L3462">        return result;</span>
    }

    private ActivityDTO toActivity(@NotNull LoggedInEHRRequestContext requestContext, @NotNull IBaseDTO dto) {
<span class="fc" id="L3466">        checkNotNull(requestContext, &quot;requestContext&quot;);</span>
<span class="fc" id="L3467">        checkNotNull(dto, &quot;dto&quot;);</span>

<span class="fc" id="L3469">        return Match(dto).of(</span>
<span class="fc" id="L3470">                Case($(instanceOf(EncounterEvent.class)), (EncounterEvent msg) -&gt; toActivity(requestContext, msg)),</span>
<span class="fc" id="L3471">                Case($(instanceOf(Message.class)), (Message msg) -&gt; toActivity(requestContext, msg)), // also handles EncounterEvent</span>
<span class="fc" id="L3472">                Case($(instanceOf(TestResultDTO.class)), (TestResultDTO test) -&gt; toActivity(requestContext, test)),</span>
<span class="fc" id="L3473">                Case($(instanceOf(AppointmentDTO.class)), (AppointmentDTO app) -&gt; toActivity(requestContext, app)),</span>
<span class="fc" id="L3474">                Case($(), o -&gt; {</span>
<span class="nc" id="L3475">                    throw new RuntimeException(&quot;Unexpected dto type! &quot; + dto.getClass());</span>
                }));
    }

    private ActivityDTO toActivity(LoggedInEHRRequestContext requestContext, AppointmentDTO appointment) {

<span class="fc" id="L3481">        Activity activity = new Activity(appointment.getBaseFields().findEnteredDate().orElse(dateTimeService.now()), Activity.Action.INVITED_TO_APPOINTMENT, requestContext.getOrgId().orElse(null));</span>

<span class="fc" id="L3483">        Map&lt;ActivityProperty, Object&gt; properties = new EnumMap&lt;&gt;(ActivityProperty.class);</span>
<span class="fc" id="L3484">        properties.put(ActivityProperty.APPOINTMENT_ID, appointment.getBaseFields().getUniqueId());</span>
<span class="fc" id="L3485">        properties.put(ActivityProperty.APPOINTMENT_SUBJECT, appointment.getSubject());</span>
<span class="fc" id="L3486">        properties.put(ActivityProperty.APPOINTMENT_DATE, appointment.getStartTimestamp());</span>
<span class="fc" id="L3487">        properties.put(ActivityProperty.STATUS, appointment.getStatus());</span>

<span class="fc" id="L3489">        return createActivityDTO(activity, properties);</span>
    }

    private ActivityDTO toActivity(LoggedInEHRRequestContext requestContext, TestResultDTO testResult) {

<span class="fc" id="L3494">        Activity activity = new Activity(testResult.getBaseFields().findEnteredDate().orElse(dateTimeService.now()), Activity.Action.UPLOADED_LAB_RESULTS, requestContext.getOrgId().orElse(null));</span>

<span class="fc" id="L3496">        String source = testResult.getTestResultTypeIdSource();</span>

<span class="fc" id="L3498">        Map&lt;ActivityProperty, Object&gt; properties = new EnumMap&lt;&gt;(ActivityProperty.class);</span>
<span class="fc" id="L3499">        properties.put(ActivityProperty.LAB_TEST_ID, testResult.getTestResultTypeId());</span>
<span class="fc" id="L3500">        properties.put(ActivityProperty.LAB_TEST_ID_SOURCE, source);</span>

        // activities.jsp will check the result type to determine whether to interpret the testName as an i18n string or literal text
<span class="fc" id="L3503">        String testName = &quot;&quot;;</span>

<span class="fc bfc" id="L3505" title="All 2 branches covered.">        if (TestResultType.ID_SOURCE_LOINC.equalsIgnoreCase(source)) {</span>
<span class="fc" id="L3506">            testName = loincTestRepository.findById(testResult.getTestResultTypeId())</span>
<span class="fc" id="L3507">                    .map(LoincTest::getNameKey)</span>
<span class="pc" id="L3508">                    .orElseThrow(() -&gt; new RuntimeException(String.format(&quot;No LoincTest or NameKey found for test result type id: %d&quot;, testResult.getTestResultTypeId())));</span>
<span class="pc bpc" id="L3509" title="1 of 2 branches missed.">        } else if (TestResultType.ID_SOURCE_MAPPING.equalsIgnoreCase(source)) {</span>
<span class="fc" id="L3510">            testName = loincMappingRepository.findById(testResult.getTestResultTypeId())</span>
<span class="fc" id="L3511">                    .map(LoincMapping::getNameForDisplay)</span>
<span class="pc" id="L3512">                    .orElseThrow(() -&gt; new RuntimeException(String.format(&quot;No LoincTestMapping or NameForDisplay found for test result type id: %d&quot;, testResult.getTestResultTypeId())));</span>
        } else {
<span class="nc" id="L3514">            testName = testResult.getServiceNameFromSource();</span>
<span class="nc" id="L3515">            LOGGER.error(&quot;Processing a test whose type was neither loinc nor loincmapping&quot;);</span>
        }

<span class="fc" id="L3518">        properties.put(ActivityProperty.LAB_TEST_NAME, testName);</span>

<span class="fc" id="L3520">        return createActivityDTO(activity, properties);</span>
    }

    private ActivityDTO toActivity(LoggedInEHRRequestContext requestContext, EncounterEvent encounter) {

<span class="fc" id="L3525">        Activity activity = new Activity(encounter.getBaseFields().findEnteredDate().orElse(dateTimeService.now()), Activity.Action.SENT_MESSAGE, requestContext.getOrgId().orElse(null));</span>
<span class="fc" id="L3526">        Map&lt;ActivityProperty, Object&gt; properties = getCommonMessageProperties(encounter);</span>

<span class="fc" id="L3528">        String orgName = encounter.getSource().getOrgName();</span>
<span class="pc bpc" id="L3529" title="1 of 2 branches missed.">        if (orgName != null) {</span>
<span class="fc" id="L3530">            activity.setActorId(orgName);</span>
<span class="fc" id="L3531">            properties.put(ActivityProperty.MESSAGE_SENDER, orgName);</span>
        }

<span class="fc" id="L3534">        return createActivityDTO(activity, properties);</span>
    }

    private ActivityDTO toActivity(LoggedInEHRRequestContext requestContext, Message latestMessage) {

<span class="fc" id="L3539">        Activity activity = new Activity(latestMessage.getBaseFields().findEnteredDate().orElse(dateTimeService.now()), Activity.Action.SENT_MESSAGE, requestContext.getOrgId().orElse(null));</span>
<span class="fc" id="L3540">        activity.setActorId(latestMessage.getSenderId());</span>

<span class="fc" id="L3542">        Map&lt;ActivityProperty, Object&gt; properties = getCommonMessageProperties(latestMessage);</span>

<span class="pc bpc" id="L3544" title="1 of 2 branches missed.">        if (latestMessage.getSenderId() != null &amp;&amp;</span>
<span class="fc bfc" id="L3545" title="All 2 branches covered.">                !Long.toString(requestContext.getAccessingUserId()).equals(latestMessage.getSenderId())) {</span>
<span class="fc" id="L3546">            PKBPerson sender = beanFactory.getPKBPersonBean().getPKBPerson(parseLong(latestMessage.getSenderId()));</span>
<span class="fc" id="L3547">            properties.put(ActivityProperty.MESSAGE_SENDER, sender.getNameWithoutTitle());</span>
        }

<span class="fc" id="L3550">        return createActivityDTO(activity, properties);</span>
    }

    private ActivityDTO createActivityDTO(Activity activity, Map&lt;ActivityProperty, Object&gt; properties) {
<span class="fc" id="L3554">        return anActivityDTO()</span>
<span class="fc" id="L3555">                .withActivity(activity)</span>
<span class="fc" id="L3556">                .withActionProperties(properties)</span>
<span class="fc" id="L3557">                .build();</span>
    }

    private Map&lt;ActivityProperty, Object&gt; getCommonMessageProperties(Message message) {
<span class="fc" id="L3561">        Map&lt;ActivityProperty, Object&gt; properties = new EnumMap&lt;&gt;(ActivityProperty.class);</span>
<span class="fc" id="L3562">        properties.put(ActivityProperty.MESSAGE_SUBJECT, message.getSubject());</span>
<span class="fc" id="L3563">        properties.put(ActivityProperty.CONVERSATION_ID, message.getEncounterUniqueId());</span>
<span class="fc" id="L3564">        properties.put(ActivityProperty.MSG_CONTENT_TYPE, message.getInlineContentType());</span>
<span class="fc" id="L3565">        properties.put(ActivityProperty.MESSAGE_SENDER, &quot;&quot;);</span>
<span class="fc" id="L3566">        return properties;</span>
    }

    public Option&lt;UUID&gt; findConversationIdForDocumentId(UUID documentId) {
<span class="fc" id="L3570">        return Option.ofOptional(encounterRepository.findConversationIdsForDocumentId(documentId).stream().findFirst());</span>
    }

    public Optional&lt;Message&gt; findMessageById(@NotNull LoggedInEHRRequestContext requestContext, @NotNull Long messageId) {
<span class="fc" id="L3574">        EHRData data = beanFactory.getEhrRemote().findAndDecryptEHRData(messageId, requestContext);</span>
<span class="fc" id="L3575">        return Optional.ofNullable(beanFactory.getEhrRemote().populateDTO(data, Message.class, requestContext));</span>
    }

    public void addAttachment(EHRRequestContext requestContext, Long messageId, Attachment attachment) {
        try {
<span class="fc" id="L3580">            UUID docId = attachment.getDocMetadataId();</span>
<span class="pc bpc" id="L3581" title="1 of 2 branches missed.">            if (docId != null) {</span>
<span class="fc" id="L3582">                chunkedDocManager.deleteUploadInProgress(docId);</span>
            } else {
                //TODO : this call is made from CallAction and MessageManager - handleDocument (for Hl7 API)
                // migrate the call patient functionality to support chunked documents and remove this case

                // in this case attachment will have contents
<span class="nc" id="L3588">                docId = createAttachmentByOldMethod(requestContext, attachment.getUserId(), attachment.getAccountId(), attachment);</span>
            }
<span class="fc" id="L3590">            chunkedDocManager.createAttachment(messageId, docId, attachment, attachment.getUserId(), attachment.getAccountId());</span>
<span class="nc" id="L3591">        } catch (Exception e) {</span>
<span class="nc" id="L3592">            throw new RuntimeException(&quot;Exception while adding attachment to message-&quot; + messageId, e);</span>
<span class="fc" id="L3593">        }</span>
<span class="fc" id="L3594">    }</span>

    private UUID createAttachmentByOldMethod(EHRRequestContext requestContext, long personId, long accountId, Attachment attachment) {

<span class="nc" id="L3598">        return documentManager.create(</span>
<span class="nc" id="L3599">                beanFactory.getEhrRemote().createDocument(</span>
                        requestContext,
<span class="nc" id="L3601">                        attachment.getContent(),</span>
<span class="nc" id="L3602">                        accountId, genericMetadata(</span>
<span class="nc" id="L3603">                                attachment.getMediaType(),</span>
<span class="nc" id="L3604">                                personId,</span>
<span class="nc" id="L3605">                                &quot;encounterAttachment&quot;).toJavaMap()));</span>
    }

    @Nullable
    public Message getLastMessageOnConversationExcludeDraft(@NotNull LoggedInEHRRequestContext requestContext, String userId,
                                                            Long accountId, UUID conversationId) {
<span class="fc" id="L3611">        return getLastMessageOnConversation(requestContext, userId, conversationId, accountId, false);</span>
    }

    @Nullable
    public Message getLastMessageOnConversationIncludeDraft(@NotNull LoggedInEHRRequestContext requestContext, String userId,
                                                            Long accountId, UUID conversationId) {
<span class="fc" id="L3617">        return getLastMessageOnConversation(requestContext, userId, conversationId, accountId, true);</span>
    }

    @Nullable
    private Message getLastMessageOnConversation(@NotNull LoggedInEHRRequestContext requestContext, String userId, UUID conversationId, Long accountId, boolean includeDraft) {
        try {
<span class="fc" id="L3623">            EHRSearch&lt;Message&gt; ehrSearch = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);
<span class="fc" id="L3625">            ehrSearch.addFilter(new PKBFilter(&quot;uuid01&quot;, PKBFilter.Operator.EQUAL,</span>
                    conversationId));
<span class="fc bfc" id="L3627" title="All 2 branches covered.">            if (!includeDraft) {</span>
<span class="fc" id="L3628">                ehrSearch.addFilter(new PKBFilter(&quot;string04&quot;, PKBFilter.Operator.NOT_EQUAL,</span>
<span class="fc" id="L3629">                        MessageStatus.INDRAFT.toString()));</span>
            }
<span class="fc" id="L3631">            ehrSearch.setOrderBy(&quot;date01&quot;, EHRSearch.OrderByDirection.Desc);</span>
<span class="fc" id="L3632">            ehrSearch.setResultsMaxReturned(1);</span>
<span class="fc" id="L3633">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryAndDecryptEHRData(ehrSearch, requestContext);</span>
<span class="fc bfc" id="L3634" title="All 2 branches covered.">            if (ehrList.isEmpty()) {</span>
<span class="fc" id="L3635">                return null;</span>
            }
<span class="fc" id="L3637">            return populateMessage(requestContext, ehrList.get(0));</span>
<span class="nc" id="L3638">        } catch (Exception e) {</span>
<span class="nc" id="L3639">            throw new RuntimeException(&quot;Error while fetching last non-draft message for conversation id &quot; + conversationId + &quot; user &quot; + userId, e);</span>
        }
    }

    public UUID getConversationIdForDocument(@NotNull EHRRequestContext requestContext, Long accountId, String documentId, long oid) {
        try {
<span class="fc" id="L3645">            UUID conversationIdOrNull = null;</span>
<span class="fc" id="L3646">            EHRSearch&lt;Message&gt; search = new EHRSearch&lt;&gt;(singletonList(accountId), Message.class,</span>
                    ENCOUNTER_TYPES);
<span class="fc" id="L3648">            search.addFilter(new PKBFilter(&quot;string10&quot;, PKBFilter.Operator.EQUAL, documentId));</span>
<span class="fc" id="L3649">            search.addFilter(new PKBFilter(SourceDetails.EHRQUERY_ORG_ID, PKBFilter.Operator.EQUAL, oid));</span>

<span class="fc" id="L3651">            search.setLatestPerTypeFilter(&quot;date01&quot;, Message.ENCOUNTER_ID);</span>

<span class="fc" id="L3653">            List&lt;EHRData&gt; ehrList = beanFactory.getEhrRemote().queryEHRData(search, requestContext);</span>
<span class="fc bfc" id="L3654" title="All 2 branches covered.">            if (ehrList.size() == 1) {</span>
<span class="fc" id="L3655">                Message message = populateMessage(requestContext, ehrList.get(0));</span>
<span class="fc" id="L3656">                conversationIdOrNull = message.getEncounterUniqueId();</span>
<span class="fc" id="L3657">            } else {</span>
<span class="fc" id="L3658">                LOGGER.info(&quot;Number of conversations with documentId-{} is-{}&quot;, documentId, ehrList.size());</span>
            }
<span class="fc" id="L3660">            return conversationIdOrNull;</span>
<span class="nc" id="L3661">        } catch (Exception e) {</span>
<span class="nc" id="L3662">            throw new RuntimeException(&quot;Error getting conversation Id for document &quot; + documentId, e);</span>
        }
    }

    public void deleteMessage(Long messageId) {
        try {
<span class="fc" id="L3668">            beanFactory.getEhrRemote().deleteEHRData(messageId);</span>
<span class="nc" id="L3669">        } catch (Exception e) {</span>
<span class="nc" id="L3670">            throw new RuntimeException(&quot;Exception while deleting message: &quot; + messageId, e);</span>
<span class="fc" id="L3671">        }</span>
<span class="fc" id="L3672">    }</span>

    public Optional&lt;UUID&gt; getAppointmentUuidForEncounter(@NotNull LoggedInEHRRequestContext requestContext, Long accountId, UUID encounterUniqueId) {
<span class="fc" id="L3675">        return encounterRepository.getAppointmentUuidForEncounter(encounterUniqueId);</span>
    }

    public Long linkAppointmentToEncounter(EHRRequestContext requestContext, Long accountId,
                                           UUID appointmentUniqueId, UUID encounterUniqueId) {
<span class="fc" id="L3680">        EncounterToAppointmentLink link = new EncounterToAppointmentLink();</span>
<span class="fc" id="L3681">        link.setAccountId(accountId);</span>
<span class="fc" id="L3682">        link.setEncounterUniqueId(encounterUniqueId);</span>
<span class="fc" id="L3683">        link.setAppointmentUniqueId(appointmentUniqueId);</span>
<span class="fc" id="L3684">        link.setPersistedDate(Date.from(dateTimeService.now()));</span>
<span class="fc" id="L3685">        return encounterToAppointmentLinkRepository.save(link).getId();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>