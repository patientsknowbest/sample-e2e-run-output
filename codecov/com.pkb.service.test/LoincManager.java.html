<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LoincManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.test</a> &gt; <span class="el_source">LoincManager.java</span></div><h1>LoincManager.java</h1><pre class="source lang-java linenums">package com.pkb.service.test;

import com.pkb.app.dto.SavedIdsDTO;
import com.pkb.app.entity.DTOMapping;
import com.pkb.app.entity.EHRData;
import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.EHRSearch;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.app.entity.PKBFilter;
import com.pkb.app.entity.SourceDetails;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.data.EHRRemote;
import com.pkb.entities.enums.Route;
import com.pkb.exception.PKBPluginException;
import com.pkb.repository.MenuDataRepository;
import com.pkb.repository.legacy.LegacyLoincCommonFormLoincTestRepository;
import com.pkb.repository.legacy.LegacyLoincCommonFormRepository;
import com.pkb.repository.legacy.LegacyLoincMappingRepository;
import com.pkb.repository.legacy.LegacyLoincTestRepository;
import com.pkb.service.uuid.UUIDProvider;
import com.pkb.test.IncludeDeletedResults;
import com.pkb.test.UploadedDataDeletionMetadata;
import com.pkb.test.entity.LoincCommonForm;
import com.pkb.test.entity.LoincMapping;
import com.pkb.test.entity.LoincTest;
import com.pkb.test.entity.TestHistoryDTO;
import com.pkb.test.entity.TestHistoryFilter;
import com.pkb.test.entity.TestResultDTO;
import com.pkb.test.entity.TestResultType;
import com.pkb.user.PKBPersonRemote;
import com.pkb.util.Constants;
import com.pkb.util.DbUtil;
import com.pkb.util.tolven.TolvenBeanFactory;
import com.pkb.util.tolven.TransactionManager;
import io.vavr.Predicates;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.collection.HashMultimap;
import io.vavr.collection.Multimap;
import io.vavr.control.Option;
import org.apache.commons.lang3.StringUtils;
import org.immutables.value.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Timestamp;
import java.text.ParseException;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.pkb.entities.enums.MenuDataType.loincTestResult;
import static com.pkb.test.IncludeDeletedResults.INCLUDE_DELETED;
import static java.lang.String.format;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

public class LoincManager extends TransactionManager {

    private final LegacyLoincTestRepository loincTestRepository;
    private final LegacyLoincCommonFormRepository loincCommonFormRepository;
    private final LegacyLoincCommonFormLoincTestRepository loincCommonFormLoincTestRepository;
    private final LegacyLoincMappingRepository loincMappingRepository;
    private final MenuDataRepository menuDataRepository;
<span class="fc" id="L89">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    public LoincManager(PhrConfig config, TolvenBeanFactory beanFactory, DateTimeService dateTimeService, UUIDProvider uuidProvider,
                        LegacyLoincTestRepository loincTestRepository, LegacyLoincCommonFormRepository loincCommonFormRepository,
                        LegacyLoincCommonFormLoincTestRepository loincCommonFormLoincTestRepository, LegacyLoincMappingRepository loincMappingRepository,
                        MenuDataRepository menuDataRepository) {
<span class="fc" id="L95">        super(config, beanFactory, dateTimeService, uuidProvider);</span>
<span class="fc" id="L96">        this.loincTestRepository = loincTestRepository;</span>
<span class="fc" id="L97">        this.loincCommonFormRepository = loincCommonFormRepository;</span>
<span class="fc" id="L98">        this.loincCommonFormLoincTestRepository = loincCommonFormLoincTestRepository;</span>
<span class="fc" id="L99">        this.loincMappingRepository = loincMappingRepository;</span>
<span class="fc" id="L100">        this.menuDataRepository = menuDataRepository;</span>
<span class="fc" id="L101">    }</span>

    /*
        LoincTest
     */

    public List&lt;LoincTest&gt; getAllLoincTests() {
<span class="fc" id="L108">        return loincTestRepository.getAllByOrderByIdAsc();</span>
    }

    public &lt;A, R&gt; R getLoincTestsByIds(Collection&lt;Long&gt; ids, Collector&lt;LoincTest, A, R&gt; collector) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (isEmpty(ids)) {</span>
<span class="fc" id="L113">            return Stream.&lt;LoincTest&gt;empty().collect(collector);</span>
        }
<span class="fc" id="L115">        return loincTestRepository.getAllByIdInOrderByIdAsc(ids).stream().collect(collector);</span>
    }

    public Map&lt;Long, LoincTest&gt; loadLoincTestsByIds(Map&lt;Long, String&gt; input) {
<span class="fc" id="L119">        Set&lt;Long&gt; ids = input.entrySet().stream()</span>
<span class="fc" id="L120">                .filter(entry -&gt; isNotBlank(entry.getValue()))</span>
<span class="fc" id="L121">                .map(Map.Entry::getKey)</span>
<span class="fc" id="L122">                .collect(toSet());</span>
<span class="fc" id="L123">        return getLoincTestsByIds(ids, Collectors.toMap(LoincTest::getId, identity()));</span>
    }

    public Optional&lt;LoincTest&gt; findLoincTestByLoincCodeAndUnits(@NotNull String loinc, @NotNull String unit) {
<span class="fc" id="L127">        List&lt;LoincTest&gt; results = null;</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (StringUtils.isBlank(unit)) {</span>
<span class="fc" id="L130">            results = loincTestRepository.getAllByLoincAndUnitIsNullOrderByIdAsc(loinc);</span>
        } else {
<span class="fc" id="L132">            results = loincTestRepository.getAllByLoincAndUnitOrderByIdAsc(loinc, unit);</span>
        }

<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (!results.isEmpty()) {</span>
<span class="fc" id="L136">            LoincTest match = results.get(0);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (results.size() &gt; 1) {</span>
<span class="nc" id="L138">                LOGGER.error(&quot;Found {} results for loinc {}, unit {}!&quot;, results.size(), loinc, unit);</span>
            }
<span class="fc" id="L140">            return Optional.of(match);</span>
        }

        // loinc/unit not found
<span class="fc" id="L144">        return Optional.empty();</span>
    }

    public List&lt;LoincTest&gt; findLoincTestsByLoincCodesReturnAllByEmptyList(List&lt;String&gt; loincCodes) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (isNotEmpty(loincCodes)) {</span>
<span class="fc" id="L149">            return DbUtil.getInBatches(loincCodes, loincTestRepository::getAllByLoincInOrderByIdAsc);</span>
        } else {
<span class="nc" id="L151">            return getAllLoincTests();</span>
        }
    }

    public Stream&lt;LoincTest&gt; findLoincTestsByLoincCodesAndUnits(Set&lt;String&gt; loincCodes, Set&lt;String&gt; units) {
<span class="nc" id="L156">        return DbUtil.getInStreamOfBatches(loincCodes, units, loincTestRepository::getAllByLoincInAndUnitIn);</span>
    }

    /**
     * load the LoincTests for the given IDs (if any)
     */
    private Map&lt;Long, LoincTest&gt; getLoincTestMap(List&lt;Long&gt; ids) {
<span class="fc" id="L163">        Map&lt;Long, LoincTest&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (ids.isEmpty()) {</span>
<span class="fc" id="L165">            return map;</span>
        }

        try {
<span class="fc" id="L169">            map = loincTestRepository.getAllByIdInOrderByIdAsc(ids)</span>
<span class="fc" id="L170">                    .stream()</span>
<span class="fc" id="L171">                    .collect(toMap(LoincTest::getId, l -&gt; l));</span>
<span class="nc" id="L172">        } catch (Exception e) {</span>
<span class="nc" id="L173">            throw new RuntimeException(&quot;Error getting loinc tests from id list &quot; + ids, e);</span>
<span class="fc" id="L174">        }</span>
<span class="fc" id="L175">        return map;</span>
    }

    /*
        LoincMapping
     */

    public @Nullable LoincMapping findLoincMapping(long sourceOrgId, String testCode, String testCodingSystem, String unit) {
<span class="fc" id="L183">        List&lt;LoincMapping&gt; results = loincMappingRepository.getLoincMappings(sourceOrgId, testCode, testCodingSystem, unit);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (!results.isEmpty()) {</span>
<span class="fc" id="L185">            LoincMapping match = results.get(0);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if (results.size() &gt; 1) {</span>
<span class="nc" id="L187">                LOGGER.error(&quot;Found {} results for loincmapping {}, system {}, unit {}!&quot;,</span>
<span class="nc" id="L188">                        results.size(), testCode, testCodingSystem, unit);</span>
            }
<span class="fc" id="L190">            return match;</span>
        }
        // no mapping found
<span class="fc" id="L193">        return null;</span>
    }

    public Stream&lt;LoincMapping&gt; findLoincMappings(Set&lt;Long&gt; orgIds, Set&lt;String&gt; testCodes, Set&lt;String&gt; units, String codeSystem) {
<span class="nc" id="L197">        return DbUtil.getInStreamOfBatches(testCodes, orgIds, (testCodeBatch, orgBatch) -&gt;</span>
<span class="nc" id="L198">            loincMappingRepository.getAllLoincMappingsByOrgIdsUnitsTestCodesAndCodingSystem(orgBatch, testCodeBatch, units, codeSystem)</span>
        );
    }

    public List&lt;LoincMapping&gt; addLoincMappings(Collection&lt;LoincMapping&gt; loincMappings) {
<span class="fc" id="L203">        return loincMappingRepository.saveAll(loincMappings);</span>
    }

    public Long addLoincMapping(LoincMapping loincMapping) {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (loincMapping.getId() != null) {</span>
<span class="nc" id="L208">            throw new IllegalArgumentException(&quot;call to createLoincMapping with mapping that already has an ID: &quot; + loincMapping.getId());</span>
        }

        // LoincMapping.unit -- if missing -- is stored as &quot;&quot;, NOT null.
        // ...unlike LoincTest.unit, which is stored null if missing.  Sorry... :(
<span class="fc" id="L213">        loincMapping.setUnit(StringUtils.trimToEmpty(loincMapping.getUnit()));</span>

<span class="fc" id="L215">        loincMapping.setLastUpdated(dateTimeService.now());</span>
<span class="fc" id="L216">        return loincMappingRepository.save(loincMapping).getId();</span>
    }

    public void updateLoincMapping(LoincMapping loincMapping) {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (loincMapping.getId() == null) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;can't update mapping with no ID; &quot; + loincMapping.getTestCodingSystem() + &quot;:&quot; + loincMapping.getTestCode());</span>
        }

<span class="fc" id="L224">        loincMapping.setLastUpdated(dateTimeService.now());</span>
<span class="fc" id="L225">        loincMappingRepository.save(loincMapping);</span>
<span class="fc" id="L226">    }</span>

    public @Nullable TestResultType getTestResultType(long sourceOrgId, String testCode, String testCodingSystem, String unit) {
<span class="fc" id="L229">        Optional&lt;TestResultType&gt; foundType = Optional.empty();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (testCodingSystem.equalsIgnoreCase(LoincTest.CODING_SYSTEM)) {</span>
            // this is now strict on unit
<span class="fc" id="L232">            foundType = findLoincTestByLoincCodeAndUnits(testCode, unit)</span>
<span class="fc" id="L233">                    .map(loincTest -&gt; loincTest);</span>
        }

        // didn't match any LOINC/unit we currently have -- check for a mapping
<span class="fc" id="L237">        return foundType.or(() -&gt; Optional.ofNullable(findLoincMapping(sourceOrgId, testCode, testCodingSystem, unit))).orElse(null);</span>
    }

    public Optional&lt;LoincMapping&gt; getLoincMappingById(long id) {
<span class="nc" id="L241">        return loincMappingRepository.findById(id);</span>
    }

    /*
        LoincCommonForm
     */
    public List&lt;LoincCommonForm&gt; getLoincCommonFormList() {
<span class="fc" id="L248">        return loincCommonFormRepository.getAllByOrderByName().stream()</span>
<span class="fc" id="L249">                .peek(loincCommonForm -&gt; {</span>
<span class="fc" id="L250">                    List&lt;LoincTest&gt; loincTests = loincCommonFormLoincTestRepository.getAllLoincTestsForCommonFormId(loincCommonForm.getId());</span>
<span class="fc" id="L251">                    loincCommonForm.setLoincTestList(loincTests);</span>
<span class="fc" id="L252">                })</span>
<span class="fc" id="L253">                .collect(Collectors.toList());</span>
    }

    public List&lt;LoincCommonForm&gt; getLoincCommonFormsByTestId(long loincTestId) {
<span class="fc" id="L257">        return loincCommonFormRepository.getAllForLoincTestId(loincTestId).stream()</span>
<span class="fc" id="L258">                .peek(loincCommonForm -&gt; {</span>
<span class="fc" id="L259">                    List&lt;LoincTest&gt; loincTests = loincCommonFormLoincTestRepository.getAllLoincTestsForCommonFormId(loincCommonForm.getId());</span>
<span class="fc" id="L260">                    loincCommonForm.setLoincTestList(loincTests);</span>
<span class="fc" id="L261">                })</span>
<span class="fc" id="L262">                .collect(Collectors.toList());</span>
    }

    public Optional&lt;TestResultDTO&gt; findExistingTestResultById(long id, @NotNull LoggedInEHRRequestContext requestContext) {
<span class="fc" id="L266">        EHRSearch&lt;TestResultDTO&gt; search = getLoincTestSearch(Collections.singletonList(id));</span>
<span class="fc" id="L267">        search.setResultsMaxReturned(2);</span>
<span class="fc" id="L268">        return DbUtil.findSingleResult(() -&gt; beanFactory.getEhrRemote().queryDecryptAndPopulateData(search, requestContext));</span>
    }

    public List&lt;TestResultDTO&gt; findExistingTestResultsById(Collection&lt;Long&gt; ids, @NotNull LoggedInEHRRequestContext requestContext) {
<span class="nc" id="L272">        return beanFactory.getEhrRemote().queryDecryptAndPopulateData(getLoincTestSearch(ids), requestContext);</span>
    }

    private EHRSearch&lt;TestResultDTO&gt; getLoincTestSearch(Collection&lt;Long&gt; ids) {
<span class="fc" id="L276">        EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(TestResultDTO.class, Collections.singleton(loincTestResult));</span>
<span class="fc" id="L277">        search.addFilter(new PKBFilter(&quot;id&quot;, PKBFilter.Operator.IN, ids));</span>
<span class="fc" id="L278">        search.setIncludeDeleted(false);</span>
<span class="fc" id="L279">        return search;</span>
    }

    public List&lt;TestResultDTO&gt; getTestResults(@NotNull LoggedInEHRRequestContext requestContext, TestHistoryFilter filter, @Nullable Integer latestResults,
                                              IncludeDeletedResults includeDeletedResults) {
<span class="fc" id="L284">        PKBPersonRemote personBean = beanFactory.getPKBPersonBean();</span>
        try {
<span class="fc" id="L286">            LOGGER.info(&quot;TIMING: start getTestResults&quot;);</span>

<span class="fc" id="L288">            Long accountId = personBean.getDefaultAccountId(filter.getPatientId());</span>

<span class="fc" id="L290">            var loincIdLists = getLoincIdsForAccount(accountId);</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (filter.getLoincMappingServiceName() != null) {</span>
<span class="fc" id="L293">                List&lt;Long&gt; loincMappingIdList = getLoincMappingIdsByServiceName(filter, loincIdLists);</span>

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                if (loincMappingIdList.isEmpty()) {</span>
<span class="nc" id="L296">                    return new ArrayList&lt;&gt;();</span>
                }

<span class="fc" id="L299">                filter.addLoincMappingIdList(loincMappingIdList);</span>
            }


<span class="fc" id="L303">            List&lt;TestResultDTO&gt; resultList = null;</span>

            // no date range required: easy!
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (TestHistoryFilter.RangeType.ALL_RESULTS == filter.getRangeType()) {</span>
<span class="fc" id="L307">                resultList = getTestResultsByStartDate(accountId, null, filter.getLoincIdList(), filter.getLoincMappingIdList(),</span>
                        requestContext, latestResults, includeDeletedResults);
<span class="fc bfc" id="L309" title="All 2 branches covered.">            } else if (TestHistoryFilter.RangeType.LATEST_ONLY == filter.getRangeType()) {</span>
<span class="fc" id="L310">                resultList = getLatestResultPerTest(requestContext, accountId, filter.getLoincIdList(), filter.getLoincMappingIdList(), includeDeletedResults);</span>
            } else {
                // latest X months PER TEST
<span class="fc" id="L313">                Integer xMonths = filter.getRangeMonths();</span>
<span class="fc" id="L314">                resultList = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L316" title="3 of 4 branches missed.">                boolean noIdFilters = ((filter.getLoincIdList() == null) &amp;&amp; (filter.getLoincMappingIdList() == null));</span>

<span class="pc bpc" id="L318" title="2 of 4 branches missed.">                if (noIdFilters || (filter.getLoincIdList() != null)) {</span>
                    // we need a DIFFERENT start date for each test, because we want the latest X months
                    // PER-TEST.  So: custom query to find out the latest result for each test this user has,
                    // and calculate the start date from there.
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">                    var loincIdsToQuery = filter.getLoincIdList() == null ? loincIdLists.getLoincIds() : filter.getLoincIdList();</span>

<span class="fc" id="L324">                    Map&lt;Long, Instant&gt; loincToStartDate = getLoincRangeStartDates(accountId,</span>
                            loincIdsToQuery, xMonths, requestContext);

<span class="fc bfc" id="L327" title="All 2 branches covered.">                    for (Map.Entry&lt;Long, Instant&gt; longDateEntry : loincToStartDate.entrySet()) {</span>
<span class="fc" id="L328">                        resultList.addAll(getTestResultsByStartDate(accountId, longDateEntry.getValue(),</span>
<span class="fc" id="L329">                                Collections.singletonList(longDateEntry.getKey()), null, requestContext, null, includeDeletedResults));</span>
<span class="fc" id="L330">                    }</span>
                }

<span class="pc bpc" id="L333" title="2 of 4 branches missed.">                if (noIdFilters || (filter.getLoincMappingIdList() != null)) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                    var loincMappingIdsToQuery = filter.getLoincMappingIdList() == null ? loincIdLists.getLoincMappingIds() : filter.getLoincMappingIdList();</span>

                    // note that this will skip over loinc mappings where the LOINC is set
<span class="nc" id="L337">                    Map&lt;Long, Instant&gt; mappingToStartDate = getLoincMappingRangeStartDates(accountId,</span>
                            loincMappingIdsToQuery, xMonths, requestContext);

<span class="nc bnc" id="L340" title="All 2 branches missed.">                    for (Map.Entry&lt;Long, Instant&gt; longDateEntry : mappingToStartDate.entrySet()) {</span>
<span class="nc" id="L341">                        resultList.addAll(getTestResultsByStartDate(accountId, longDateEntry.getValue(),</span>
<span class="nc" id="L342">                                null, Collections.singletonList(longDateEntry.getKey()), requestContext, null, includeDeletedResults));</span>
<span class="nc" id="L343">                    }</span>
                }
            }

<span class="fc" id="L347">            LOGGER.info(&quot;Returning {} test results for patientid-{} for range-{}&quot;, resultList.size(), filter.getPatientId(), filter.getRangeType());</span>
<span class="fc" id="L348">            return resultList;</span>
<span class="nc" id="L349">        } catch (Exception e) {</span>
<span class="nc" id="L350">            throw new PKBPluginException(&quot;Exception while getting test results&quot;, e);</span>
        }
    }

    public List&lt;TestHistoryDTO&gt; getTestHistoryList(TestHistoryFilter filter, @NotNull LoggedInEHRRequestContext requestContext,
                                                   Integer latestResults, IncludeDeletedResults deleted) {
        try {
<span class="fc" id="L357">            List&lt;TestResultDTO&gt; resultList = getTestResults(requestContext, filter, latestResults, deleted);</span>

            // sort out what LoincTest and LoincMapping objects we need to load -- group into maps
<span class="fc" id="L360">            Set&lt;Long&gt; loincIdSet = new HashSet&lt;&gt;();</span>
<span class="fc" id="L361">            Set&lt;Long&gt; mappingIdSet = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            for (TestResultDTO result : resultList) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                if (result.getLoincTestId() != null) {</span>
<span class="fc" id="L364">                    loincIdSet.add(result.getLoincTestId());</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">                } else if (result.getLoincMappingId() != null) {</span>
                    // some results will have both -- but here we ignore mapping if LOINC is there
<span class="fc" id="L367">                    mappingIdSet.add(result.getLoincMappingId());</span>
                } else {
<span class="nc" id="L369">                    LOGGER.error(&quot;result {} has a null real for loincId and loincMappingID&quot;, result.getId());</span>
                }
<span class="fc" id="L371">            }</span>
<span class="fc" id="L372">            Map&lt;Long, LoincTest&gt; loincMap = getLoincTestMap(new ArrayList&lt;&gt;(loincIdSet));</span>
<span class="fc" id="L373">            Map&lt;Long, LoincMapping&gt; mappingMap = getLoincMappingMap(new ArrayList&lt;&gt;(mappingIdSet));</span>

<span class="fc" id="L375">            Map&lt;Long, TestHistoryDTO&gt; historiesForLoincIds = new HashMap&lt;&gt;();</span>
<span class="fc" id="L376">            Map&lt;Long, TestHistoryDTO&gt; historiesForMappingIds = new HashMap&lt;&gt;();</span>

            // shuffle results into histories
<span class="fc bfc" id="L379" title="All 2 branches covered.">            for (TestResultDTO result : resultList) {</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                if (result.getLoincTestId() != null) {</span>
<span class="fc" id="L381">                    Long loincId = result.getLoincTestId();</span>
<span class="fc" id="L382">                    TestHistoryDTO history = historiesForLoincIds.get(loincId);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                    if (history == null) {</span>
<span class="fc" id="L384">                        history = new TestHistoryDTO();</span>
<span class="fc" id="L385">                        history.setLoincTest(loincMap.get(loincId));</span>
<span class="fc" id="L386">                        history.setTestResultList(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L387">                        historiesForLoincIds.put(loincId, history);</span>
                    }
<span class="fc" id="L389">                    history.getTestResultList().add(result);</span>
<span class="fc" id="L390">                } else { // no loinc id, only mapping</span>
<span class="fc" id="L391">                    Long mappingId = result.getLoincMappingId();</span>
<span class="fc" id="L392">                    TestHistoryDTO history = historiesForMappingIds.get(mappingId);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                    if (history == null) {</span>
<span class="fc" id="L394">                        history = new TestHistoryDTO();</span>
<span class="fc" id="L395">                        history.setLoincMapping(mappingMap.get(mappingId));</span>
<span class="fc" id="L396">                        history.setTestResultList(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L397">                        historiesForMappingIds.put(mappingId, history);</span>
                    }
<span class="fc" id="L399">                    history.getTestResultList().add(result);</span>
                }
<span class="fc" id="L401">            }</span>

<span class="fc" id="L403">            List&lt;TestHistoryDTO&gt; mergedList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L404">            mergedList.addAll(historiesForLoincIds.values());</span>
<span class="fc" id="L405">            mergedList.addAll(historiesForMappingIds.values());</span>

<span class="fc" id="L407">            LOGGER.info(&quot;Returning {} test histories for patient-{}&quot;, mergedList.size(), filter.getPatientId());</span>
<span class="fc" id="L408">            return mergedList;</span>
<span class="nc" id="L409">        } catch (Exception e) {</span>
<span class="nc" id="L410">            throw new PKBPluginException(&quot;Error getting loinc test history list &quot;, e);</span>
        }
    }

    public void deleteResultsByFillerOrderNumber(LoggedInEHRRequestContext requestContext, UploadedDataDeletionMetadata deletionInfo, long orgId, long patientId) {
<span class="fc" id="L415">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L416">        PKBPersonRemote personBean = beanFactory.getPKBPersonBean();</span>
<span class="fc" id="L417">        String fonToDelete = deletionInfo.getMaybeFillerOrderNumber();</span>
<span class="fc" id="L418">        Long accountId = personBean.getDefaultAccountId(patientId);</span>
<span class="fc" id="L419">        EHRSearch&lt;TestResultDTO&gt; ehrSearch = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="fc" id="L420">        ehrSearch.addFilter(new PKBFilter(TestResultDTO.LAB_ORDER_ID, PKBFilter.Operator.EQUAL, fonToDelete));</span>
<span class="fc" id="L421">        ehrSearch.addFilter(new PKBFilter(SourceDetails.EHRQUERY_ORG_ID, PKBFilter.Operator.EQUAL, orgId));</span>
<span class="fc" id="L422">        ehrSearch.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>
<span class="fc" id="L423">        ehrSearch.setIncludeDeleted(false);</span>
<span class="fc" id="L424">        List&lt;EHRData&gt; ehrDataList = ehrBean.queryAndDecryptEHRData(ehrSearch, requestContext);</span>

<span class="fc" id="L426">        deleteTestResults(requestContext, ehrDataList, deletionInfo);</span>
<span class="fc" id="L427">    }</span>

    public void deleteUploadedTestResults(EHRRequestContext requestContext, long patientId, List&lt;Long&gt; uploadedDataIds) {
        // guard clause -- nothing to delete (and broken sql coming up)
<span class="pc bpc" id="L431" title="2 of 4 branches missed.">        if (uploadedDataIds == null || uploadedDataIds.isEmpty()) {</span>
<span class="fc" id="L432">            return;</span>
        }
<span class="nc" id="L434">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="nc" id="L435">        PKBPersonRemote personBean = beanFactory.getPKBPersonBean();</span>

<span class="nc" id="L437">        Long accountId = personBean.getDefaultAccountId(patientId);</span>
<span class="nc" id="L438">        EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="nc" id="L439">        search.addFilter(new PKBFilter(TestResultDTO.UPLOADED_DATA_ID, PKBFilter.Operator.IN, uploadedDataIds));</span>
<span class="nc" id="L440">        int countDeleted = ehrBean.deleteEHRData(search, requestContext);</span>
<span class="nc" id="L441">        LOGGER.info(&quot;SJG: setting deleted flag for lab results -- affected {} datapoints&quot;, countDeleted);</span>
<span class="nc" id="L442">    }</span>

    public void deleteTestResult(LoggedInEHRRequestContext requestContext, long testResultId, UploadedDataDeletionMetadata deletionMetadata) {
<span class="fc" id="L445">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L446">        EHRData edToDelete = ehrBean.findAndDecryptEHRData(testResultId, requestContext);</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (edToDelete == null) {</span>
<span class="nc" id="L448">            return;</span>
        }
<span class="fc" id="L450">        deleteTestResults(requestContext, List.of(edToDelete), deletionMetadata);</span>
<span class="fc" id="L451">    }</span>

    public List&lt;SavedIdsDTO&gt; saveTestResults(@NotNull LoggedInEHRRequestContext requestContext, List&lt;TestResultDTO&gt; testResults, long patientUserId, Long accountId) {

<span class="fc" id="L455">        return doSaveTestResults(requestContext,</span>
                testResults,
<span class="fc" id="L457">                accountId,</span>
<span class="fc" id="L458">                getTestUpdateOperationBuilder(requestContext, testResults, patientUserId, accountId),</span>
                this::getSaveNewOperation);
    }

    public List&lt;SavedIdsDTO&gt; saveTestResultsNoUpdate(@NotNull EHRRequestContext requestContext, List&lt;TestResultDTO&gt; testResults, long accountId) {
<span class="fc" id="L463">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L464">        Set&lt;String&gt; labOrderIds = getLabResultIdsForTestResults(testResults);</span>
        //This will fail with an exception due to lack of crypto access if there are any pre-existing test results that match
        //on lab order id (i.e. potential updates to existing data). It's not the most
        //elegant way to perform this check but I don't think we have much choice given the data we receive.
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (!labOrderIds.isEmpty()) {</span>
<span class="nc" id="L469">            EHRSearch&lt;TestResultDTO&gt; search = getSearchForLabOrdersForOrg(testResults, accountId, labOrderIds);</span>
<span class="nc" id="L470">            List&lt;EHRData&gt; matchingData = ehrBean.queryEHRData(search, requestContext);</span>
<span class="nc" id="L471">            getLabOrderHistoryMap(matchingData, requestContext);</span>
        }

<span class="fc" id="L474">        return doSaveTestResults(requestContext, testResults, accountId, testResult -&gt; Option.none(), this::getSaveNewOperation);</span>
    }

    /**
     * does NOT yet support filtering on BOTH loincTestIds and loincMappingIds, just one or the other
     */
    private List&lt;TestResultDTO&gt; getTestResultsByStartDate(long accountId, Instant fromDateOrNull,
                                                          List&lt;Long&gt; loincTestIds, List&lt;Long&gt; orLoincMappingIds, LoggedInEHRRequestContext requestContext,
                                                          Integer latestResults, IncludeDeletedResults deleted)
            throws ParseException {

<span class="fc" id="L485">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L486">        EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        search.setIncludeDeleted(deleted == INCLUDE_DELETED);</span>
<span class="fc" id="L488">        search.setLatestPerTypeFilter(EHRData.ENTERED_DATE, EHRData.UNIQUE_ID);</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">        if (loincTestIds != null) {</span>
<span class="fc" id="L491">            search.addFilter(new PKBFilter(TestResultDTO.LOINC_TEST_ID, PKBFilter.Operator.IN, loincTestIds));</span>

            // error if we try to filter on both types of ID, here
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (orLoincMappingIds != null) {</span>
<span class="nc" id="L495">                throw new IllegalArgumentException(&quot;No support yet to filter on BOTH Loinc IDs and mapping IDs&quot;);</span>
            }
<span class="fc bfc" id="L497" title="All 2 branches covered.">        } else if (orLoincMappingIds != null) {</span>
<span class="fc" id="L498">            search.addFilter(new PKBFilter(TestResultDTO.LOINC_MAPPING_ID, PKBFilter.Operator.IN, orLoincMappingIds));</span>
<span class="fc" id="L499">            search.addFilter(new PKBFilter(TestResultDTO.LOINC_TEST_ID, PKBFilter.Operator.IS_NULL, null));</span>
        }

<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (fromDateOrNull != null) {</span>
<span class="fc" id="L503">            search.addFilter(new PKBFilter(TestResultDTO.TEST_DATE, PKBFilter.Operator.GREATER_OR_EQUAL, fromDateOrNull));</span>
        }

<span class="fc" id="L506">        search.setOrderBy(TestResultDTO.TEST_DATE, EHRSearch.OrderByDirection.Asc);</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (latestResults != null) {</span>
<span class="fc" id="L509">            search.setOrderBy(TestResultDTO.TEST_DATE, EHRSearch.OrderByDirection.Desc);</span>
<span class="fc" id="L510">            search.setResultsMaxReturned(latestResults);</span>
        }

<span class="fc" id="L513">        List&lt;EHRData&gt; edList = ehrBean.queryAndDecryptEHRData(search, requestContext);</span>
<span class="fc" id="L514">        List&lt;EHRData&gt; filteredList = edList.stream()</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                .filter(ed -&gt; !ed.getDeleted()</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                        || (ed.getDeleted()</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                        &amp;&amp; ed.getRoute() != Route.SCISTORE</span>
<span class="pc bpc" id="L518" title="2 of 6 branches missed.">                        &amp;&amp; (ed.getSourcePersonId() != null || ed.getSourceTeamId() != null || ed.getSourceOrgId() != null)))</span>
<span class="fc" id="L519">                .collect(toList());</span>
<span class="fc" id="L520">        List&lt;TestResultDTO&gt; dtoList = ehrBean.populateDTOList(filteredList, TestResultDTO.class, requestContext);</span>

<span class="fc" id="L522">        LOGGER.info(&quot;Returning {} test results for account-{}&quot;, dtoList.size(), accountId);</span>
<span class="fc" id="L523">        return dtoList;</span>
    }

    private List&lt;TestResultDTO&gt; getLatestResultPerTest(LoggedInEHRRequestContext context, long accountId,
                                                       List&lt;Long&gt; loincTestIds, List&lt;Long&gt; orLoincMappingIds,
                                                       IncludeDeletedResults deleted) {
        try {
<span class="fc" id="L530">            EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L531">            List&lt;EHRData&gt; allEdMatches = new ArrayList&lt;&gt;();</span>

            // search twice if we need both results with LOINC IDs and those with Mappings only
<span class="fc" id="L534">            LOGGER.info(&quot;TIMING: starting latest loincTest fetch for account-{}&quot;, accountId);</span>
<span class="pc bpc" id="L535" title="3 of 4 branches missed.">            boolean noIdFilters = ((loincTestIds == null) &amp;&amp; (orLoincMappingIds == null));</span>
<span class="pc bpc" id="L536" title="3 of 4 branches missed.">            if ((loincTestIds != null) || noIdFilters) {</span>
<span class="fc" id="L537">                EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">                search.setIncludeDeleted(deleted == INCLUDE_DELETED);</span>
<span class="fc" id="L539">                search.setLatestPerTypeFilter(TestResultDTO.TEST_DATE, TestResultDTO.LOINC_TEST_ID);</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                if (loincTestIds != null) {</span>
<span class="fc" id="L541">                    search.addFilter(new PKBFilter(TestResultDTO.LOINC_TEST_ID, PKBFilter.Operator.IN, loincTestIds));</span>
                } else {
<span class="nc" id="L543">                    search.addFilter(new PKBFilter(TestResultDTO.LOINC_TEST_ID, PKBFilter.Operator.IS_NOT_NULL, null));</span>
                }

<span class="fc" id="L546">                allEdMatches.addAll(ehrBean.queryAndDecryptEHRData(search, context));</span>
            }
<span class="fc" id="L548">            LOGGER.info(&quot;TIMING: starting latest loincTestMapping fetch for account-{}&quot;, accountId);</span>

<span class="pc bpc" id="L550" title="2 of 4 branches missed.">            if ((orLoincMappingIds != null) || noIdFilters) {</span>
<span class="nc" id="L551">                EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                search.setIncludeDeleted(deleted == INCLUDE_DELETED);</span>
<span class="nc" id="L553">                search.setLatestPerTypeFilter(TestResultDTO.TEST_DATE, TestResultDTO.LOINC_MAPPING_ID);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                if (orLoincMappingIds != null) {</span>
<span class="nc" id="L555">                    search.addFilter(new PKBFilter(TestResultDTO.LOINC_MAPPING_ID, PKBFilter.Operator.IN, orLoincMappingIds));</span>
                } else {
<span class="nc" id="L557">                    search.addFilter(new PKBFilter(TestResultDTO.LOINC_MAPPING_ID, PKBFilter.Operator.IS_NOT_NULL, null));</span>
                }

                // ALSO: exclude the ones that also have a LOINC test ID set
<span class="nc" id="L561">                search.addFilter(new PKBFilter(TestResultDTO.LOINC_TEST_ID, PKBFilter.Operator.IS_NULL, null));</span>

<span class="nc" id="L563">                allEdMatches.addAll(ehrBean.queryAndDecryptEHRData(search, context));</span>
            }
<span class="fc" id="L565">            LOGGER.info(&quot;TIMING: finished fetches for account-{}&quot;, accountId);</span>

            // sort (again) by date if we've merged two query result sets
<span class="pc bpc" id="L568" title="3 of 6 branches missed.">            if (noIdFilters || ((loincTestIds != null) &amp;&amp; (orLoincMappingIds != null))) {</span>
<span class="nc" id="L569">                String testDateFieldName = DTOMapping.get(TestResultDTO.class).getEHRDataField(TestResultDTO.TEST_DATE);</span>

<span class="nc" id="L571">                allEdMatches.sort(Comparator.comparing(ed -&gt; ed.getQueryDateField(testDateFieldName)));</span>
            }

<span class="fc" id="L574">            List&lt;TestResultDTO&gt; dtoList = ehrBean.populateDTOList(allEdMatches, TestResultDTO.class, context);</span>

<span class="fc" id="L576">            LOGGER.info(&quot;TIMING: finished sort for account-{}&quot;, accountId);</span>
<span class="fc" id="L577">            return dtoList;</span>
<span class="nc" id="L578">        } catch (Exception e) {</span>
<span class="nc" id="L579">            LOGGER.error(&quot;Exception while getting latest test results{}&quot;, e.getMessage());</span>
<span class="nc" id="L580">            throw new PKBPluginException(&quot;Exception while getting latest test results &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * load the LoincMappings for the given IDs (if any)
     */
    private Map&lt;Long, LoincMapping&gt; getLoincMappingMap(List&lt;Long&gt; ids) {
<span class="fc" id="L588">        Map&lt;Long, LoincMapping&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (ids.isEmpty()) {</span>
<span class="fc" id="L590">            return map;</span>
        }

<span class="fc" id="L593">        List&lt;LoincMapping&gt; list = loincMappingRepository.getAllByIdIn(ids);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (LoincMapping l : list) {</span>
<span class="fc" id="L595">            map.put(l.getId(), l);</span>
<span class="fc" id="L596">        }</span>
<span class="fc" id="L597">        return map;</span>
    }

    private List&lt;Long&gt; getLoincMappingIdsByServiceName(TestHistoryFilter filter, LoincIdLists loincIdLists) {

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (filter.getLoincMappingServiceName() == null) {</span>
<span class="nc" id="L603">            return Collections.emptyList();</span>
        }

<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (filter.getLoincIdList() != null ||</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">                filter.getLoincMappingIdList() != null) {</span>
<span class="nc" id="L608">            throw new RuntimeException(&quot;Filter(s) conflicting with loinc mapping service name set !!!&quot;);</span>
        }

<span class="fc" id="L611">        return loincMappingRepository.getMappingIdsForIdsAndServiceName(loincIdLists.getLoincMappingIds(), filter.getLoincMappingServiceName());</span>
    }

    private Map&lt;Long, Instant&gt; getLoincRangeStartDates(long accountId, List&lt;Long&gt; loincTestIdList, Integer lastXMonthsOfDataPerTest, LoggedInEHRRequestContext requestContext) {
<span class="fc" id="L615">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L616">        EHRSearch&lt;TestResultDTO&gt; search = getSearchOfRangeStartDates(accountId, loincTestIdList, TestResultDTO.LOINC_TEST_ID);</span>
<span class="fc" id="L617">        return ehrBean.queryEHRDataFields(search, requestContext)</span>
<span class="fc" id="L618">                .stream()</span>
<span class="fc" id="L619">                .collect(LinkedHashMap::new, (resultMap, rowMap) -&gt; resultMap.put((Long) rowMap.get(TestResultDTO.LOINC_TEST_ID), getStartDate(rowMap.get(TestResultDTO.TEST_DATE), lastXMonthsOfDataPerTest)), HashMap::putAll);</span>
    }

    private Map&lt;Long, Instant&gt; getLoincMappingRangeStartDates(long accountId, List&lt;Long&gt; loincMappingIdList,
                                                              Integer lastXMonthsOfDataPerTest, LoggedInEHRRequestContext requestContext) {
<span class="nc" id="L624">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="nc" id="L625">        EHRSearch&lt;TestResultDTO&gt; search = getSearchOfRangeStartDates(accountId, loincMappingIdList, TestResultDTO.LOINC_MAPPING_ID);</span>
<span class="nc" id="L626">        search.addFilter(new PKBFilter(TestResultDTO.LOINC_TEST_ID, PKBFilter.Operator.IS_NULL, null));</span>
<span class="nc" id="L627">        return ehrBean.queryEHRDataFields(search, requestContext)</span>
<span class="nc" id="L628">                .stream()</span>
<span class="nc" id="L629">                .collect(LinkedHashMap::new, (resultMap, rowMap) -&gt; resultMap.put((Long) rowMap.get(TestResultDTO.LOINC_MAPPING_ID), getStartDate(rowMap.get(TestResultDTO.TEST_DATE), lastXMonthsOfDataPerTest)), HashMap::putAll);</span>
    }

    private Instant getStartDate(Object input, long months) {
<span class="fc" id="L633">        ZonedDateTime zdt = ZonedDateTime.ofInstant(((Timestamp) input).toInstant(), Constants.APPLICATION_TZ);</span>
<span class="fc" id="L634">        ZonedDateTime xMonthsPrior = zdt.minusMonths(months);</span>
<span class="fc" id="L635">        return xMonthsPrior.toInstant();</span>
    }


    private EHRSearch&lt;TestResultDTO&gt; getSearchOfRangeStartDates(long accountId, List&lt;Long&gt; idList, String idFieldName) {
<span class="fc" id="L640">        EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="fc" id="L641">        search.setLatestPerTypeFilter(TestResultDTO.TEST_DATE, idFieldName);</span>

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (idList != null) {</span>
<span class="fc" id="L644">            search.addFilter(new PKBFilter(idFieldName, PKBFilter.Operator.IN, idList));</span>
        } else {
<span class="nc" id="L646">            search.addFilter(new PKBFilter(idFieldName, PKBFilter.Operator.IS_NOT_NULL, null));</span>
        }
<span class="fc" id="L648">        return search.addFields(idFieldName, TestResultDTO.TEST_DATE);</span>
    }

    private LoincIdLists getLoincIdsForAccount(long accountId) {
        //long01 and long02 are the cleartext migrated storage for loincTestId and loincMappingId respectively
        //This code is a bit hard to read: we're searching for all the distinct non-null values of these two fields
        //but we'd like to avoid doing multiple database queries (this gets called a fair amount)
<span class="fc" id="L655">        List&lt;javax.persistence.Tuple&gt; results = menuDataRepository.findDistinctLong01AndLong02ByDataTypeAndAccountId(loincTestResult, accountId);</span>
<span class="fc" id="L656">        return io.vavr.collection.List.ofAll(results)</span>
<span class="fc" id="L657">                .unzip(result -&gt; Tuple.of((Long) result.get(&quot;long01&quot;), (Long) result.get(&quot;long02&quot;)))</span>
<span class="fc" id="L658">                .apply((list1, list2) -&gt; ImmutableLoincIdLists.of(list1.reject(Predicates.isNull()).distinct(), list2.reject(Predicates.isNull()).distinct()));</span>
    }

    private void deleteTestResults(LoggedInEHRRequestContext requestContext, @NotNull List&lt;EHRData&gt; edsToDelete, UploadedDataDeletionMetadata deletionMetadata) {
<span class="fc" id="L662">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L663">        ehrBean.deleteIBaseDto(requestContext, edsToDelete, deletionMetadata, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="fc" id="L664">    }</span>

    @NotNull
    private Function&lt;TestResultDTO, Option&lt;TestSaveOperation&gt;&gt; getTestUpdateOperationBuilder(@NotNull LoggedInEHRRequestContext requestContext, List&lt;TestResultDTO&gt; testResults,
                                                                                             long patientUserId, long accountId) {
<span class="fc" id="L669">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L670">        Set&lt;String&gt; labOrderIds = getLabResultIdsForTestResults(testResults);</span>


        Multimap&lt;String, TestResultDTO&gt; labOrderExisting;

<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (labOrderIds.isEmpty()) {</span>
<span class="fc" id="L676">            labOrderExisting = HashMultimap.withSeq().empty();</span>
        } else {
<span class="fc" id="L678">            EHRSearch&lt;TestResultDTO&gt; search = getSearchForLabOrdersForOrg(testResults, accountId, labOrderIds);</span>
<span class="fc" id="L679">            List&lt;EHRData&gt; matchingData = ehrBean.queryAndDecryptEHRData(search, requestContext);</span>
<span class="fc" id="L680">            labOrderExisting = getLabOrderHistoryMap(matchingData, requestContext);</span>
        }

<span class="fc" id="L683">        List&lt;Long&gt; testResultIds = testResults.stream()</span>
<span class="fc" id="L684">                .map(TestResultDTO::getId)</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">                .filter(id -&gt; id != null)</span>
<span class="fc" id="L686">                .collect(toList());</span>

        Map&lt;Long, TestResultDTO&gt; existingTestResultsById;
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        if (testResultIds.isEmpty()) {</span>
<span class="fc" id="L690">            existingTestResultsById = Collections.emptyMap();</span>
        } else {
<span class="nc" id="L692">            existingTestResultsById = findExistingTestResultsById(testResultIds, requestContext).stream()</span>
<span class="nc" id="L693">                    .collect(toMap(TestResultDTO::getId, identity()));</span>
        }

<span class="fc" id="L696">        return testResult -&gt; findMatchingTestResult(testResult, labOrderExisting, existingTestResultsById)</span>
<span class="fc" id="L697">                .map(existingResultData -&gt; buildUpdateOperation(testResult, existingResultData, patientUserId, accountId));</span>
    }

    @NotNull
    private TestSaveOperation buildUpdateOperation(TestResultDTO testResult, TestResultDTO existingDTO, long patientUserId, long accountId) {
        // is this an EXACT dupe record?  equals() only checks type, value (num/text), timestamp
        // here, isDuplicate() checks everything except id, uploadedDataId, source/history fields, and privacy flags
<span class="fc" id="L704">        boolean duplicate = existingDTO.isDuplicate(testResult);</span>
<span class="fc" id="L705">        boolean hasPrivacyUpdate = existingDTO.hasPrivacyFlagChange(testResult);</span>

<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (duplicate) {</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">            return hasPrivacyUpdate ? new PrivacyFlagOnlyUpdateTestOperation(testResult, existingDTO)</span>
<span class="fc" id="L709">                    : new SkipDuplicateOperation(testResult, existingDTO);</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        } else if (testResult.getBaseFields().isDeleted()) {</span>
<span class="nc" id="L711">            return new DeleteTestOperation(testResult, existingDTO);</span>
        }

<span class="fc" id="L714">        LOGGER.info(&quot;Updating existing result for patient-{} account-{}&quot;, patientUserId, accountId);</span>
<span class="fc" id="L715">        return new UpdateTestOperation(testResult, existingDTO);</span>
    }

    private final class PrivacyFlagOnlyUpdateTestOperation extends UpdateTestOperation {
<span class="fc" id="L719">        private PrivacyFlagOnlyUpdateTestOperation(@NotNull TestResultDTO newDTO, @NotNull TestResultDTO previousDTO) {</span>
<span class="fc" id="L720">            super(newDTO, previousDTO);</span>
<span class="fc" id="L721">            LOGGER.info(&quot;saving privacy-only changes to {}&quot;, previousDTO.getId());</span>
<span class="fc" id="L722">        }</span>

        // HACKERY AFOOT!!
        // If we are correcting a lab result, we store the id of the result it is replacing.
        // This allows a change history to be maintained, and the UI uses the existence
        // of this information to display a little [C] change notifier.
        // However, if we have changed the privacy flag (and *only* the privacy flag), we
        // still want to create a new record for changelog purposes but we don't want the
        // UI to flag it as a correction.
        // If there is *already* a correction in the history of this item, we must continue
        // to show the [C] after a privacy flag change, which means we must carry over the
        // last replacement id.
        // The logic is therefore:
        // If a previous item exists,
        //    -&gt; if it already has a replacement timestamp set, we must carry it over
        //    -&gt; if it doesn't have a replacement timestamp,
        //        -&gt; and this is a data change, we must set the timestamp
        //        -&gt; and this is a privacy flag change, we do *not* set the timestamp
        //
        // This is basically dealing with the specific case where a piece of data has *not*
        // been corrected, but *has* changed privacy. In that case, the UI needs to not show
        // the [C] indicator. Yes, I am aware this is not an area of code that should be
        // worried about what the UI is up to, but it has to be done here because otherwise
        // the UI does not have enough info to make the decision. See PHR-360
        @Override
        boolean shouldSetReplacementDetailsOnNewDTO(boolean dataEditedInPast) {
<span class="fc" id="L748">            return dataEditedInPast;</span>
        }
    }

    private void logChanges(TestResultDTO testResult, TestResultDTO matchDto) {
<span class="fc" id="L753">        LOGGER.info(</span>
                &quot;Test Result has changed:\nNew result id={} testDate-{} uploadeddataid-{} labOrderId-{} source-{}\nOld result id={} testDate-{} uploadeddataid-{} labOrderId-{} source-{}&quot;,
<span class="fc" id="L755">                String.valueOf(testResult.getId()),</span>
<span class="fc" id="L756">                testResult.getTestDate(),</span>
<span class="fc" id="L757">                testResult.getBaseFields().getUploadedDataId(),</span>
<span class="fc" id="L758">                testResult.getLabOrderId(),</span>
<span class="fc" id="L759">                testResult.getSource().toString(),</span>
<span class="fc" id="L760">                matchDto.getId(),</span>
<span class="fc" id="L761">                matchDto.getTestDate(),</span>
<span class="fc" id="L762">                matchDto.getBaseFields().getUploadedDataId(),</span>
<span class="fc" id="L763">                matchDto.getLabOrderId(),</span>
<span class="fc" id="L764">                matchDto.getSource().toString());</span>
<span class="fc" id="L765">    }</span>

    private Option&lt;TestResultDTO&gt; findMatchingTestResult(TestResultDTO testResult, Multimap&lt;String, TestResultDTO&gt; existingTestResultsByLabOrder,
                                                         Map&lt;Long, TestResultDTO&gt; existingTestResultsById) {
<span class="fc" id="L769">        Predicate&lt;TestResultDTO&gt; testResultTypeMatch = existingTestResultDTO -&gt; existingTestResultDTO.isTestResultTypeMatchIgnoringUnits(testResult);</span>

<span class="fc" id="L771">        return Option.of(testResult.getId())</span>
<span class="pc" id="L772">                .flatMap(id -&gt; Option.of(existingTestResultsById.get(id)))</span>
<span class="fc" id="L773">                .orElse(() -&gt; existingTestResultsByLabOrder.get(testResult.getLabOrderId())</span>
<span class="fc" id="L774">                        .flatMap(existingTestResults -&gt; existingTestResults.find(testResultTypeMatch))</span>
                );
    }

    /**
     * Optimized for the assumption that it's quite rare to get updates to existing results
     * For each UNIQUE labOrderId in the dtoList (probably just one) get the existing test results in the DB, if any.
     *
     * @param requestContext
     * @param testResults
     * @return
     */
    private Multimap&lt;String, TestResultDTO&gt; getLabOrderHistoryMap(List&lt;EHRData&gt; matchingData, @NotNull EHRRequestContext requestContext) {
<span class="fc" id="L787">        return queryEHRAndTypedData(matchingData, TestResultDTO.class, requestContext)</span>
<span class="fc" id="L788">                .stream()</span>
<span class="fc" id="L789">                .map(matchingTestResult -&gt; Tuple.of(matchingTestResult._1.getLabOrderId(), matchingTestResult._1))</span>
<span class="fc" id="L790">                .collect(HashMultimap.withSeq().collector());</span>
    }

    public EHRSearch&lt;TestResultDTO&gt; getSearchForLabOrdersForOrg(@NotNull List&lt;TestResultDTO&gt; testResults, long accountId, Set&lt;String&gt; labOrderIds) {
<span class="fc" id="L794">        long orgId = getSourceOrgIdAndCheckConsistent(testResults);</span>
<span class="fc" id="L795">        EHRSearch&lt;TestResultDTO&gt; search = new EHRSearch&lt;&gt;(accountId, TestResultDTO.class, TestResultDTO.MS_PATH);</span>
<span class="fc" id="L796">        search.addFilter(new PKBFilter(TestResultDTO.LAB_ORDER_ID, PKBFilter.Operator.IN, labOrderIds));</span>
<span class="fc" id="L797">        search.addFilter(new PKBFilter(SourceDetails.EHRQUERY_ORG_ID, PKBFilter.Operator.EQUAL, orgId));</span>
<span class="fc" id="L798">        search.setIncludeDeleted(true);</span>
<span class="fc" id="L799">        return search;</span>
    }

    private Set&lt;String&gt; getLabResultIdsForTestResults(@NotNull List&lt;TestResultDTO&gt; testResults) {
<span class="fc" id="L803">        return testResults.stream()</span>
<span class="fc" id="L804">                .map(TestResultDTO::getLabOrderId)</span>
<span class="fc" id="L805">                .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L806">                .collect(Collectors.toUnmodifiableSet());</span>
    }

    private &lt;D&gt; List&lt;Tuple2&lt;D, EHRData&gt;&gt; queryEHRAndTypedData(List&lt;EHRData&gt; matchingData, Class&lt;D&gt; dtoClass, @NotNull EHRRequestContext requestContext) {
<span class="fc" id="L810">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>
<span class="fc" id="L811">        List&lt;D&gt; dtos = ehrBean.populateDTOList(matchingData, dtoClass, requestContext);</span>
<span class="fc" id="L812">        return io.vavr.collection.List.ofAll(dtos).zip(matchingData).toJavaList();</span>
    }

    private long getSourceOrgIdAndCheckConsistent(@NotNull List&lt;TestResultDTO&gt; testResults) {
<span class="fc" id="L816">        return testResults.stream().map(testResult -&gt; testResult.getSource().getOrgId()).reduce((orgId1, orgId2) -&gt; {</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">            if (!orgId1.equals(orgId2)) {</span>
<span class="nc" id="L818">                throw new RuntimeException(format(&quot;List of test results supplied to save don't all have the same source org id : %s&quot;, testResults));</span>
            }
<span class="fc" id="L820">            return orgId1;</span>
<span class="fc" id="L821">        }).orElseThrow();</span>
    }

    private List&lt;SavedIdsDTO&gt; doSaveTestResults(@NotNull EHRRequestContext requestContext, List&lt;TestResultDTO&gt; testResults, long accountId,
                                                Function&lt;TestResultDTO, Option&lt;TestSaveOperation&gt;&gt; updateOperationBuilder, Function&lt;TestResultDTO, Option&lt;TestSaveOperation&gt;&gt; saveNewOperationBuilder) {
<span class="fc" id="L826">        EHRRemote ehrBean = beanFactory.getEhrRemote();</span>

<span class="fc" id="L828">        List&lt;TestSaveOperation&gt; saveOperations = testResults</span>
<span class="fc" id="L829">                .stream()</span>
<span class="fc" id="L830">                .map(this::ensureFieldsPopulatedCorrectly)</span>
<span class="fc" id="L831">                .map(testResult -&gt; updateOperationBuilder.apply(testResult)</span>
<span class="fc" id="L832">                        .orElse(saveNewOperationBuilder.apply(testResult))</span>

                )
<span class="fc" id="L835">                .filter(Option::isDefined)</span>
<span class="fc" id="L836">                .map(Option::get)</span>
<span class="fc" id="L837">                .collect(Collectors.toUnmodifiableList());</span>

<span class="fc" id="L839">        List&lt;TestResultDTO&gt; dtosToSave = saveOperations.stream().map(TestSaveOperation::getDTOToSave)</span>
<span class="fc" id="L840">                .filter(Predicates.isNotNull())</span>
<span class="fc" id="L841">                .collect(Collectors.toUnmodifiableList());</span>
<span class="fc" id="L842">        ehrBean.saveDtoList(requestContext, dtosToSave, accountId, TestResultDTO.MS_PATH);</span>

<span class="fc" id="L844">        return saveOperations.stream().map(TestSaveOperation::getSavedIdsDTO).collect(Collectors.toUnmodifiableList());</span>
    }

    private TestResultDTO ensureFieldsPopulatedCorrectly(TestResultDTO testResult) {
        // ensure some basic fields are set
<span class="fc" id="L849">        testResult.getBaseFields().generateNewRandomUniqueId();</span>

        // tidy up (for dupe check) -- any blank string fields will be saved as null anyway:
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (isBlank(testResult.getComments())) {</span>
<span class="fc" id="L853">            testResult.setComments(null);</span>
        }
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (isBlank(testResult.getTextValue())) {</span>
<span class="fc" id="L856">            testResult.setTextValue(null);</span>
        }
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">        if (isBlank(testResult.getTextRange())) {</span>
<span class="fc" id="L859">            testResult.setTextRange(null);</span>
        }
<span class="fc" id="L861">        return testResult;</span>
    }

    private Option&lt;TestSaveOperation&gt; getSaveNewOperation(TestResultDTO testResult) {
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (testResult.getBaseFields().isDeleted()) {</span>
<span class="nc" id="L866">            LOGGER.warn(&quot;Trying to add a record that deletes a nonexistent test result with lab order id {}&quot;, testResult.getLabOrderId());</span>
<span class="nc" id="L867">            return Option.none();</span>
        }
<span class="fc" id="L869">        return Option.of(new SaveNewTestOperation(testResult));</span>
    }

    private abstract class TestSaveOperation {
        final TestResultDTO newDTO;
        final TestResultDTO previousDTO;

        @NotNull
        SavedIdsDTO getSavedIdsDTO() {
<span class="fc" id="L878">            return new SavedIdsDTO(newDTO.getId(), newDTO.getBaseFields().getUniqueId());</span>
        }

        TestResultDTO getDTOToSave() {
<span class="fc" id="L882">            return newDTO;</span>
        }

<span class="fc" id="L885">        TestSaveOperation(TestResultDTO newDTO, TestResultDTO previousDTO) {</span>
<span class="fc" id="L886">            this.newDTO = newDTO;</span>
<span class="fc" id="L887">            this.previousDTO = previousDTO;</span>
<span class="fc" id="L888">            newDTO.getBaseFields().setUniqueId(previousDTO.getBaseFields().getUniqueId());</span>
<span class="fc" id="L889">        }</span>

<span class="fc" id="L891">        TestSaveOperation(TestResultDTO newDTO) {</span>
<span class="fc" id="L892">            this.newDTO = newDTO;</span>
<span class="fc" id="L893">            this.previousDTO = null;</span>
<span class="fc" id="L894">        }</span>
    }

    private final class SaveNewTestOperation extends TestSaveOperation {
<span class="fc" id="L898">        SaveNewTestOperation(TestResultDTO newDTO) {</span>
<span class="fc" id="L899">            super(newDTO);</span>
<span class="fc" id="L900">        }</span>
    }

    private final class DeleteTestOperation extends TestSaveOperation {
<span class="nc" id="L904">        private DeleteTestOperation(TestResultDTO newDTO, TestResultDTO previousDTO) {</span>
<span class="nc" id="L905">            super(newDTO, previousDTO);</span>
<span class="nc" id="L906">        }</span>
    }

    private class UpdateTestOperation extends TestSaveOperation {

<span class="fc" id="L911">        UpdateTestOperation(@NotNull TestResultDTO newDTO, @NotNull TestResultDTO previousDTO) {</span>
<span class="fc" id="L912">            super(newDTO, previousDTO);</span>
            //We should be saving a new record rather than updating the old row
<span class="fc" id="L914">            newDTO.setId(null);</span>
<span class="fc" id="L915">            logChanges(newDTO, previousDTO);</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">            Instant replacementTs = newDTO.getBaseFields().getEnteredDate() != null ? newDTO.getBaseFields().getEnteredDate().toInstant() : dateTimeService.now();</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">            boolean dataEditedInPast = previousDTO.getReplacementTimestamp() != null;</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">            if (shouldSetReplacementDetailsOnNewDTO(dataEditedInPast)) {</span>
<span class="fc" id="L919">                newDTO.setReplacementTimestamp(replacementTs);</span>
            }
<span class="fc" id="L921">        }</span>

        boolean shouldSetReplacementDetailsOnNewDTO(boolean dataEditedInPast) {
<span class="fc" id="L924">            return true;</span>
        }
    }

    private final class SkipDuplicateOperation extends TestSaveOperation {
<span class="fc" id="L929">        SkipDuplicateOperation(TestResultDTO newDTO, TestResultDTO previousDTO) {</span>
<span class="fc" id="L930">            super(newDTO, previousDTO);</span>
<span class="fc" id="L931">            newDTO.setId(previousDTO.getId());</span>
<span class="fc" id="L932">        }</span>

        @Override
        @Nullable
        TestResultDTO getDTOToSave() {
<span class="fc" id="L937">            return null;</span>
        }
    }

    @Value.Immutable
    @Value.Style(
            // Generate construction method using all attributes as parameters
            allParameters = true,
            // We may also disable builder
            defaults = @Value.Immutable(builder = false))
    interface LoincIdLists {
        List&lt;Long&gt; getLoincIds();

        List&lt;Long&gt; getLoincMappingIds();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>