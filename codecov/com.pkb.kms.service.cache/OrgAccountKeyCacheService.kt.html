<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrgAccountKeyCacheService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.kms.service.cache</a> &gt; <span class="el_source">OrgAccountKeyCacheService.kt</span></div><h1>OrgAccountKeyCacheService.kt</h1><pre class="source lang-java linenums">package com.pkb.kms.service.cache

import com.pkb.common.ClearableInternalState
import com.pkb.crypto.AccountPrivateKey
import com.pkb.crypto.EncryptedAccountPrivateKey
import com.pkb.crypto.UserPrivateKey
import com.pkb.kms.service.AccountPath
import com.pkb.kms.service.EncryptedOrgAccountKey
import com.pkb.kms.service.MetricsHelper
import com.pkb.kms.service.OrgAccountKey
import com.pkb.kms.service.extension.encryptedAccountPrivateKey
import com.pkb.kms.service.repository.AccountOrgRepository
import com.pkb.kms.shared.KMS_CACHE_PREFIX
import com.pkb.kms.shared.representation.AccountPublicId
import com.pkb.kms.shared.representation.KmsError
import com.pkb.kms.shared.representation.KmsError.Companion.orgAccountPrivateKeyNotCached
import com.pkb.kms.shared.representation.OrgPrivateId
import io.vavr.control.Either
import io.vavr.kotlin.left
import io.vavr.kotlin.right
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.cache.annotation.CacheEvict
import org.springframework.cache.annotation.CachePut
import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.lang.invoke.MethodHandles

<span class="fc" id="L30">@Service</span>
<span class="fc" id="L31">class OrgAccountKeyCacheService(private val accountOrgRepository: AccountOrgRepository,</span>
<span class="fc" id="L32">                                private val kmsCacheManager: KmsCacheManager,</span>
                                metrics: MetricsHelper) : ClearableInternalState {

<span class="fc" id="L35">    private val log: Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())</span>

<span class="fc" id="L37">    init {</span>
<span class="fc" id="L38">        metrics.registerCaches(ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME)</span>
<span class="fc" id="L39">    }</span>

    @Cacheable(ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME, key = &quot;#accountPath.orgAccountKey.orgId&quot;, unless = &quot;#result.isLeft()&quot;)
    fun getOrDecryptOrgAccountKey(userPrivateKey: UserPrivateKey, accountPath: AccountPath) =
<span class="fc" id="L43">            decryptOrgAccountKey(userPrivateKey, accountPath)</span>

    /**
     * Decrypts the org account key in [accountPath] with [userPrivateKey] and caches the result
     */
    @CachePut(ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME, key = &quot;#accountPath.orgAccountKey.orgId&quot;, unless = &quot;#result.isLeft()&quot;)
    fun decryptOrgAccountKey(userPrivateKey: UserPrivateKey,
                             accountPath: AccountPath): Either&lt;KmsError, OrgAccountKey&gt; =
<span class="pc bpc" id="L51" title="2 of 4 branches missed.">            accountPath.orgAccountKey?.let {</span>
<span class="fc" id="L52">                val orgAccountKey = userPrivateKey.decryptAccountPrivateKey(it.encryptedAccountPrivateKey)</span>
<span class="fc" id="L53">                right(OrgAccountKey(it.orgId, orgAccountKey))</span>
<span class="nc" id="L54">            } ?: left(KmsError(&quot;org.access.missing&quot;,</span>
<span class="nc" id="L55">                    &quot;No org access for ${accountPath.requester} to ${accountPath.accountPublicId}&quot;,</span>
<span class="pc" id="L56">                    KmsError.Type.NOT_AUTHORISED))</span>

    /**
     * Decrypts [encryptedOrgAccountKey] with [userPrivateKey] and caches the result
     */
    @CachePut(ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME, key = &quot;#encryptedOrgAccountKey.orgId&quot;, unless = &quot;#result.isLeft()&quot;)
    fun decryptOrgAccountKey(userPrivateKey: UserPrivateKey,
                             encryptedOrgAccountKey: EncryptedOrgAccountKey): Either&lt;KmsError, OrgAccountKey&gt; =
<span class="fc" id="L64">            right&lt;KmsError, OrgAccountKey&gt;(OrgAccountKey(</span>
<span class="fc" id="L65">                    orgId = encryptedOrgAccountKey.orgId,</span>
<span class="fc" id="L66">                    accountPrivateKey = userPrivateKey.decryptAccountPrivateKey(encryptedOrgAccountKey.encryptedAccountPrivateKey)))</span>
<span class="fc" id="L67">                    .peek { log.info(&quot;Decrypted org account key for org ${encryptedOrgAccountKey.orgId}&quot;) }</span>

    /**
     * Returns the plaintext org account key for [orgId] if it is in the cache
     */
    @Cacheable(ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME, key = &quot;#orgId&quot;, unless = &quot;#result.isLeft()&quot;)
    fun getCachedOrgAccountKey(orgId: OrgPrivateId): Either&lt;KmsError, OrgAccountKey&gt; =
<span class="fc" id="L74">            left(orgAccountPrivateKeyNotCached(orgId))</span>


    /**
     * Batch version of getCachedOrgAccountKey, bypassing the spring cache abstraction to
     * fetch directly from the backing Map implementation. Results in fewer round trips to Redis.
     */
    fun getCachedOrgAccountKeys(keys: Collection&lt;OrgPrivateId&gt;): List&lt;OrgAccountKey&gt; =
<span class="fc" id="L82">            kmsCacheManager.getAll&lt;Any, Either&lt;KmsError, OrgAccountKey&gt;&gt;(ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME, keys)</span>
<span class="fc" id="L83">                    .values.flatMap { it.asIterable() }</span>

    /**
     * Removes all cached org account private keys
     */
    @CacheEvict(cacheNames = [ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME], allEntries = true)
    override fun clearState() {
<span class="fc" id="L90">        log.warn(&quot;Cache cleared&quot;)</span>
<span class="fc" id="L91">    }</span>

    /**
     * Removes the cached org account private key for [orgId]
     */
    @CacheEvict(cacheNames = [ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME], key = &quot;#orgId&quot;)
    fun evictOrgAccountKey(orgId: Long) {
<span class="nc" id="L98">        log.debug(&quot;Evicted org account key for org $orgId from cache&quot;)</span>
<span class="nc" id="L99">    }</span>

    /**
     * Returns a list of [EncryptedOrgAccountKey]s for orgs that retain a copy of the private key for [accountPublicId]
     *
     * A caller can then examine the cache to see if any of the org account keys are currently available to use to gain
     * access to the account
     */
    fun findOrgKeysWithAccessToAccountKey(accountPublicId: AccountPublicId): List&lt;EncryptedOrgAccountKey&gt; =
<span class="fc" id="L108">            accountOrgRepository.findByPublicAccountId(accountPublicId)</span>
<span class="fc" id="L109">                    .map { EncryptedOrgAccountKey(it.orgId, it.accountPrivateKey!!.encryptedAccountPrivateKey()) }</span>
<span class="fc" id="L110">                    .apply {</span>
<span class="fc bfc" id="L111" title="All 4 branches covered.">                        if (this.isNotEmpty()) {</span>
<span class="fc" id="L112">                            log.debug(&quot;Account $accountPublicId can be accessed via orgs ${this.map { it.orgId }}&quot;)</span>
                        } else {
<span class="fc" id="L114">                            log.debug(&quot;Account $accountPublicId is not accessible via any org&quot;)</span>
                        }
<span class="fc" id="L116">                    }</span>

    fun findOrgIdsWithAccessToAccounts(accountPublicIds: List&lt;AccountPublicId&gt;): Map&lt;AccountPublicId, List&lt;OrgPrivateId&gt;&gt; {
<span class="fc" id="L119">        return accountOrgRepository.findByPublicAccountIds(accountPublicIds)</span>
<span class="fc" id="L120">                .groupBy { it.accountPublicId }</span>
<span class="fc" id="L121">                .mapValues { it.value.map { it.orgPrivateId } }</span>
    }

    /**
     * Returns the private key for [accountPublicId] decrypted using [orgAccountKey]
     *
     * @sample com.pkb.kms.service.IndividuallyAccessibleAccountKeyCacheService.decryptAccountPrivateKey(java.util.UUID)
     */
    fun findAndDecryptAccountKey(orgAccountKey: OrgAccountKey, accountPublicId: AccountPublicId): Either&lt;KmsError, AccountPrivateKey&gt; =
<span class="fc" id="L130">            with(orgAccountKey) {</span>
<span class="fc" id="L131">                findOrgCopyOfAccountKey(orgId, accountPublicId)</span>
<span class="fc" id="L132">                        .map { accountPrivateKey.decryptAccountPrivateKey(it) }</span>
<span class="fc" id="L133">                        .peek { log.trace(&quot;Loaded and decrypted private key for account $accountPublicId via org $orgId&quot;) }</span>
<span class="fc" id="L134">            }</span>

    fun findAndDecryptAccountKeys(orgAccountKey: OrgAccountKey, accountPublicIds: List&lt;AccountPublicId&gt;): Map&lt;AccountPublicId, AccountPrivateKey&gt; =
<span class="fc" id="L137">        with(orgAccountKey) {</span>
<span class="fc" id="L138">            accountOrgRepository.findByOrgIdAndPublicAccountIds(orgId, accountPublicIds)</span>
<span class="fc" id="L139">                .mapNotNull{</span>
<span class="fc" id="L140">                    try {</span>
<span class="fc" id="L141">                        it.account.publicId to accountPrivateKey.decryptAccountPrivateKey(it.accountOrg.accountPrivateKey!!.encryptedAccountPrivateKey())</span>
                    }
<span class="nc" id="L143">                    catch(e: Exception) {</span>
<span class="nc" id="L144">                        log.error(&quot;Error decrypting key for account {} with key from org {}&quot;, it.account.id, orgId, e)</span>
<span class="pc" id="L145">                        null</span>
                    }
                }
<span class="fc" id="L148">                .associate { it }</span>
<span class="fc" id="L149">        }</span>

    /**
     * Find a record in core.account_org containing [orgId]'s copy of [accountPublicId]'s private key
     */
    private fun findOrgCopyOfAccountKey(orgId: Long, accountPublicId: AccountPublicId): Either&lt;KmsError, EncryptedAccountPrivateKey&gt; =
<span class="fc" id="L155">            accountOrgRepository.findByOrgIdAndPublicAccountId(orgId, accountPublicId)</span>
<span class="fc" id="L156">                    .map { it.accountPrivateKey!!.encryptedAccountPrivateKey() }</span>
<span class="fc" id="L157">                    .map { right&lt;KmsError, EncryptedAccountPrivateKey&gt;(it) }</span>
<span class="pc" id="L158">                    .orElseGet { left(orgAccountPrivateKeyNotCached(orgId)) }</span>



    @Transactional(readOnly = true)
    fun triggerForAllOrgAccessibleAccounts(orgPrivateId: OrgPrivateId, handler: (accountPublicId: AccountPublicId) -&gt; Unit) =
<span class="fc" id="L164">            accountOrgRepository.findByOrgPublicId(orgPrivateId)</span>
<span class="fc" id="L165">                    .forEach(handler)</span>

    companion object {
        const val ORG_ACCOUNT_PRIVATE_KEY_CACHE_NAME = &quot;${KMS_CACHE_PREFIX}_orgAccountKey&quot;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>