<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserAccessibleAccountPrivateKeyCacheService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.kms.service.cache</a> &gt; <span class="el_source">UserAccessibleAccountPrivateKeyCacheService.kt</span></div><h1>UserAccessibleAccountPrivateKeyCacheService.kt</h1><pre class="source lang-java linenums">package com.pkb.kms.service.cache

import com.pkb.common.ClearableInternalState
import com.pkb.crypto.UserPrivateKey
import com.pkb.crypto.dto.AccountKeysDTO
import com.pkb.crypto.dto.AccountPrivateKeyDTO
import com.pkb.crypto.dto.AccountPrivateKeyDTO.accountPrivateKeyDTO
import com.pkb.kms.service.AccountPath
import com.pkb.kms.service.AccountPrivateKeyDecryptorService
import com.pkb.kms.service.MetricsHelper
import com.pkb.kms.shared.KMS_CACHE_PREFIX
import com.pkb.kms.shared.representation.AccountPublicId
import com.pkb.kms.shared.representation.KmsError
import io.vavr.control.Either
import io.vavr.kotlin.left
import io.vavr.kotlin.right
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.cache.annotation.CacheEvict
import org.springframework.cache.annotation.CachePut
import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Service
import java.lang.invoke.MethodHandles
import java.util.stream.Collectors

/**
 * Wraps AccountPrivateKeyDTO with it's cache status
 */
<span class="fc" id="L29">data class AccountPrivateKeyResult(val accountPrivateKeyDTO: AccountPrivateKeyDTO,</span>
<span class="fc" id="L30">                                   val wasCached: Boolean)</span>
typealias AccountPrivateKeysResults = Map&lt;AccountPublicId, Either&lt;KmsError, AccountPrivateKeyResult&gt;&gt;

/**
 * Account private key cache for keys that are not currently accessible via org, and therefore must not be allowed
 * to expire
 */
<span class="fc" id="L37">@Service</span>
<span class="fc" id="L38">class UserAccessibleAccountPrivateKeyCacheService(private val decryptorService: AccountPrivateKeyDecryptorService,</span>
<span class="fc" id="L39">                                                  private val cacheManager: KmsCacheManager,</span>
                                                  metricsHelper: MetricsHelper) : ClearableInternalState,
        IsAccountKeyCache {

<span class="fc" id="L43">    private val log: Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())</span>

<span class="fc" id="L45">    init {</span>
<span class="fc" id="L46">        metricsHelper.registerCaches(USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME)</span>
<span class="fc" id="L47">    }</span>

    /**
     * Returns plaintext key for an account. Will use cached copy if available.
     *
     * If not cached, will attempt to decrypt the account key with the user key.
     */
    @Cacheable(
            USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME,
            key = &quot;#accountPath.accountPublicId&quot;,
            unless = &quot;#result.isLeft()&quot;)
    fun getAccountPrivateKeyInPath(userPrivateKey: UserPrivateKey,
                                   accountPath: AccountPath): Either&lt;KmsError, AccountPrivateKeyDTO&gt; =
<span class="fc" id="L60">            decryptorService.decryptAccountPrivateKeyForUser(userPrivateKey, accountPath)</span>
<span class="fc" id="L61">                    .map { accountPrivateKeyDTO(it) }</span>

    /**
     * Batch &amp; parallelised version of the above, minimises round trips to redis.
     * All the account paths must be accessible to the given user
     */
    fun getAccountPrivateKeysInPath(userPrivateKey: UserPrivateKey, accountPaths: List&lt;AccountPath&gt;): AccountPrivateKeysResults {
        // Check the cache for existing entries
<span class="fc" id="L69">        val accountPublicIds = accountPaths.map { it.accountPublicId }</span>
<span class="fc" id="L70">        val cached = cacheManager.getAll&lt;AccountPublicId, Either&lt;KmsError, AccountPrivateKeyDTO&gt;&gt;(USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME, accountPublicIds)</span>
<span class="fc" id="L71">                .mapValues { it.value.map { AccountPrivateKeyResult(it, wasCached = true) } }</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        val nonCachedAccountPaths = accountPaths.filter { it.accountPublicId !in cached.keys }</span>

        // Decrypt any we didn't have cached already
        // Use parallel stream for maximum speed in CPU bound operation
<span class="fc" id="L76">        val decryptResults = nonCachedAccountPaths.parallelStream()</span>
<span class="fc" id="L77">                .collect(Collectors.toMap&lt;AccountPath, AccountPath, Either&lt;KmsError, AccountPrivateKeyResult&gt;&gt;({ it }, { accountPath -&gt;</span>
<span class="fc" id="L78">                    try {</span>
<span class="fc" id="L79">                        decryptorService.decryptAccountPrivateKeyForUser(userPrivateKey, accountPath)</span>
<span class="fc" id="L80">                                .map { AccountPrivateKeyResult(accountPrivateKeyDTO(it), wasCached = false) }</span>
<span class="fc" id="L81">                    } catch (e: Exception) {</span>
<span class="fc" id="L82">                        Either.left(KmsError(&quot;unexpected.exception&quot;,</span>
<span class="fc" id="L83">                                &quot;Unexpected exception ${e.javaClass} ${e.message} decrypting account keys ${accountPath.accountPublicId}&quot;,</span>
<span class="fc" id="L84">                                KmsError.Type.UNEXPECTED))</span>
                    }
<span class="fc" id="L86">                })).also { decryptResults -&gt;</span>
                    // Careful to transform to the correct object type for the map
<span class="fc" id="L88">                    val successes = decryptResults</span>
<span class="fc" id="L89">                            .filter { it.value.isRight }</span>
<span class="fc" id="L90">                            .mapValues { Either.right&lt;KmsError, AccountPrivateKeyDTO&gt;(it.value.get().accountPrivateKeyDTO) }</span>
<span class="fc" id="L91">                            .mapKeys { it.key.accountPublicId }</span>
<span class="fc bfc" id="L92" title="All 4 branches covered.">                    if (successes.isNotEmpty()) {</span>
                        // Add anything we newly successfully decrypted to the cache
<span class="fc" id="L94">                        cacheManager.putAll(USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME, successes)</span>
                    }
<span class="fc" id="L96">                }</span>
        // return everything we got from cache + decrypting
<span class="fc" id="L98">        return cached + decryptResults.mapKeys { it.key.accountPublicId }</span>
    }

    @Cacheable(
            USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME,
            key = &quot;#accountPublicId&quot;,
            unless = &quot;#result.isLeft()&quot;)
    fun getCachedAccountPrivateKey(accountPublicId: AccountPublicId): Either&lt;KmsError, AccountPrivateKeyDTO&gt; =
<span class="fc" id="L106">            left(KmsError.accountPrivateKeyNotCached(accountPublicId))</span>

    fun getCachedAccountPrivateKeys(accountPublicIds: List&lt;AccountPublicId&gt;): Map&lt;AccountPublicId, AccountPrivateKeyDTO&gt; =
<span class="fc" id="L109">        cacheManager.getAll&lt;AccountPublicId, Either&lt;KmsError, AccountPrivateKeyDTO&gt;&gt;(USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME, accountPublicIds)</span>
<span class="fc" id="L110">            .mapValues { it.value.get() }</span>

    @CacheEvict(cacheNames = [USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME], allEntries = true)
    override fun clearState() {
<span class="fc" id="L114">        log.warn(&quot;Cache cleared&quot;)</span>
<span class="fc" id="L115">    }</span>

    @CacheEvict(cacheNames = [USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME], key = &quot;#accountPublicId&quot;)
    override fun evictKeysForAccount(accountPublicId: AccountPublicId) {
<span class="nc" id="L119">        log.debug(&quot;Evicted keys for account $accountPublicId from cache&quot;)</span>
<span class="nc" id="L120">    }</span>

    /**
     * Stores an account private key in the cache with no further processing (mainly used when migrating keys from the
     * legacy cache)
     */
    @CachePut(
            USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME,
            key = &quot;#accountKeysDTO.accountPublicId&quot;,
            unless = &quot;#result.isLeft()&quot;)
    fun addToCache(accountKeysDTO: AccountKeysDTO): Either&lt;KmsError, AccountPrivateKeyDTO&gt; =
<span class="fc" id="L131">        right(accountKeysDTO.privateKey)</span>

    companion object {
        const val USER_ACCESSIBLE_ACCOUNT_PRIVATE_KEY_CACHE_NAME = &quot;${KMS_CACHE_PREFIX}_userAccessibleAccountPrivateKey&quot;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>