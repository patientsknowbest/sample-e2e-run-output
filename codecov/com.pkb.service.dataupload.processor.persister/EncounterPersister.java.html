<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EncounterPersister.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.dataupload.processor.persister</a> &gt; <span class="el_source">EncounterPersister.java</span></div><h1>EncounterPersister.java</h1><pre class="source lang-java linenums">package com.pkb.service.dataupload.processor.persister;

import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.app.entity.SourceDetails;
import com.pkb.calendar.entity.AppointmentDTO;
import com.pkb.calendar.entity.AppointmentRequestDTO;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.dataupload.entity.UploadedData;
import com.pkb.dataupload.entity.UploadedDataDTO;
import com.pkb.encounter.entity.Encounter;
import com.pkb.encounter.entity.Message;
import com.pkb.entities.enums.AppointmentStatus;
import com.pkb.exception.PKBException;
import com.pkb.service.calendar.impl.AppointmentService;
import com.pkb.service.calendar.impl.CalendarManager;
import com.pkb.service.code.CodeManager;
import com.pkb.service.dataupload.hl7.field.HL7Code;
import com.pkb.service.dataupload.processor.LoggedInUploadedDataProcessingContext;
import com.pkb.service.dataupload.processor.UploadedDataProcessingContext;
import com.pkb.service.dataupload.processor.domain.UploadedDataPersistentState;
import com.pkb.service.dataupload.processor.domain.UploadedEncounter;
import com.pkb.service.dataupload.processor.support.EncounterMessageFilter;
import com.pkb.service.encounter.EncounterMessageHelper;
import com.pkb.service.encounter.impl.tolven.EncounterManager;
import com.pkb.user.entity.PKBPerson;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;

@SuppressWarnings({&quot;ClassWithTooManyMethods&quot;, &quot;OverlyComplexClass&quot;})
@Component
public class EncounterPersister extends AbstractUploadedDataPersister&lt;UploadedEncounter, LoggedInUploadedDataProcessingContext&gt; {
<span class="fc" id="L49">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    private final EncounterMessageFilter messageFilter;
    private final DateTimeService dateTimeService;
    private final AppointmentService appointmentService;
    private final CodeManager codeManager;
    private final CalendarManager calendarManager;
    private final EncounterManager encounterManager;

    @Autowired
    public EncounterPersister(EncounterMessageFilter messageFilter, DateTimeService dateTimeService, AppointmentService appointmentService,
<span class="fc" id="L60">                              CodeManager codeManager, @Lazy CalendarManager calendarManager, @Lazy EncounterManager encounterManager) {</span>
<span class="fc" id="L61">        this.messageFilter = messageFilter;</span>
<span class="fc" id="L62">        this.dateTimeService = dateTimeService;</span>
<span class="fc" id="L63">        this.appointmentService = appointmentService;</span>
<span class="fc" id="L64">        this.codeManager = codeManager;</span>
<span class="fc" id="L65">        this.calendarManager = calendarManager;</span>
<span class="fc" id="L66">        this.encounterManager = encounterManager;</span>
<span class="fc" id="L67">    }</span>

    @Override
    public UploadedDataPersistentState doPersist(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, List&lt;UploadedEncounter&gt; data) {
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if (data.size() &gt; 1) {</span>
<span class="nc" id="L72">            throw new IllegalStateException(&quot;Only one encounter can be persisted at once currently&quot;);</span>
        }
        UploadedDataPersistentState result;
<span class="fc" id="L75">        Optional&lt;UploadedEncounter&gt; uploadedEncounter = data.stream().findFirst();</span>

<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (uploadedEncounter.isPresent()) {</span>
<span class="fc" id="L78">            SourceDetails sourceDetails = new SourceDetails(dto);</span>
<span class="fc" id="L79">            result = new UploadedDataPersistentState(doPersist(context, dto, uploadedEncounter.get()),</span>
                    UploadedDataPersistentState.UploadedDataPersistentStateEnum.CREATED_OR_UPDATED);
<span class="fc" id="L81">        } else {</span>
<span class="nc" id="L82">            result = new UploadedDataPersistentState(UploadedData.Status.COMPLETED, UploadedDataPersistentState.UploadedDataPersistentStateEnum.NO_OP);</span>
        }
<span class="fc" id="L84">        return result;</span>

    }

    private UploadedData.Status doPersist(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, UploadedEncounter uploadedEncounter) {
<span class="pc bpc" id="L89" title="1 of 12 branches missed.">        switch (uploadedEncounter.getEncounterRequestType()) {</span>
            case ADMIT:
<span class="fc" id="L91">                admit(context, uploadedEncounter);</span>
<span class="fc" id="L92">                break;</span>
            case ADMIT_CANCEL:
<span class="fc" id="L94">                admitCancel(context, uploadedEncounter);</span>
<span class="fc" id="L95">                break;</span>
            case TRANSFER:
<span class="fc" id="L97">                doCreateOrUpdateEncounterWithMessage(context, uploadedEncounter, uploadedEncounter.getEncounterEvent());</span>
<span class="fc" id="L98">                break;</span>
            case TRANSFER_CANCEL:
<span class="fc" id="L100">                transferCancel(context, uploadedEncounter);</span>
<span class="fc" id="L101">                break;</span>
            case DISCHARGE:
<span class="fc" id="L103">                discharge(context, uploadedEncounter);</span>
<span class="fc" id="L104">                break;</span>
            case DISCHARGE_CANCEL:
<span class="fc" id="L106">                dischargeCancel(context, uploadedEncounter);</span>
<span class="fc" id="L107">                break;</span>
            case INFORMATION_UPDATE:
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if (uploadedEncounter.getEncounter() != null) {</span>
<span class="fc" id="L110">                    createOrUpdateEncounterWithMessage(context, uploadedEncounter);</span>
<span class="fc" id="L111">                    doCreateOrUpdateEncounterWithMessage(context, uploadedEncounter, uploadedEncounter.getEncounterEvent());</span>
                }
                break;
            case PRE_ADMIT:
<span class="fc" id="L115">                preAdmit(context, dto, uploadedEncounter);</span>
<span class="fc" id="L116">                break;</span>
            case PRE_ADMIT_CANCEL:
<span class="fc" id="L118">                preAdmitCancel(context, dto, uploadedEncounter);</span>
<span class="fc" id="L119">                break;</span>
            case PENDING_ADMIT:
<span class="fc" id="L121">                pendingAdmit(context, dto, uploadedEncounter);</span>
<span class="fc" id="L122">                break;</span>
            case PENDING_ADMIT_CANCEL:
<span class="fc" id="L124">                pendingAdmissionCancel(context, dto, uploadedEncounter);</span>
<span class="fc" id="L125">                break;</span>
            default:
<span class="nc" id="L127">                throw new IllegalArgumentException(String.format(&quot;Failed to save processed uploaded data. Unknown action: %s&quot;, uploadedEncounter.getEncounterRequestType()));</span>
        }
<span class="fc" id="L129">        return UploadedData.Status.COMPLETED;</span>
    }

    private void admit(LoggedInUploadedDataProcessingContext context, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L133">        overrideMessages(context, uploadedEncounter, Message.MessageType.PATIENT_ADMIT);</span>
<span class="fc" id="L134">        doCreateOrUpdateEncounterWithMessage(context, uploadedEncounter, uploadedEncounter.getEncounterEvent());</span>
<span class="fc" id="L135">    }</span>

    private void admitCancel(UploadedDataProcessingContext context, UploadedEncounter uploadedEncounter) {

<span class="fc" id="L139">        Encounter encounter = uploadedEncounter.getEncounter();</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (encounter == null) {</span>
            // No original admit encounter, mark this as complete
<span class="fc" id="L143">            return;</span>
        }

        // We look for a single message of type PATIENT_ADMIT (A01)
<span class="fc" id="L147">        List&lt;Message&gt; messagesToCancel = filterMessages(encounter.getMessages(), Message.MessageType.PATIENT_ADMIT, true, false);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (messagesToCancel.isEmpty()) {</span>
<span class="fc" id="L149">            return;</span>
        }

<span class="fc" id="L152">        deleteEncounterMessage(encounter, messagesToCancel.get(0).getId());</span>
<span class="fc" id="L153">    }</span>

    private void createOrUpdateEncounterWithMessage(LoggedInUploadedDataProcessingContext context, UploadedEncounter uploadedEncounter) {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (uploadedEncounter.getMessages() != null) {</span>
<span class="fc" id="L157">            uploadedEncounter.getMessages().forEach(message -&gt; doCreateOrUpdateEncounterWithMessage(context, uploadedEncounter, message));</span>
        }
<span class="fc" id="L159">    }</span>

    private void preAdmit(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L162">        scheduleAdmission(context, dto, uploadedEncounter);</span>
<span class="fc" id="L163">    }</span>

    private void preAdmitCancel(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L166">        Encounter encounter = uploadedEncounter.getEncounter();</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (encounter == null) {</span>
            // No original pre-admit encounter, mark this as complete
<span class="fc" id="L170">            return;</span>
        }

        // We look for a single message of type PATIENT_PRE_ADMIT (A05)
<span class="fc" id="L174">        List&lt;Message&gt; messageCandidates = filterMessages(encounter.getMessages(), Message.MessageType.PATIENT_PRE_ADMIT, true, false);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (messageCandidates.isEmpty()) {</span>
<span class="fc" id="L176">            return;</span>
        }
<span class="fc" id="L178">        SourceDetails sourceDetails = new SourceDetails(dto);</span>
        // First we cancel any appointment record that might (does) exist for a pre-admit (A05) message candidate
<span class="fc" id="L180">        cancelAppointmentForPatientScheduledAdmission(sourceDetails, context.requestContext(), context.patientAccountId(), encounter);</span>
        // Then cancel the pre-admit (A05) message itself
<span class="fc" id="L182">        deleteEncounterMessage(encounter, messageCandidates.get(0).getId());</span>
<span class="fc" id="L183">    }</span>

    private void pendingAdmit(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L186">        scheduleAdmission(context, dto, uploadedEncounter);</span>
<span class="fc" id="L187">    }</span>

    /**
     * ADT^A27
     */
    private void pendingAdmissionCancel(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L193">        Encounter encounter = uploadedEncounter.getEncounter();</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (encounter == null) {</span>
            // No original pending-admit encounter, mark this as complete
<span class="fc" id="L197">            return;</span>
        }

        // We look for a single message of type PATIENT_PENDING_ADMIT (A14)
<span class="fc" id="L201">        List&lt;Message&gt; messageCandidates = filterMessages(encounter.getMessages(), Message.MessageType.PATIENT_PENDING_ADMIT, true, false);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (messageCandidates.isEmpty()) {</span>
<span class="fc" id="L203">            return;</span>
        }
<span class="fc" id="L205">        boolean cancelAppointment = false;</span>
        // If there is no A05 and there is an appointment that this A14 would then have created we should cancel it
<span class="fc" id="L207">        List&lt;Message&gt; existingA05Candidates = filterMessages(encounter.getMessages(), Message.MessageType.PATIENT_PRE_ADMIT);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (existingA05Candidates.isEmpty()) {</span>
<span class="fc" id="L209">            cancelAppointment = true;</span>
        }

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (cancelAppointment) {</span>
            // Cancel any appointment record that might exist
<span class="fc" id="L214">            SourceDetails sourceDetails = new SourceDetails(dto);</span>
<span class="fc" id="L215">            cancelAppointmentForPatientScheduledAdmission(sourceDetails, context.requestContext(), context.patientAccountId(), encounter);</span>
        }

<span class="fc" id="L218">        deleteEncounterMessage(encounter, messageCandidates.get(0).getId());</span>
<span class="fc" id="L219">    }</span>

    private void transferCancel(LoggedInUploadedDataProcessingContext context, UploadedEncounter uploadedEncounter) {

<span class="fc" id="L223">        Encounter encounter = uploadedEncounter.getEncounter();</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (encounter == null) {</span>
            // No original transfer encounter, mark this as complete
<span class="fc" id="L227">            return;</span>
        }

        // We look for 1 or more messages of type PATIENT_TRANSFER (A02)
<span class="fc" id="L231">        List&lt;Message&gt; existingTransfers = filterMessages(encounter.getMessages(), Message.MessageType.PATIENT_TRANSFER, true, true);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (existingTransfers.isEmpty()) {</span>
<span class="nc" id="L233">            return;</span>
        }

<span class="fc" id="L236">        existingTransfers.sort(Collections.reverseOrder(new MessageDateComparator()));</span>

        // XXX Implement iteration through the existing transfers looking for a match on PV1 data?

        // Current handling is to simply cancel most recently received transfer
<span class="fc" id="L241">        Message messageToCancel = existingTransfers.get(0);</span>

<span class="fc" id="L243">        deleteEncounterMessage(encounter, messageToCancel.getId());</span>
<span class="fc" id="L244">    }</span>

    private void discharge(LoggedInUploadedDataProcessingContext context, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L247">        overrideMessages(context, uploadedEncounter, Message.MessageType.PATIENT_DISCHARGE);</span>

<span class="fc" id="L249">        doCreateOrUpdateEncounterWithMessage(context, uploadedEncounter, uploadedEncounter.getEncounterEvent());</span>
<span class="fc" id="L250">    }</span>

    private void dischargeCancel(LoggedInUploadedDataProcessingContext context, UploadedEncounter uploadedEncounter) {

<span class="fc" id="L254">        Encounter encounter = uploadedEncounter.getEncounter();</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (encounter == null) {</span>
            // No original discharge encounter, mark this as complete
<span class="fc" id="L258">            return;</span>
        }

        // We look for a single message of type PATIENT_DISCHARGE (A03)
<span class="fc" id="L262">        List&lt;Message&gt; messagesToCancel = filterMessages(encounter.getMessages(), Message.MessageType.PATIENT_DISCHARGE, true, false);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (messagesToCancel.isEmpty()) {</span>
<span class="fc" id="L264">            return;</span>
        }

<span class="fc" id="L267">        deleteEncounterMessage(encounter, messagesToCancel.get(0).getId());</span>
<span class="fc" id="L268">    }</span>

    private List&lt;Message&gt; filterMessages(List&lt;Message&gt; messages, Message.MessageType messageType, boolean allowEmpty, boolean allowMultiple) {
<span class="fc" id="L271">        return messageFilter.filterMessages(messages, messageType, allowEmpty, allowMultiple);</span>
    }

    private List&lt;Message&gt; filterMessages(List&lt;Message&gt; messages, Message.MessageType messageType) {
<span class="fc" id="L275">        return messageFilter.filterMessages(messages, messageType);</span>
    }

    private void overrideMessages(UploadedDataProcessingContext context, UploadedEncounter uploadedEncounter, Message.MessageType messageType) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (uploadedEncounter.getEncounter() != null) {</span>
            // We accept multiple A01's but each will be treated as a complete update to the existing
<span class="fc" id="L281">            Optional&lt;UUID&gt; uniqueId = overrideExistingMessage(context.requestContext(), messageType, uploadedEncounter.getEncounter());</span>
<span class="fc" id="L282">            uniqueId.ifPresent(u -&gt; uploadedEncounter.getEncounterEvent().getBaseFields().setUniqueId(u));</span>
        }
<span class="fc" id="L284">    }</span>

    private UUID doCreateOrUpdateEncounterWithMessage(LoggedInUploadedDataProcessingContext context, UploadedEncounter uploadedEncounter, Message message) {
        // Create new Encounter if one isn't existing
<span class="fc" id="L288">        UUID encounterUniqueId = null;</span>
<span class="pc" id="L289">        codeManager.getCode(message.getReasonCode()).ifPresent(value -&gt; message.setReasonCodeId(value.getId()));</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (uploadedEncounter.getEncounter() == null) {</span>
<span class="fc" id="L292">            LOGGER.debug(&quot;This message is the first for the Encounter.&quot;);</span>
<span class="fc" id="L293">            encounterUniqueId = saveEncounter(context.requestContext(), Optional.ofNullable(context.patient())</span>
<span class="fc" id="L294">                            .map(PKBPerson::getId)</span>
<span class="pc" id="L295">                            .orElseThrow(() -&gt; new IllegalStateException(&quot;Unable to save encounter due to missing patient&quot;))</span>
<span class="fc" id="L296">                            .toString(),</span>
<span class="fc" id="L297">                    List.of(message));</span>
<span class="fc" id="L298">            LOGGER.debug(&quot;Created new Encounter with Unique ID: {}&quot;, encounterUniqueId);</span>
        } else {
<span class="fc" id="L300">            LOGGER.debug(&quot;Saving a message for existing Encounter: {}&quot;, uploadedEncounter.getEncounter().getEncounterUniqueId());</span>
<span class="fc" id="L301">            encounterUniqueId = encounterManager.updateEncounter(</span>
<span class="fc" id="L302">                    context.requestContext(),</span>
<span class="fc" id="L303">                    Optional.ofNullable(context.patient())</span>
<span class="fc" id="L304">                            .map(PKBPerson::getId)</span>
<span class="pc" id="L305">                            .orElseThrow(() -&gt; new IllegalStateException(&quot;Unable to update encounter due to missing patient&quot;))</span>
<span class="fc" id="L306">                            .toString(),</span>
<span class="fc" id="L307">                    uploadedEncounter.getEncounter().getEncounterUniqueId(),</span>
<span class="fc" id="L308">                    List.of(message));</span>
<span class="fc" id="L309">            LOGGER.debug(&quot;Update an Encounter with new message. Encounter UniqueID return value: {}&quot;, encounterUniqueId);</span>
        }

<span class="fc" id="L312">        return encounterUniqueId;</span>
    }

    private UUID saveEncounter(EHRRequestContext requestContext, String patientId, List&lt;Message&gt; messagesOrNull) {
        try {
<span class="fc" id="L317">            return encounterManager.saveEncounter(requestContext, patientId, messagesOrNull);</span>
<span class="nc" id="L318">        } catch (Exception e) {</span>
<span class="nc" id="L319">            throw new RuntimeException(&quot;Exception while saving encounter for patientId-&quot; + patientId, e);</span>
        }
    }

    /**
     * Wrapper for delete that will also remove an ENCOUNTER_DETAILS message if one
     * exists to completely void the encounter.
     * &lt;p&gt;
     * Only applies if the encounter is comprised of a message corresponding to the messageId
     * to delete and a message of type ENCOUNTER_DETAILS.
     * &lt;p&gt;
     * Some ADT encounters used ENCOUNTER_DETAILS messages
     * as control messages that weren't for display. This was causing conflicts with other
     * sourced encounters that actually make use of ENCOUNTER_DETAILS messages.
     * &lt;p&gt;
     * ADT encounters no longer create a message of type ENCOUNTER_DETAILS to keep encounter state
     * information. This method will only apply to older encounters that did create this message.
     * &lt;p&gt;
     * This should only be used by handlers that need this logic applied.
     *
     * @param requestContext
     * @param encounter
     * @param messageId
     */
    private void deleteEncounterMessage(Encounter encounter, Long messageId) {

<span class="fc" id="L345">        List&lt;Long&gt; messagesToDelete = Arrays.asList(messageId);</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (encounter.getMessages().size() == 2) { // assume these are: our message to delete and one other (potentially an ENCOUNTER_DETAILS message)</span>
<span class="nc" id="L347">            Message encounterDetails = null;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            for (Message m : encounter.getMessages()) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (!Objects.equals(m.getId(), messageId)) {</span>
                    // could be our additional ENCOUNTER_DETAILS message that needs to be deleted
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (m.getMessageType() == Message.MessageType.ENCOUNTER_DETAILS) {</span>
<span class="nc" id="L352">                        encounterDetails = m;</span>
<span class="nc" id="L353">                        break;</span>
                    }
                }
<span class="nc" id="L356">            }</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">            if ((encounterDetails != null) &amp;&amp; (!Objects.equals(encounterDetails.getId(), messageId))) {</span>
<span class="nc" id="L358">                messagesToDelete.add(encounterDetails.getId());</span>
            }
        }

<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (Long id : messagesToDelete) {</span>
<span class="fc" id="L363">            deleteMessage(id);</span>
<span class="fc" id="L364">        }</span>
<span class="fc" id="L365">    }</span>

    public void deleteMessage(Long messageId) {
        try {
<span class="fc" id="L369">            encounterManager.deleteMessage(messageId);</span>
<span class="nc" id="L370">        } catch (Exception e) {</span>
<span class="nc" id="L371">            throw new RuntimeException(&quot;Exception while deleting Encounter message by messageId: &quot; + messageId, e);</span>
<span class="fc" id="L372">        }</span>
<span class="fc" id="L373">    }</span>

    /**
     * For when we only want a single message of the provided messageType, a subsequently received
     * message of this type causes the existing to be overridden completely. This method looks for
     * an existing message and if found returns the message data point uniqueId.
     * &lt;p&gt;
     * XXX Implement versioning here rather than delete
     *
     * @param requestContext
     * @param messageType
     * @param encounter
     * @return uniqueId of message to overwrite
     */
    public Optional&lt;UUID&gt; overrideExistingMessage(EHRRequestContext requestContext, Message.MessageType messageType, Encounter encounter) {

        // We look for a possible pre-existing message to overwrite, expect 0 or 1 but allow multiple from older more permissive code
        // precondition: 0 or 1 pre-existing messages of type messageType and deleted = false
<span class="fc" id="L391">        List&lt;Message&gt; existing = messageFilter.filterMessages(encounter.getMessages(), messageType);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (!existing.isEmpty()) {</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">            if (existing.size() &gt; 1) {</span>
                // Did not meet pre-condition, warn and handle this unexpected edge case as follows
<span class="nc" id="L395">                LOGGER.warn(</span>
                        &quot;We have multiple encounter messages when single expected - from more permissive older code, we should clear them out and continue with just the one received.&quot;);
<span class="nc" id="L397">                UUID uniqueId = null;</span>
                // if they all share the same uniqueId, we'll return this value but if the messages
                // returned don't share the same uniqueId (i.e. are distinct data points) we can't
                // reliably make use of any of these and so delete them all and start with a fresh data point.
<span class="nc" id="L401">                boolean uniqueIdsMatch = true;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                for (Message m : existing) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if (uniqueId == null) {</span>
<span class="nc" id="L404">                        uniqueId = m.getBaseFields().getUniqueId();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                    } else if (uniqueIdsMatch) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                        if (!uniqueId.equals(m.getBaseFields().getUniqueId())) {</span>
<span class="nc" id="L407">                            uniqueIdsMatch = false;</span>
                        }
                    }
<span class="nc" id="L410">                    deleteEncounterMessage(encounter, m.getId());</span>
<span class="nc" id="L411">                }</span>
                // we now return with or without a uniqueId depending on above
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (uniqueIdsMatch) {</span>
<span class="nc" id="L414">                    return Optional.of(uniqueId);</span>
                }
<span class="nc" id="L416">            } else {</span>
<span class="fc" id="L417">                deleteEncounterMessage(encounter, existing.get(0).getId());</span>
<span class="fc" id="L418">                return Optional.of(existing.get(0).getBaseFields().getUniqueId());</span>
            }
        }

<span class="fc" id="L422">        return Optional.empty();</span>
    }

    /**
     * Used in handleEncounterCancel to sort messages based on messageTimestamp.
     */
<span class="fc" id="L428">    private class MessageDateComparator implements Comparator&lt;Message&gt;, Serializable {</span>

        @Override
        public int compare(Message m1, Message m2) {
<span class="nc" id="L432">            return m1.getMessageTimestamp().compareTo(m2.getMessageTimestamp());</span>
        }
    }

    private void scheduleAdmission(LoggedInUploadedDataProcessingContext context, UploadedDataDTO dto, UploadedEncounter uploadedEncounter) {
<span class="fc" id="L437">        overrideMessages(context, uploadedEncounter, uploadedEncounter.getEncounterEvent().getMessageType());</span>

<span class="fc" id="L439">        UUID encounterUniqueId = doCreateOrUpdateEncounterWithMessage(context, uploadedEncounter, uploadedEncounter.getEncounterEvent());</span>

<span class="fc" id="L441">        createOrUpdateAppointmentForScheduledEncounter(</span>
<span class="fc" id="L442">                context.requestContext(),</span>
<span class="fc" id="L443">                context.patient(),</span>
<span class="fc" id="L444">                context.patientAccountId(),</span>
                dto,
<span class="fc" id="L446">                uploadedEncounter.getEncounterEvent(),</span>
                encounterUniqueId,
<span class="fc" id="L448">                uploadedEncounter.getCustomAppointmentTypeCode());</span>
<span class="fc" id="L449">    }</span>

    /**
     * For any ADT Message that is scheduled to occur in the future (A05 and A14)
     * we add a calendar entry for the patient and link it back to the encounter
     * so we can track any updates.
     */
    private void createOrUpdateAppointmentForScheduledEncounter(@NotNull LoggedInEHRRequestContext requestContext,
                                                                          PKBPerson patient, Long accountId,
                                                                          UploadedDataDTO dto, Message message, UUID encounterUniqueId,
                                                                          @Nullable HL7Code customAppointmentCode) {

        // Look up an existing Appointment that might already be linked to the specific encounter message
<span class="fc" id="L462">        var appointmentUuid = encounterManager.getAppointmentUuidForEncounter(requestContext, accountId, encounterUniqueId);</span>
<span class="fc" id="L463">        var existing = calendarManager.getAppointmentByUniqueId(requestContext, appointmentUuid.orElse(null), accountId);</span>

<span class="fc" id="L465">        LOGGER.info(&quot;Is there an existing appointment for account ID {} and encounterUniqueId {} ? {}&quot;, accountId, encounterUniqueId, (existing.isPresent()));</span>

<span class="fc" id="L467">        AppointmentDTO appointment = new AppointmentDTO(new SourceDetails(dto));</span>

<span class="fc" id="L469">        appointment.setPatientId(patient.getIdString());</span>
<span class="fc" id="L470">        appointment.setPersonId(patient.getIdString());</span>
<span class="fc" id="L471">        appointment.setStartTimestamp(message.getMessageTimestamp());</span>
<span class="fc" id="L472">        appointment.setDescription(null); // no appointment description as we don't get enough info in ADT messages (A05/A14's).</span>
<span class="fc" id="L473">        appointment.setSubject(EncounterMessageHelper.makeEncounterAppointmentSubject(message.getEncounterClass()));</span>
<span class="fc" id="L474">        appointment.setLocation(message.getLocation().getDescription());</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (customAppointmentCode != null) {</span>
<span class="fc" id="L476">            appointment.setTypeCode(customAppointmentCode.getId().toString());</span>
<span class="fc" id="L477">            appointment.setTypeCodingSystem(customAppointmentCode.getCodingSystem().toString());</span>
        }

        // We create an appointment DTO for this patient and save it
<span class="fc" id="L481">        appointment.getBaseFields().setUploadedDataId(dto.getId());</span>
<span class="fc" id="L482">        appointment.getBaseFields().generateNewRandomUniqueId();</span>
        // TODO: Is there a field we should be using for enteredDate, from the HL7 spec? (We don't currently have one in our S12 message)
<span class="fc" id="L484">        appointment.getBaseFields().setEnteredDate(Date.from(dateTimeService.now()));</span>
<span class="fc" id="L485">        appointment.getBaseFields().setPersistedDate(Date.from(dateTimeService.now()));</span>

        // Privacy labels
<span class="fc" id="L488">        message.getBaseFields().copyConsentFlags(appointment.getBaseFields());</span>

<span class="fc" id="L490">        AppointmentRequestDTO req = new AppointmentRequestDTO(new SourceDetails(dto));</span>
<span class="fc" id="L491">        req.setParticipantId(patient.getIdString());</span>
<span class="fc" id="L492">        req.setParticipant(patient);</span>
<span class="fc" id="L493">        req.setCommonId(UUID.randomUUID().toString());</span>
<span class="fc" id="L494">        req.getBaseFields().generateNewRandomUniqueId();</span>
        // Since this is coming into a patient's account from an external source,
        // normal behaviour is to set acceptance status to PENDING. The patient can then accept or decline.
<span class="fc" id="L497">        List&lt;AppointmentRequestDTO&gt; reqList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L498">        reqList.add(req);</span>
<span class="fc" id="L499">        appointment.setAppointmentRequestList(reqList);</span>

<span class="fc bfc" id="L501" title="All 2 branches covered.">        if (existing.isPresent()) {</span>
<span class="fc" id="L502">            var existingAppointment = existing.get();</span>
<span class="fc" id="L503">            appointment.setId(existingAppointment.getId());</span>
<span class="fc" id="L504">            appointment.setCommonId(existingAppointment.getCommonId()); // TODO: Common ID??</span>
<span class="fc" id="L505">            appointment.getBaseFields().setUniqueId(existingAppointment.getBaseFields().getUniqueId());</span>

<span class="fc bfc" id="L507" title="All 2 branches covered.">            for (AppointmentRequestDTO appReq : appointment.getAppointmentRequestList()) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                for (AppointmentRequestDTO existingReq : existingAppointment.getAppointmentRequestList()) {</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">                    if (appReq.getParticipantId().equals(existingReq.getParticipantId())) {</span>
<span class="fc" id="L510">                        appReq.setCommonId(existingReq.getCommonId());</span>
                    }
<span class="fc" id="L512">                }</span>
<span class="fc" id="L513">            }</span>

            // By-passes getRemoteBeanAndSynch logic in CalendarManager because it requires
            // that there isn't a current UserTransaction open - we update this appointment
            // within the current transaction.
<span class="fc" id="L518">            updateAppointment(new SourceDetails(dto), requestContext, appointment, accountId);</span>

<span class="fc" id="L520">        } else {</span>
<span class="fc" id="L521">            appointment.setId(null);</span>
<span class="fc" id="L522">            appointment.setCommonId(UUID.randomUUID().toString());</span>
<span class="fc" id="L523">            UUID uniqueId = createAppointment(new SourceDetails(dto), requestContext, appointment, accountId);</span>

            // only returns id if an AppointmentRequestDTO record is created for this appointment for the logged in user
            // a professional user looking at this account may not be participating in the appointment
            // and so an id is not returned here in that case

<span class="fc" id="L529">            Long ehrLinkId = encounterManager.linkAppointmentToEncounter(requestContext, accountId, uniqueId, encounterUniqueId);</span>

<span class="fc" id="L531">            LOGGER.debug(&quot;Associated the new appointment with this Encounter, ehrLinkId: {}&quot;, ehrLinkId);</span>
        }
<span class="fc" id="L533">    }</span>

    private UUID createAppointment(SourceDetails sourceDetails, EHRRequestContext requestContext, AppointmentDTO dto, Long accountId) {
<span class="fc" id="L536">        return appointmentService.createAppointment(sourceDetails, requestContext, dto, accountId)._2();</span>
    }

    private void cancelAppointmentForPatientScheduledAdmission(SourceDetails sourceDetails, @NotNull LoggedInEHRRequestContext requestContext, Long accountId,
                                                               Encounter encounter) {

<span class="fc" id="L542">        LOGGER.info(&quot;Need to cancel an appointment for scheduled encounter: {}&quot;, encounter.getExternalEncounterId());</span>

        // Look up Appointment linked to the encounterUniqueId
<span class="fc" id="L545">        var appointmentUuid = encounterManager.getAppointmentUuidForEncounter(requestContext, accountId, encounter.getEncounterUniqueId());</span>
<span class="fc" id="L546">        var existing = calendarManager.getAppointmentByUniqueId(requestContext, appointmentUuid.orElse(null), accountId);</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (existing.isPresent()) {</span>
<span class="fc" id="L548">            LOGGER.debug(&quot;Cancelling existing Appointment: {}&quot;, existing.get().getId());</span>
<span class="fc" id="L549">            existing.get().setStatus(AppointmentStatus.CANCELLED);</span>
<span class="fc" id="L550">            updateAppointment(sourceDetails, requestContext, existing.get(), accountId);</span>
        } else {
<span class="nc" id="L552">            LOGGER.warn(&quot;Expected an existing appointment record for this scheduled encounter but none found: {}&quot;,</span>
<span class="nc" id="L553">                    encounter.getExternalEncounterId());</span>
        }
<span class="fc" id="L555">    }</span>

    private void updateAppointment(SourceDetails sourceDetails, LoggedInEHRRequestContext requestContext, AppointmentDTO dto, Long accountId) {
        try {
<span class="pc bpc" id="L559" title="2 of 4 branches missed.">            if ((dto.getId() == null) || (dto.getId() &lt;= 0)) {</span>
                //noinspection ThrowCaughtLocally
<span class="nc" id="L561">                throw new IllegalArgumentException(&quot;cannot update appointment without id&quot;);</span>
            }
<span class="fc" id="L563">            populateAppointmentRequestListSource(sourceDetails, dto);</span>
<span class="fc" id="L564">            calendarManager.saveAppointment(requestContext, dto, accountId, false);</span>
<span class="nc" id="L565">        } catch (Exception e) {</span>
<span class="nc" id="L566">            throw new PKBException(&quot;Exception saving appointment for acct &quot; + accountId, e);</span>
<span class="fc" id="L567">        }</span>
<span class="fc" id="L568">    }</span>

    private void populateAppointmentRequestListSource(SourceDetails sourceDetails, AppointmentDTO dto) {
<span class="fc" id="L571">        appointmentService.populateAppointmentRequestListSource(sourceDetails, dto);</span>
<span class="fc" id="L572">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>