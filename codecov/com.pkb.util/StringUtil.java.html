<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.util</a> &gt; <span class="el_source">StringUtil.java</span></div><h1>StringUtil.java</h1><pre class="source lang-java linenums">package com.pkb.util;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.jetbrains.annotations.NotNull;

import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.regex.Pattern;

/**
 * Created by matev on 11/19/2015.
 */
<span class="nc" id="L15">public class StringUtil {</span>

    private static final String ALPHA_LOWER = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
    public static final String ALPHA_UPPER = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    private static final String ALPHA = ALPHA_LOWER + ALPHA_UPPER;
    public static final String NUMERIC = &quot;0123456789&quot;;
    public static final String ALPHA_NUMERIC = ALPHA + NUMERIC;
<span class="fc" id="L22">    private static final Pattern YEAR_PATTERN = Pattern.compile(&quot;\\d\\d\\d\\d&quot;);</span>
<span class="fc" id="L23">    private static final Pattern NEWLINE_PATTERN = Pattern.compile(&quot;(\r\n|\r|\n)&quot;);</span>
<span class="fc" id="L24">    private static final Pattern AMPERSAND_PATTERN = Pattern.compile(&quot;(&amp;amp;)&quot;);</span>
    public static final String LINEBREAK_TAG = &quot;&lt;br/&gt;&quot;;
<span class="fc" id="L26">    private static final Pattern HTML_BODY_TAG_PATTERN = Pattern.compile(&quot;(?i)&lt;/?(body|html)[^&gt;]*&gt;&quot;);</span>

    public static String textToHtml(String input) {
<span class="fc" id="L29">        String htmlContent = StringEscapeUtils.escapeHtml4(input);</span>
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">        if (htmlContent != null) {</span>
<span class="fc" id="L31">            htmlContent = newLineToBR(htmlContent);</span>
<span class="fc" id="L32">            htmlContent = recoverAmpersand(htmlContent);</span>
        }
<span class="fc" id="L34">        return htmlContent;</span>
    }

    public static String newLineToBR(@NotNull String htmlContent) {
<span class="fc" id="L38">        return NEWLINE_PATTERN.matcher(htmlContent.trim()).replaceAll(LINEBREAK_TAG);</span>
    }

    public static String recoverAmpersand(@NotNull String htmlContent) {
<span class="fc" id="L42">        return AMPERSAND_PATTERN.matcher(htmlContent).replaceAll(&quot;&amp;amp;amp;&quot;);</span>
    }

    public static boolean containsLineBreak(String text) {
<span class="fc" id="L46">        return NEWLINE_PATTERN.matcher(text).find();</span>
    }

    /**
     * Returns a string of the unicode character codes from the given string. eg\u0627\u0644\u0644\u064A\u0628\u0627\u0632
     *
     * This is for use in any scenario where text may be in special characters eg arabic, chinese etc and needs to be passed to javascript
     * etc.
     *
     * @param text
     * @return
     */
    public static String getUnicodeCharacters(String text) {
<span class="fc" id="L59">        CharsetEncoder asciiEncoder = Charset.forName(&quot;US-ASCII&quot;).newEncoder();</span>
<span class="fc" id="L60">        StringBuilder convertedText = new StringBuilder();</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        for (Character character : text.toCharArray()) {</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">            if (asciiEncoder.canEncode(character)) {</span>
<span class="fc" id="L63">                convertedText.append(character);</span>
            } else {
<span class="nc" id="L65">                convertedText.append(&quot;\\u&quot;);</span>
<span class="nc" id="L66">                convertedText.append(Integer.toHexString(0x10000 | character).substring(1).toUpperCase());</span>
            }
        }
<span class="fc" id="L69">        return convertedText.toString();</span>
    }

    public static String cleanWithWhitelist(String s, String whitelistChars) {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (StringUtils.isEmpty(s)) {</span>
<span class="nc" id="L74">            return s;</span>
        }

<span class="fc" id="L77">        StringBuilder valid = new StringBuilder();</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">            if (whitelistChars.indexOf(s.charAt(i)) &gt;= 0) {</span>
<span class="fc" id="L80">                valid.append(s.charAt(i));</span>
            }
        }

<span class="fc" id="L84">        return valid.toString();</span>
    }

    /**
     * For validating patient details in automated imports.
     * Case-insensitive, and ignores punctuation &amp; whitespace (this part still TODO)
     * Null considered equal to blank.
     *
     * Optional: use getLevenshteinDistance()
     */
    public static boolean equalsApproximate(String s1, String s2) {
<span class="fc" id="L95">        String clean1 = StringUtils.trimToEmpty(s1);</span>
<span class="fc" id="L96">        String clean2 = StringUtils.trimToEmpty(s2);</span>

        // remove whitespace and punctuation (but save UTF8!)
<span class="fc" id="L99">        clean1 = stripNonAlphabetChars(clean1);</span>
<span class="fc" id="L100">        clean2 = stripNonAlphabetChars(clean2);</span>

<span class="fc" id="L102">        return StringUtils.equalsIgnoreCase(clean1, clean2);</span>
    }

    /**
     * This performs identically to equalsApproximate, except that the
     * comparison will only be performed for the first X characters, where X is
     * the length of shorter string.
     *
     * If one of the strings is empty, the match will return true.
     *
     * @param s1
     * @param s2
     * @return
     */
    public static boolean equalsApproximateShort(String s1, String s2) {

<span class="nc" id="L118">        String clean1 = StringUtils.trimToEmpty(s1);</span>
<span class="nc" id="L119">        String clean2 = StringUtils.trimToEmpty(s2);</span>

<span class="nc" id="L121">        clean1 = stripNonAlphabetChars(clean1);</span>
<span class="nc" id="L122">        clean2 = stripNonAlphabetChars(clean2);</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (clean1.length() &gt; clean2.length()) {</span>
<span class="nc" id="L125">            return StringUtils.equalsIgnoreCase(clean1.substring(0, clean2.length()), clean2);</span>
        } else {
<span class="nc" id="L127">            return StringUtils.equalsIgnoreCase(clean1, clean2.substring(0, clean1.length()));</span>
        }
    }

    /**
     * Compares the first character of two strings for equality.
     *
     * Two empty strings are considered to match.
     *
     * Non-alphabetical characters are ignored.
     *
     * @param s1
     * @param s2
     * @return
     */
    public static boolean equalsApproximateInitial(String s1, String s2) {

<span class="nc" id="L144">        String clean1 = StringUtils.trimToEmpty(s1);</span>
<span class="nc" id="L145">        String clean2 = StringUtils.trimToEmpty(s2);</span>

<span class="nc" id="L147">        clean1 = stripNonAlphabetChars(clean1);</span>
<span class="nc" id="L148">        clean2 = stripNonAlphabetChars(clean2);</span>

        // If both empty, just return true
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (clean1.isEmpty() &amp;&amp; clean2.isEmpty()) {</span>
<span class="nc" id="L152">            return true;</span>
        }

        // If not both empty, then at least one had content.
        // Therefore, if either is empty, they don't match
<span class="nc bnc" id="L157" title="All 4 branches missed.">        if (clean1.isEmpty() || clean2.isEmpty()) {</span>
<span class="nc" id="L158">            return false;</span>
        }

        // Now we know they both have content, check the first chars match
<span class="nc" id="L162">        return clean1.substring(0, 1).equalsIgnoreCase(clean2.substring(0, 1));</span>
    }

    /**
     * As much as possible, strip out control chars, whitespace, and punctuation. Preserve ranges that may contain
     * &quot;alphanumeric&quot; chars (in any alphabet -- this is utf-8 and i18n safe)
     */
    public static String stripNonAlphabetChars(String s) {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (StringUtils.isBlank(s)) {</span>
<span class="nc" id="L171">            return StringUtils.trim(s);</span>
        }
<span class="fc" id="L173">        String result = stripCharsInRange(s, (char) 0, (char) ('0' - 1));</span>
<span class="fc" id="L174">        result = stripCharsInRange(result, (char) ('9' + 1), (char) ('A' - 1));</span>
<span class="fc" id="L175">        result = stripCharsInRange(result, (char) ('Z' + 1), (char) ('a' - 1));</span>
<span class="fc" id="L176">        result = stripCharsInRange(result, (char) ('z' + 1), (char) ('Š' - 1));</span>
<span class="fc" id="L177">        result = stripCharsInRange(result, (char) ('Ž' + 1), (char) ('š' - 1));</span>
<span class="fc" id="L178">        result = stripCharsInRange(result, (char) ('Ÿ' + 1), (char) ('À' - 1));</span>
<span class="fc" id="L179">        result = StringUtils.replaceChars(result, &quot;›‹÷×&quot;, &quot;&quot;);</span>
<span class="fc" id="L180">        return result;</span>
    }

    /** strip out any characters that are in the specified character range (inclusive) */
    public static String stripCharsInRange(String s, char from, char through) {
<span class="fc" id="L185">        StringBuilder keep = new StringBuilder(s.length());</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="fc" id="L187">            char c = s.charAt(i);</span>
<span class="fc bfc" id="L188" title="All 4 branches covered.">            if ((c &lt; from) || (c &gt; through)) {</span>
<span class="fc" id="L189">                keep.append(c);</span>
            }
        }

<span class="fc" id="L193">        return keep.toString();</span>
    }

    public static boolean isDecimalNumber(String value) {
<span class="fc" id="L197">        return NumberUtils.isNumber(value);</span>
    }

    public static boolean isPositiveNumber(Object value) {
        try {
<span class="nc" id="L202">            Double d = Double.parseDouble((String) value);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            return d &gt; 0;</span>
<span class="nc" id="L204">        } catch (Exception ignored) {</span>
<span class="nc" id="L205">            return false;</span>
        }
    }

    public static boolean isYYYY(String value) {
<span class="fc" id="L210">        return YEAR_PATTERN.matcher(value).matches();</span>
    }

    static String replaceNbsp(String value) {
<span class="fc" id="L214">        return StringUtils.replaceIgnoreCase(value, &quot;\\u00a0&quot;, &quot; &quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>