<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueMappingUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.util</a> &gt; <span class="el_source">ValueMappingUtil.java</span></div><h1>ValueMappingUtil.java</h1><pre class="source lang-java linenums">//------------------------------------------------------------------------------
//
// Copyright (c) 2009-2016 PatientsKnowBest, Inc. All Rights Reserved.
//
//------------------------------------------------------------------------------

package com.pkb.util;

import com.pkb.app.entity.DTOMapping;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.Nullable;

import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Extracting some of the work around mappings DTOs to EHRData from EHRBean
 */
public final class ValueMappingUtil {

    private ValueMappingUtil() {
    }

    @Nullable
    public static Object prepValueForEHRData(Object value, DTOMapping&lt;?&gt; nestedMappingIfAny) {
<span class="fc bfc" id="L33" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L34">            return null;</span>
<span class="fc bfc" id="L35" title="All 4 branches covered.">        } else if ((value instanceof List) &amp;&amp; ((List) value).isEmpty()) {</span>
<span class="fc" id="L36">            return null;</span>
<span class="pc bpc" id="L37" title="1 of 4 branches missed.">        } else if ((value instanceof List) &amp;&amp; ((List) value).get(0).getClass().isEnum()) {</span>
            // list of enums: persist as list of Strings
<span class="nc" id="L39">            List&lt;String&gt; stringList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">            for (Object eVal : (List) value) {</span>
<span class="nc" id="L41">                stringList.add(((Enum) eVal).name());</span>
<span class="nc" id="L42">            }</span>
<span class="nc" id="L43">            return stringList;</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        } else if (value.getClass().isEnum()) {</span>
            // persist as string value
<span class="fc" id="L46">            return ((Enum) value).name();</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">        } else if (nestedMappingIfAny != null) { // save encrypted values (simple, or in a List) as a Map&lt;String, Object&gt;</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">            if (value instanceof List) {</span>
                // convert DTOs one at a time
<span class="fc" id="L50">                List&lt;Map&lt;String, Object&gt;&gt; convertedList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">                for (Object dto : (List) value) {</span>
<span class="fc" id="L52">                    convertedList.add(dtoEncrFieldsToMap(dto, nestedMappingIfAny));</span>
<span class="fc" id="L53">                }</span>

<span class="fc" id="L55">                return convertedList;</span>
            } else {
<span class="fc" id="L57">                return dtoEncrFieldsToMap(value, nestedMappingIfAny);</span>
            }
        } else {
<span class="fc" id="L60">            return value;</span>
        }
    }


    private static Map&lt;String, Object&gt; dtoEncrFieldsToMap(Object dto, DTOMapping&lt;?&gt; dtoMapping) {
<span class="fc" id="L66">        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
        try {
<span class="fc bfc" id="L68" title="All 2 branches covered.">            for (String fieldName : dtoMapping.getEncryptedFieldNameSet()) {</span>
<span class="fc" id="L69">                Object fieldValue = dtoMapping.getEncryptedFieldGetter(fieldName).invoke(dto); // assumed to be basic -- String/Long/Date/enum/etc.</span>

<span class="fc" id="L71">                DTOMapping&lt;?&gt; nestedMappingIfAny = dtoMapping.getNestedDtoMapping(fieldName);</span>
<span class="fc" id="L72">                map.put(fieldName, prepValueForEHRData(fieldValue, nestedMappingIfAny));</span>
<span class="fc" id="L73">            }</span>
<span class="nc" id="L74">        } catch (Exception e) {</span>
<span class="nc" id="L75">            throw new IllegalArgumentException(&quot;bad logic? DTO-&gt;map problems &quot; + dto, e);</span>
<span class="fc" id="L76">        }</span>

<span class="fc" id="L78">        return map;</span>
    }


    /**
     * special handling for enums, lists, nested DTOs
     */
    @Nullable
    public static Object prepValueForDTO(Object value, Type destType, DTOMapping&lt;?&gt; nestedMappingIfAny, String fieldName) {
<span class="fc" id="L87">        Class simpleDestType = null;</span>
<span class="fc" id="L88">        ParameterizedType parametrizedDestType = null;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (destType instanceof ParameterizedType) {</span>
<span class="fc" id="L90">            parametrizedDestType = (ParameterizedType) destType;</span>
<span class="fc" id="L91">            simpleDestType = (Class) parametrizedDestType.getRawType();</span>
        } else {
<span class="fc" id="L93">            simpleDestType = (Class) destType;</span>
        }

<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L97">            return null;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        } else if (nestedMappingIfAny != null) {</span>
            // can be a List of nested DTOs, or just the nested DTO itself
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (simpleDestType.equals(List.class)) {</span>
<span class="fc" id="L101">                List&lt;Object&gt; nestedDtoList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">                for (Map&lt;String, Object&gt; encrFieldMap : (List&lt;Map&lt;String, Object&gt;&gt;) value) {</span>
<span class="fc" id="L103">                    nestedDtoList.add(encrFieldMapToDto(encrFieldMap, nestedMappingIfAny));</span>
<span class="fc" id="L104">                }</span>
<span class="fc" id="L105">                return nestedDtoList;</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            } else if (value instanceof Map) {</span>
<span class="fc" id="L107">                return encrFieldMapToDto((Map&lt;String, Object&gt;) value, nestedMappingIfAny);</span>
            } else {
<span class="nc" id="L109">                throw new IllegalArgumentException(&quot;Encrypted nested mapping for &quot; + fieldName + &quot;: value isn't a map! &quot; + value.getClass());</span>
            }
<span class="fc bfc" id="L111" title="All 2 branches covered.">        } else if (simpleDestType.isEnum()) {</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (simpleDestType.isInstance(value)) {</span>
<span class="fc" id="L113">                return value;</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            } else if (value instanceof String) {</span>
<span class="fc" id="L115">                return Enum.valueOf(simpleDestType, (String) value);</span>
            } else {
<span class="nc" id="L117">                throw new IllegalArgumentException(&quot;Value for &quot; + fieldName + &quot; mapped to enum &quot; + simpleDestType.getName() + &quot; is neither instanceof nor a String for valueOf: &quot; + value);</span>
            }
<span class="fc bfc" id="L119" title="All 2 branches covered.">        } else if (simpleDestType.equals(List.class)) {</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if (value instanceof String) {</span>
                // for old data -- formerly single String, now a List
<span class="nc" id="L122">                ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L123">                list.add((String) value);</span>
<span class="nc" id="L124">                return list;</span>
            } else {
                // value is a real list
                // check dest parametrized type in the DTO.  Assume List is parametrized!
<span class="fc" id="L128">                Class firstType = (Class) parametrizedDestType.getActualTypeArguments()[0];</span>
<span class="pc bpc" id="L129" title="3 of 4 branches missed.">                if (firstType.equals(String.class) || firstType.equals(Long.class)) {</span>
                    // List&lt;String | Long&gt; --- no special handling needed
<span class="fc" id="L131">                    return value;</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                } else if (firstType.isEnum()) {</span>
                    // convert from List&lt;String&gt; to List&lt;Enum&gt;
<span class="nc" id="L134">                    List&lt;Enum&gt; enumList = new ArrayList();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                    for (String stringVal : (List&lt;String&gt;) value) {</span>
<span class="nc" id="L136">                        enumList.add(Enum.valueOf(firstType, stringVal));</span>
<span class="nc" id="L137">                    }</span>
<span class="nc" id="L138">                    return enumList;</span>
                } else {
<span class="nc" id="L140">                    throw new IllegalArgumentException(&quot;For &quot; + fieldName + &quot;: no handling yet in EHRBean for List&lt;&quot; + firstType.getName() + &quot;&gt;&quot;);</span>
                }
            }
        }
        // addressing specific issues.. but is there a tidy util in Apache Commons or elsewhere to do this generally?
<span class="fc bfc" id="L145" title="All 4 branches covered.">        else if (simpleDestType.equals(Long.class) &amp;&amp; (value instanceof String)) {</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">            if (StringUtils.isBlank((String) value)) {</span>
<span class="nc" id="L147">                return null;</span>
            } else {
<span class="fc" id="L149">                return Long.valueOf(StringUtils.trim((String) value));</span>
            }
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">        } else if (simpleDestType.equals(Double.class) &amp;&amp; (value instanceof String)) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (StringUtils.isBlank((String) value)) {</span>
<span class="nc" id="L153">                return null;</span>
            } else {
<span class="nc" id="L155">                return Double.valueOf(StringUtils.trim((String) value));</span>
            }
<span class="pc bpc" id="L157" title="1 of 6 branches missed.">        } else if ((simpleDestType.equals(Boolean.class) || simpleDestType.equals(Boolean.TYPE)) &amp;&amp; (value instanceof String)) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (StringUtils.isBlank((String) value)) {</span>
<span class="nc" id="L159">                return null;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            } else if (StringUtils.trim((String) value).equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="nc" id="L161">                return Boolean.TRUE;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            } else if (StringUtils.trim((String) value).equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L163">                return Boolean.FALSE;</span>
            } else {
<span class="nc" id="L165">                throw new IllegalArgumentException(&quot;invalid boolean string: &quot; + value);</span>
            }
<span class="pc bpc" id="L167" title="1 of 4 branches missed.">        } else if (simpleDestType.equals(Instant.class) &amp;&amp; (value instanceof Date)) {</span>
<span class="fc" id="L168">            return ((Date) value).toInstant();</span>
        } else {
<span class="fc" id="L170">            return value;</span>
        }
    }

    private static Object encrFieldMapToDto(Map&lt;String, Object&gt; encrFieldMap, DTOMapping&lt;?&gt; dtoMapping) {
<span class="fc" id="L175">        String currentFieldName = null;</span>
<span class="fc" id="L176">        Object currentValue = null;</span>
        try {
<span class="fc" id="L178">            Object newDto = dtoMapping.newDTO();</span>
            // populate nested DTO (encry fields only) from Map&lt;String, Object&gt;
<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (String fieldName : dtoMapping.getEncryptedFieldNameSet()) {</span>
<span class="fc" id="L181">                currentFieldName = fieldName;</span>
<span class="fc" id="L182">                currentValue = encrFieldMap.get(currentFieldName);</span>

<span class="fc" id="L184">                Method setter = dtoMapping.getEncryptedFieldSetter(currentFieldName);</span>

<span class="fc" id="L186">                DTOMapping&lt;?&gt; nestedMappingIfAny = dtoMapping.getNestedDtoMapping(currentFieldName);</span>
<span class="fc" id="L187">                currentValue = prepValueForDTO(currentValue, setter.getGenericParameterTypes()[0], nestedMappingIfAny, currentFieldName);</span>
<span class="fc" id="L188">                setter.invoke(newDto, currentValue);</span>
<span class="fc" id="L189">            }</span>
<span class="fc" id="L190">            return newDto;</span>
<span class="nc" id="L191">        } catch (Exception e) {</span>
<span class="nc" id="L192">            throw new IllegalStateException(&quot;Failed setting field value in nested DTO. Debug: &quot; + &quot;field &quot; + currentFieldName + &quot;, value &quot; + currentValue + &quot;; dto mapping: &quot; + dtoMapping, e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>