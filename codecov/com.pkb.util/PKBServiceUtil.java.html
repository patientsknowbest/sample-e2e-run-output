<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PKBServiceUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.util</a> &gt; <span class="el_source">PKBServiceUtil.java</span></div><h1>PKBServiceUtil.java</h1><pre class="source lang-java linenums">package com.pkb.util;

import com.pkb.common.ClearableInternalState;
import com.pkb.entities.enums.NationalIdType;
import com.pkb.exception.ApiCallMalformedException;
import com.pkb.institute.entity.Org;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.MessageSource;

import java.time.format.DateTimeFormatter;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.BiConsumer;

import static com.pkb.util.XMLConfigUtil.computeTranslation;
import static com.pkb.util.XMLConfigUtil.readConfig;
import static org.apache.commons.lang3.StringUtils.EMPTY;

public class PKBServiceUtil implements ClearableInternalState {

<span class="fc" id="L31">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>
<span class="fc" id="L32">    private static final List&lt;Tuple2&lt;String, String&gt;&gt; COUNTRY_LIST = readConfig(&quot;countrylist.xml&quot;, c -&gt; Tuple.of(c.getNodeName(), String.valueOf(c.getValue())));</span>
<span class="fc" id="L33">    private static final ConcurrentMap&lt;Locale, Map&lt;String, String&gt;&gt; COUNTRIES = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L34">    private static final ConcurrentMap&lt;Locale, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; COUNTRY_MAP_ENTRIES = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L35">    private static final ConcurrentMap&lt;Locale, DateTimeFormatter&gt; MESSAGE_DATE_FORMATTERS = new ConcurrentHashMap&lt;&gt;();</span>

    private final MessageSource messageSource;

<span class="fc" id="L39">    public PKBServiceUtil(MessageSource messageSource) {</span>
<span class="fc" id="L40">        this.messageSource = messageSource;</span>
<span class="fc" id="L41">    }</span>

    /**
     * @return country map
     */
    public Map&lt;String, String&gt; getCountriesMap(Locale locale) {
<span class="fc" id="L47">        return COUNTRIES.computeIfAbsent(locale, this::computeCountryMap);</span>
    }

    public List&lt;Map.Entry&lt;String, String&gt;&gt; getCountries(Locale locale) {
<span class="fc" id="L51">        return COUNTRY_MAP_ENTRIES.computeIfAbsent(locale, this::computeCountries);</span>
    }

    private List&lt;Map.Entry&lt;String, String&gt;&gt; computeCountries(Locale locale) {
        // List has commonest values at the front, followed by all values in (local) alphabetic order
        // So read all entries into body noting duplicate keys along the way
        // then copy the duplicates in their original order into the head

<span class="fc" id="L59">        List&lt;Map.Entry&lt;String, String&gt;&gt; head = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L60">        List&lt;Map.Entry&lt;String, String&gt;&gt; body = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L62">        Set&lt;String&gt; keys = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L63">        Set&lt;String&gt; duplicateKeys = new TreeSet&lt;&gt;();</span>

<span class="fc" id="L65">        COUNTRY_LIST.forEach(t -&gt; {</span>
<span class="pc" id="L66">            String translated = getTranslation(t._2(), locale, (s2, e) -&gt; LOGGER.error(&quot;No country value for '{}'&quot;, s2, e));</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">            if (translated != null) {</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">                if (keys.contains(t._1())) {</span>
<span class="fc" id="L69">                    duplicateKeys.add(t._1());</span>
                } else {
<span class="fc" id="L71">                    body.add(new AbstractMap.SimpleEntry&lt;&gt;(t._1(), translated));</span>
<span class="fc" id="L72">                    keys.add(t._1());</span>
                }
            }
<span class="fc" id="L75">        });</span>

<span class="fc bfc" id="L77" title="All 2 branches covered.">        for (Map.Entry&lt;String, String&gt; entry : body) {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if (duplicateKeys.contains(entry.getKey())) {</span>
<span class="fc" id="L79">                head.add(entry);</span>
            }
<span class="fc" id="L81">        }</span>

<span class="fc" id="L83">        body.sort(Map.Entry.comparingByValue());</span>

<span class="fc" id="L85">        List&lt;Map.Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L86">        list.addAll(head);</span>
<span class="fc" id="L87">        list.addAll(body);</span>

<span class="fc" id="L89">        return list;</span>
    }

    private Map&lt;String, String&gt; computeCountryMap(Locale locale) {
<span class="pc" id="L93">        return computeTranslation(COUNTRY_LIST, s -&gt; getTranslation(s, locale, (s2, e) -&gt; LOGGER.error(&quot;No country value for '{}'&quot;, s2, e)), (a, b) -&gt; a);</span>
    }

    private String getTranslation(String key, Locale locale, BiConsumer&lt;String, Exception&gt; errorHandler) {
        try {
<span class="fc" id="L98">            return messageSource.getMessage(key, null, locale);</span>
<span class="nc" id="L99">        } catch (Exception e) {</span>
<span class="nc" id="L100">            errorHandler.accept(key, e);</span>
        }
<span class="nc" id="L102">        return null;</span>
    }

    /**
     * 2015-10-22 - pkbtom - Temporary safety hack until we have proper sandboxes set up.
     * 2016-07-26 - pkbtom - Extending check to non-HL7 access routes, and also blocking non-NHS numbers
     * &lt;p&gt;
     * The &quot;PKB Sandboxes&quot; org on production should not permit any National IDs except for NHS numbers that begin with 5 or 9.
     *
     * @param org   The org associated with the currently authenticated user.
     * @param type  The type of ID trying to be used.
     * @param value The value of the ID trying to be used.
     * @throws ApiCallMalformedException If this is a sandbox connection and the ID is not allowed.
     */
    public static void checkSandboxNationalID(Org org, NationalIdType type, String value)
            throws ApiCallMalformedException {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (&quot;pkbsandboxes&quot;.equals(org.getCode())) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (type == NationalIdType.NHS_NUMBER) {</span>
                // We don't have anything formal to justify these magic numbers. However, note that this link...
                // http://systems.digital.nhs.uk/nhsnumber/staff/faqs
                // ...indicates that currently issued NHS numbers begin with 4, 6 or 7. As such, anything beginning with 5 or 9 should not
                // be associated with a real patient.
<span class="nc bnc" id="L124" title="All 4 branches missed.">                if (!value.startsWith(&quot;5&quot;) &amp;&amp; !value.startsWith(&quot;9&quot;)) {</span>
<span class="nc" id="L125">                    throw new ApiCallMalformedException(&quot;Sandbox NHS numbers must start with 5 or 9&quot;);</span>
                }
            } else {
<span class="nc" id="L128">                throw new ApiCallMalformedException(&quot;Cannot send IDs of type &quot; + type.getName() + &quot; to the sandbox&quot;);</span>
            }
        }
<span class="fc" id="L131">    }</span>

    @Override
    public void clearState() {
<span class="fc" id="L135">        COUNTRIES.clear();</span>
<span class="fc" id="L136">        COUNTRY_MAP_ENTRIES.clear();</span>
<span class="fc" id="L137">        MESSAGE_DATE_FORMATTERS.clear();</span>
<span class="fc" id="L138">    }</span>

    public String getMessage(String key, Locale locale) {
<span class="fc" id="L141">        return getMessage(key, null, locale);</span>
    }

    public String getMessage(String key, Object[] args, Locale locale) {
<span class="fc" id="L145">        return messageSource.getMessage(key, args, EMPTY, locale);</span>
    }

    public DateTimeFormatter getMeasurementDateAtTimeFormatter(Locale locale) {
<span class="fc" id="L149">        return MESSAGE_DATE_FORMATTERS.computeIfAbsent(locale, l -&gt; DateTimeFormatter.ofPattern(getMessage(&quot;measurements.format.date_full_at_time&quot;, l))</span>
<span class="fc" id="L150">                .withLocale(l));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>