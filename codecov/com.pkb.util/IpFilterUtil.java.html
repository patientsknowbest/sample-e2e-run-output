<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IpFilterUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.util</a> &gt; <span class="el_source">IpFilterUtil.java</span></div><h1>IpFilterUtil.java</h1><pre class="source lang-java linenums">package com.pkb.util;

import com.google.common.base.Splitter;
import com.google.common.net.InetAddresses;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.util.Iterator;
import java.util.Set;

/**
 * TODO: look for standards or libraries to do this rather than custom code... nothing easy to
 * work with found on initial search... CIDR is way too cryptic.
 *
 * This supports IPv4 filtering given a filter string like one of these:
 * 1.2.3.4 just this exact IP address
 * 1.2.3.4,5.6.7.8 just these two exact IPs
 * 1.2.3.0-1.2.3.122 specified range (use 0-255 in octet(s) for wildcards)
 *
 * These can be combined as well; patterns are split on comma first (list) then dash (range)
 *
 * An empty-string pattern means all IPs are allowed.
 *
 * @author rob
 */
<span class="nc" id="L30">public class IpFilterUtil {</span>

    public static final int OCTET_MIN = 0;
    public static final int OCTET_MAX = 255;

<span class="fc" id="L35">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    /**
     * Check if the given ip address matches with the filter string.
     *
     * @param ipAddress
     *            ipv6 addresses are coerced to ipv4 -- we'll add ipv6 support when needed
     * @param filter
     *            empty for &quot;all&quot;, or a single IP, or a range, or ranges/IPs in a comma-separated list. See class docs.
     * @return
     */
    public static boolean isIpAllowed(String ipAddress, Set&lt;String&gt; filter) {
<span class="fc bfc" id="L47" title="All 2 branches covered.">        if (filter.isEmpty()) {</span>
<span class="fc" id="L48">            return false;  // no filter set; BLOCK by default</span>
        }
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">        if (filter.contains(&quot;*&quot;)) {</span>
<span class="fc" id="L51">            return true; // pass all</span>
        }

        // sanity check: filter string makes sense?
<span class="nc bnc" id="L55" title="All 2 branches missed.">        if (!looksLikeIpFilters(filter)) {</span>
<span class="nc" id="L56">            throw new IllegalArgumentException(&quot;invalid (IPv4) filter string: '&quot; + filter + &quot;'&quot;);</span>
        }

<span class="nc" id="L59">        InetAddress inet4or6 = InetAddresses.forString(ipAddress);</span>
<span class="nc" id="L60">        Inet4Address inet4 = null;</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (inet4or6 instanceof Inet6Address) {</span>
<span class="nc" id="L62">            inet4 = InetAddresses.getCoercedIPv4Address(inet4or6);</span>
<span class="nc" id="L63">            LOGGER.error(&quot;IpFilterUtil: got ipv6 in isIpAllowed(); coercing to {}&quot;, inet4.getHostAddress());</span>
        } else {
<span class="nc" id="L65">            inet4 = (Inet4Address) inet4or6;</span>
        }
<span class="nc" id="L67">        int ipInt = InetAddresses.coerceToInteger(inet4);</span>

        // now check against the filter

        // loop; comma-separated options
<span class="nc bnc" id="L72" title="All 2 branches missed.">        for (String option : filter) {</span>
<span class="nc" id="L73">            option = StringUtils.trim(option);</span>
            // handle ranges first, then exact matches
<span class="nc bnc" id="L75" title="All 2 branches missed.">            if (StringUtils.contains(option, '-')) {</span>
<span class="nc" id="L76">                Iterator&lt;String&gt; rangeIter = Splitter.on('-').split(option).iterator();</span>
<span class="nc" id="L77">                String fromIp = rangeIter.next();</span>
<span class="nc" id="L78">                String throughIp = rangeIter.next();</span>
<span class="nc" id="L79">                int fromInt = InetAddresses.coerceToInteger(InetAddresses.forString(fromIp));</span>
<span class="nc" id="L80">                int throughInt = InetAddresses.coerceToInteger(InetAddresses.forString(throughIp));</span>

<span class="nc bnc" id="L82" title="All 4 branches missed.">                if ((ipInt &gt;= fromInt) &amp;&amp; (ipInt &lt;= throughInt)) {</span>
<span class="nc" id="L83">                    return true;</span>
                }
<span class="nc" id="L85">            } else { // test for exact match</span>
<span class="nc" id="L86">                int compareInt = InetAddresses.coerceToInteger(InetAddresses.forString(option));</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                if (compareInt == ipInt) {</span>
<span class="nc" id="L88">                    return true;</span>
                }
            }
<span class="nc" id="L91">        }</span>
        // no match in the filter
<span class="nc" id="L93">        return false;</span>
    }

    public static boolean looksLikeIpFilters(Set&lt;String&gt; filter) {
        // only ipv4 for now in the filter string
<span class="fc" id="L98">        return filter.stream().allMatch(f -&gt; StringUtils.containsOnly(f, &quot;-0123456789.&quot;));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>