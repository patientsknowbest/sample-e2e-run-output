<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DbUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.util</a> &gt; <span class="el_source">DbUtil.java</span></div><h1>DbUtil.java</h1><pre class="source lang-java linenums">package com.pkb.util;

import com.google.common.collect.ArrayTable;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;
import io.vavr.control.Option;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.persistence.NonUniqueResultException;
import javax.persistence.TypedQuery;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.Optional.ofNullable;
import static java.util.function.Function.identity;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;

@SuppressWarnings(&quot;UtilityClass&quot;)
public final class DbUtil {

<span class="fc" id="L31">    private static final DBResultUtil DB_RESULT_UTIL = new DBResultUtil();</span>
    private static final int DEFAULT_BATCH_SIZE = 10000;

    /**
     * &lt;pre&gt;
     * This method can be used to get a single result in a more null save manner.
     * The method sets max result count to two, so caller does not have to deal with this.
     * &lt;/pre&gt;
     *
     * @return Result of query or {@link Optional#empty()}.
     * @throws NonUniqueResultException when there is more than one result.
     */
    public static &lt;T&gt; @NotNull Optional&lt;T&gt; findSingleResult(@NotNull TypedQuery&lt;T&gt; query) {
<span class="fc" id="L44">        return ofNullable(getExactlyOneUniqueResultOrNull(query));</span>
    }

    public static &lt;T&gt; @NotNull Optional&lt;T&gt; findSingleResult(Supplier&lt;List&lt;T&gt;&gt; queryResult) {
<span class="fc" id="L48">        List&lt;T&gt; results = queryResult.get();</span>
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">        if (isEmpty(results)) {</span>
<span class="nc" id="L50">            return Optional.empty();</span>
        }
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">        if (results.size() != 1) {</span>
<span class="nc" id="L53">            throw new RuntimeException(String.format(&quot;Unique search returned %s rows.&quot;, results.size()));</span>
        }

<span class="fc" id="L56">        return Optional.ofNullable(results.get(0));</span>
    }

    /**
     * &lt;pre&gt;
     * This method can be used to get a single result in a more null save manner.
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The result is {@link java.io.Serializable} which is a requirement for remote calls.
     *
     * @return Result of query or {@link Option#none()}.
     * @throws NonUniqueResultException when there is more than one result.
     */
    public static &lt;T&gt; @NotNull Option&lt;T&gt; findSingleResultForRemote(@NotNull TypedQuery&lt;T&gt; query) {
<span class="fc" id="L70">        var maybeResult = getExactlyOneUniqueResultOrNull(query);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (maybeResult == null) {</span>
<span class="fc" id="L72">            return Option.none();</span>
        }
<span class="fc" id="L74">        return Option.of(maybeResult);</span>
    }

    /**
     * &lt;pre&gt;
     * This method can be used when query is expected to return {@code null}.
     *
     * &lt;/pre&gt;
     *
     * @return Result of query or {@code null}.
     * @throws NonUniqueResultException when there is more than one result.
     */
    public static &lt;T&gt; @Nullable T getExactlyOneUniqueResultOrNull(@NotNull TypedQuery&lt;T&gt; query) {
<span class="fc" id="L87">        return DB_RESULT_UTIL.getExactlyOneUniqueResultOrNull(query);</span>
    }

    /**
     * Used when query is expected to return single result or nothing.
     * Eg. it returns null when there is no result or there would be multiple results.
     * The method sets max result count to two, so caller does not have to deal with this.
     *
     * &lt;b&gt;SHOULD ONLY BE USED IN LEGACY CODE, NOTHING NEWLY ADDED SHOULD EVER USE IT!&lt;/b&gt;
     *
     * @param query The query to run
     * @param &lt;T&gt;   Result type
     * @return Result of query or {@code null}.
     */
    public static &lt;T&gt; @Nullable T getExactlyOneResultOrNull(@NotNull TypedQuery&lt;T&gt; query) {
<span class="fc" id="L102">        return getExactlyOneResultOrNull(query, () -&gt; {</span>
<span class="nc" id="L103">        });</span>
    }

    /**
     * Used when query is expected to return single result or nothing.
     * Eg. it returns null when there is no result or there would be multiple results.
     * The method sets max result count to two, so caller does not have to deal with this.
     *
     * &lt;b&gt;SHOULD ONLY BE USED IN LEGACY CODE, NOTHING NEWLY ADDED SHOULD EVER USE IT!&lt;/b&gt;
     *
     * @param query  The query to run
     * @param logger Will be called when there are multiple elements, should log it
     * @param &lt;T&gt;    Result type
     * @return Result of query or {@code null}.
     */
    public static &lt;T&gt; @Nullable T getExactlyOneResultOrNull(@NotNull TypedQuery&lt;T&gt; query, Runnable logger) {
<span class="fc" id="L119">        return DB_RESULT_UTIL.getExactlyOneResultOrNull(query, logger);</span>
    }

    public static &lt;T&gt; int executeInBatches(Collection&lt;T&gt; ids, Function&lt;Collection&lt;T&gt;, Integer&gt; query) {
<span class="fc" id="L123">        return executeInBatches(ids, DEFAULT_BATCH_SIZE, query);</span>
    }

    public static &lt;T&gt; int executeInBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, Integer&gt; query) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (isEmpty(ids)) {</span>
<span class="nc" id="L128">            return 0;</span>
        }
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (batchSize &lt; ids.size()) {</span>
<span class="nc" id="L131">            return executeBatchImpl(ids, batchSize, query);</span>
        } else {
<span class="fc" id="L133">            return query.apply(ids);</span>
        }
    }

    public static &lt;K1, K2, R&gt; Table&lt;K1, K2, R&gt; getInBatches(Set&lt;K1&gt; keys1, Set&lt;K2&gt; keys2, BiFunction&lt;Collection&lt;K1&gt;, Collection&lt;K2&gt;, List&lt;R&gt;&gt; query, Function&lt;R, K1&gt; key1, Function&lt;R, K2&gt; key2) {
<span class="nc" id="L138">        return getInBatches(keys1, keys2, query, key1, key2, identity(), identity());</span>
    }

    public static &lt;K1, K2, IR1, IR2, R&gt; Table&lt;K1, K2, R&gt; getInBatches(Set&lt;K1&gt; keys1, Set&lt;K2&gt; keys2, BiFunction&lt;Collection&lt;K1&gt;, Collection&lt;K2&gt;, List&lt;IR1&gt;&gt; query, Function&lt;IR2, K1&gt; key1, Function&lt;IR2, K2&gt; key2, Function&lt;IR1, IR2&gt; preSortMapper, Function&lt;IR2, R&gt; resultMapper) {
<span class="nc bnc" id="L142" title="All 4 branches missed.">        if (isEmpty(keys1) || isEmpty(keys2)) {</span>
<span class="nc" id="L143">            return ImmutableTable.of();</span>
        }
<span class="nc" id="L145">        Table&lt;K1, K2, R&gt; result = ArrayTable.create(keys1, keys2);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (keys1.size() &lt; keys2.size()) {</span>
<span class="nc" id="L147">            DbUtil.getInStreamOfBatches(keys2, keys2Batch -&gt; query.apply(keys1, keys2Batch))</span>
<span class="nc" id="L148">                    .forEach(ir -&gt; {</span>
<span class="nc" id="L149">                        IR2 r = preSortMapper.apply(ir);</span>
<span class="nc" id="L150">                        result.put(key1.apply(r), key2.apply(r), resultMapper.apply(r));</span>
<span class="nc" id="L151">                    });</span>
        } else {
<span class="nc" id="L153">            DbUtil.getInStreamOfBatches(keys1, keys1Batch -&gt; query.apply(keys1Batch, keys2))</span>
<span class="nc" id="L154">                    .forEach(ir -&gt; {</span>
<span class="nc" id="L155">                        IR2 r = preSortMapper.apply(ir);</span>
<span class="nc" id="L156">                        result.put(key1.apply(r), key2.apply(r), resultMapper.apply(r));</span>
<span class="nc" id="L157">                    });</span>
        }
<span class="nc" id="L159">        return result;</span>
    }

    public static &lt;T, R&gt; List&lt;R&gt; getInBatches(Collection&lt;T&gt; ids, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query) {
<span class="fc" id="L163">        return getInBatches(ids, DEFAULT_BATCH_SIZE, query);</span>
    }

    public static &lt;T, R, I, A&gt; R getInBatches(Collection&lt;T&gt; ids, Function&lt;Collection&lt;T&gt;, List&lt;I&gt;&gt; query, Collector&lt;? super I, A, R&gt; collector) {
<span class="nc" id="L167">        return getInBatches(ids, DEFAULT_BATCH_SIZE, query, collector);</span>
    }

    public static &lt;T, R&gt; List&lt;R&gt; getInBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query) {
<span class="fc" id="L171">        return getInBatches(ids, batchSize, query, Collectors.toList());</span>
    }

    public static &lt;T, I, A, R&gt; R getInBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;I&gt;&gt; query, Collector&lt;? super I, A, R&gt; collector) {
<span class="fc" id="L175">        return getInStreamOfBatches(ids, batchSize, query).collect(collector);</span>
    }

    public static &lt;T, R&gt; List&lt;R&gt; getInBatches(Collection&lt;T&gt; ids, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query, Comparator&lt;? super R&gt; comparator) {
<span class="nc" id="L179">        return getInBatches(ids, DEFAULT_BATCH_SIZE, query, comparator);</span>
    }

    public static &lt;T, R&gt; List&lt;R&gt; getInBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query, Comparator&lt;? super R&gt; comparator) {
<span class="fc" id="L183">        return getInBatches(ids, batchSize, query, comparator, identity(), Collectors.toList());</span>
    }

    public static &lt;T, I, R&gt; List&lt;R&gt; getInBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;I&gt;&gt; query, Comparator&lt;? super I&gt; comparator, Function&lt;I, R&gt; mapper) {
<span class="fc" id="L187">        return getInBatches(ids, batchSize, query, comparator, mapper, Collectors.toList());</span>
    }

    public static &lt;T, I, O, A, R&gt; R getInBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;I&gt;&gt; query, Comparator&lt;? super I&gt; comparator, Function&lt;I, O&gt; mapper, Collector&lt;? super O, A, R&gt; collector) {
<span class="fc" id="L191">        return getInStreamOfBatches(ids, batchSize, query, comparator, mapper).collect(collector);</span>
    }

    public static &lt;K1, K2, R&gt; Stream&lt;R&gt; getInStreamOfBatches(Set&lt;K1&gt; keys1, Set&lt;K2&gt; keys2, BiFunction&lt;Collection&lt;K1&gt;, Collection&lt;K2&gt;, List&lt;R&gt;&gt; query) {
<span class="nc bnc" id="L195" title="All 4 branches missed.">        if (isEmpty(keys1) || isEmpty(keys2)) {</span>
<span class="nc" id="L196">            return Stream.empty();</span>
        }

<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (keys1.size() &lt; keys2.size()) {</span>
<span class="nc" id="L200">            return DbUtil.getInStreamOfBatches(keys2, keys2Batch -&gt; query.apply(keys1, keys2Batch));</span>
        } else {
<span class="nc" id="L202">            return DbUtil.getInStreamOfBatches(keys1, keys1Batch -&gt; query.apply(keys1Batch, keys2));</span>
        }
    }

    public static &lt;T, I, R&gt; Stream&lt;R&gt; getInStreamOfBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;I&gt;&gt; query, Comparator&lt;? super I&gt; comparator, Function&lt;I, R&gt; mapper) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (isEmpty(ids)) {</span>
<span class="fc" id="L208">            return Stream.empty();</span>
        }
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (batchSize &lt; ids.size()) {</span>
<span class="fc" id="L211">            return getBatchImpl(ids, batchSize, query).sorted(comparator).map(mapper);</span>
        } else {
<span class="fc" id="L213">            return query.apply(ids).stream().sorted(comparator).map(mapper);</span>
        }
    }

    public static &lt;T, R&gt; Stream&lt;R&gt; getInStreamOfBatches(Collection&lt;T&gt; ids, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query) {
<span class="fc" id="L218">        return getInStreamOfBatches(ids, DEFAULT_BATCH_SIZE, query);</span>
    }

    public static &lt;T, R&gt; Stream&lt;R&gt; getInStreamOfBatches(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (isEmpty(ids)) {</span>
<span class="fc" id="L223">            return Stream.empty();</span>
        }
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (batchSize &lt; ids.size()) {</span>
<span class="fc" id="L226">            return getBatchImpl(ids, batchSize, query);</span>
        } else {
<span class="fc" id="L228">            return query.apply(ids).stream();</span>
        }
    }

    private static &lt;T, R&gt; Stream&lt;R&gt; getBatchImpl(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, List&lt;R&gt;&gt; query) {
<span class="fc" id="L233">        return io.vavr.collection.LinkedHashSet.ofAll(ids)</span>
<span class="fc" id="L234">                .grouped(batchSize)</span>
<span class="fc" id="L235">                .map(batch -&gt; query.apply(batch.toJavaList()))</span>
<span class="fc" id="L236">                .toJavaStream()</span>
<span class="fc" id="L237">                .flatMap(List::stream);</span>
    }

    private static &lt;T&gt; int executeBatchImpl(Collection&lt;T&gt; ids, int batchSize, Function&lt;Collection&lt;T&gt;, Integer&gt; query) {
<span class="nc" id="L241">        return io.vavr.collection.LinkedHashSet.ofAll(ids)</span>
<span class="nc" id="L242">                .grouped(batchSize)</span>
<span class="nc" id="L243">                .map(batch -&gt; query.apply(batch.toJavaList()))</span>
<span class="nc" id="L244">                .sum()</span>
<span class="nc" id="L245">                .intValue();</span>
    }

    private DbUtil() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>