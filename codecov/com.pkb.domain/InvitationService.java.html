<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InvitationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.domain</a> &gt; <span class="el_source">InvitationService.java</span></div><h1>InvitationService.java</h1><pre class="source lang-java linenums">package com.pkb.domain;

import com.pkb.datamodel.Email;
import com.pkb.entities.doc.DocInvitation;
import com.pkb.entities.enums.InvitationStatus;
import com.pkb.entities.enums.InvitationType;
import com.pkb.repository.InvitationRepository;
import com.pkb.util.DbUtil;
import io.vavr.control.Option;
import org.jetbrains.annotations.NotNull;

import javax.persistence.Tuple;
import javax.transaction.Transactional;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.lang.String.format;

public class InvitationService {

    private final InvitationRepository invitationRepository;

<span class="fc" id="L30">    public InvitationService(InvitationRepository invitationRepository) {</span>
<span class="fc" id="L31">        this.invitationRepository = invitationRepository;</span>
<span class="fc" id="L32">    }</span>

    public DocInvitation getInvitation(UUID invitationPublicId) {
<span class="fc" id="L35">        return invitationRepository.findById(invitationPublicId).orElseThrow(() -&gt;</span>
<span class="nc" id="L36">                new IllegalArgumentException(format(&quot;invalid invitation id %s&quot;, invitationPublicId.toString())));</span>
    }

    /**
     * @deprecated  For a transitional period we might have an old-style invitation in which the acceptance url contains
     *     a long doc.invitation.id OR a new-style invitation which contains a uuid doc.invitation.public_id
     *     While the old-style is still around we read invitationId as a string and use this routine to convert it to
     *      the public_id if necessary. This saves us from having to handle both types of id further down.
     * @param invitationId - a string which can be doc.invitation.id or doc.invitation.publicId
     * @return doc.invitation.publicId
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    @Deprecated
    public UUID getInvitationIdByString(String invitationId) {
        try {
<span class="fc" id="L51">            return UUID.fromString(invitationId);</span>
<span class="fc" id="L52">        } catch (IllegalArgumentException ignored) {</span>
<span class="fc" id="L53">            Long privateId = Long.parseLong(invitationId);</span>
<span class="fc" id="L54">            return invitationRepository.findByPrivateId(privateId).orElseThrow(() -&gt;</span>
<span class="pc" id="L55">                    new IllegalArgumentException(format(&quot;invalid invitation id %s&quot;, privateId))).getPublicId();</span>
        }
    }

    public List&lt;DocInvitation&gt; getInvitations(@NotNull Collection&lt;UUID&gt; invitationIds){
<span class="fc" id="L60">        return DbUtil.getInBatches(invitationIds, invitationRepository::findByIds);</span>
    }

    public Stream&lt;Tuple&gt; getIdAndAuthorPersonIdTuplesForIds(@NotNull Collection&lt;UUID&gt; invitationIds){
<span class="fc" id="L64">        return DbUtil.getInStreamOfBatches(invitationIds, invitationRepository::getIdAndAuthorPersonIdTuplesForIds);</span>
    }

    public Set&lt;UUID&gt; getInvitationIdsForTargetPersonIds(@NotNull Collection&lt;Long&gt; targetPersonIds, @NotNull InvitationStatus status) {
<span class="nc" id="L68">        return DbUtil.getInBatches(targetPersonIds,</span>
<span class="nc" id="L69">                batchOfIds -&gt; invitationRepository.getInvitationIdsForTargetPersonIds(batchOfIds, status),Collectors.toCollection(HashSet::new));</span>
    }

    public List&lt;UUID&gt; getInvitationIdsForTargetEmails(@NotNull Collection&lt;String&gt; targetEmails, @NotNull InvitationStatus status){
<span class="fc" id="L73">        return DbUtil.getInBatches(targetEmails,</span>
<span class="fc" id="L74">                batchOfEmails -&gt; invitationRepository.getInvitationIdsForTargetEmails(batchOfEmails, status));</span>
    }

    public List&lt;DocInvitation&gt; getActiveInvitationsForAuthorIdsAndTargetEmail(@NotNull List&lt;Long&gt; authorIds, @NotNull Email targetEmail) {
<span class="fc" id="L78">        return DbUtil.getInBatches(authorIds,</span>
<span class="fc" id="L79">                batchOfIds -&gt; invitationRepository.getActiveInvitationsForAuthorIdsAndTargetEmail(batchOfIds,</span>
<span class="fc" id="L80">                        InvitationStatus.NEW, targetEmail.address()));</span>
    }

    public List&lt;DocInvitation&gt; getOpenInvitationsForTargetEmail(Option&lt;Email&gt; targetEmail, long accountId) {
<span class="fc" id="L84">        return targetEmail.map(email -&gt; invitationRepository.getOpenInvitationsForTargetEmailAndAccountId(InvitationStatus.NEW, accountId, email.address()))</span>
<span class="fc" id="L85">                .getOrElse(Collections.emptyList());</span>
    }

    public List&lt;DocInvitation&gt; getInvitationsByAuthorOrTargetUserId(long userId) {
<span class="fc" id="L89">        return invitationRepository.getInvitationsByUserId(userId, InvitationStatus.EXPIRED);</span>
    }

    public List&lt;DocInvitation&gt; getInvitationsByUserAndAccountId(long authorUserId, long accountId,
                                                                long targetUserId, @NotNull InvitationStatus status) {
<span class="fc" id="L94">        return invitationRepository.getInvitationsByUserAndAccountId(authorUserId, accountId, targetUserId, status);</span>
    }

    public Optional&lt;DocInvitation&gt; getPKBInvitation(long authorUserId, long targetUserId, @NotNull InvitationType invitationType) {
<span class="fc" id="L98">        return invitationRepository.getPKBInvitation(authorUserId, targetUserId, invitationType.description);</span>
    }

    public Stream&lt;DocInvitation&gt; getInvitationsByTargetUserIds(Set&lt;Long&gt; targetUserIds, InvitationStatus status) {
<span class="fc" id="L102">        return DbUtil.getInStreamOfBatches(targetUserIds,</span>
<span class="fc" id="L103">                batchOfIds -&gt; invitationRepository.getInvitationsByTargetUserIds(batchOfIds, status));</span>
    }

    public List&lt;DocInvitation&gt; getInvitationsFromInstitute(long teamId, long userId, @NotNull InvitationStatus status) {
<span class="nc" id="L107">        return invitationRepository.getInvitationsFromInstitute(teamId, userId, status);</span>
    }

    @Transactional
    public DocInvitation save(@NotNull DocInvitation docInvitation) {
<span class="fc" id="L112">        return invitationRepository.save(docInvitation);</span>
    }

    @Transactional
    public void updateInvitationStatus(UUID invitationId, @NotNull InvitationStatus status) {
<span class="fc" id="L117">        invitationRepository.updateInvitationStatus(invitationId, status);</span>
<span class="fc" id="L118">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>