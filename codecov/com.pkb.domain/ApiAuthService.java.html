<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ApiAuthService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.domain</a> &gt; <span class="el_source">ApiAuthService.java</span></div><h1>ApiAuthService.java</h1><pre class="source lang-java linenums">package com.pkb.domain;

import com.pkb.common.datetime.DateTimeService;
import com.pkb.datamodel.ApiAuthSession;
import com.pkb.datamodel.ApiClient;
import com.pkb.datamodel.WebAppOtp;
import com.pkb.datamodel.entity.mapper.ApiAuthSessionMapper;
import com.pkb.datamodel.entity.mapper.ApiClientMapper;
import com.pkb.datamodel.entity.mapper.WebAppOtpMapper;
import com.pkb.datamodel.entity.mapper.context.AvoidCyclicReferenceContext;
import com.pkb.entities.enums.api.WebAppOtpStatus;
import com.pkb.entities.pub.PublicApiAuthRefreshHistory;
import com.pkb.repository.ApiAuthRefreshHistoryRepository;
import com.pkb.repository.ApiAuthSessionRepository;
import com.pkb.repository.ApiClientRepository;
import com.pkb.repository.WebAppOtpRepository;
import org.jetbrains.annotations.NotNull;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.pkb.entities.enums.api.ApiAuthSessionStatus.CREATED;
import static com.pkb.entities.enums.api.ApiAuthSessionStatus.INVALID;

@Transactional(readOnly = true) // Specify @Transactional on specific method(s) to override readOnly
public class ApiAuthService {

    private final ApiAuthRefreshHistoryRepository apiAuthRefreshHistoryRepository;
    private final ApiAuthSessionRepository apiAuthSessionRepository;
    private final ApiAuthSessionMapper apiAuthSessionMapper;
    private final ApiClientRepository apiClientRepository;
    private final ApiClientMapper apiClientMapper;
    private final WebAppOtpRepository webAppOtpRepository;
    private final WebAppOtpMapper webAppOtpMapper;
    private final DateTimeService dateTimeService;

    public ApiAuthService(ApiAuthRefreshHistoryRepository apiAuthRefreshHistoryRepository,
                          ApiAuthSessionRepository apiAuthSessionRepository,
                          ApiAuthSessionMapper apiAuthSessionMapper,
                          ApiClientRepository apiClientRepository,
                          ApiClientMapper apiClientMapper,
                          WebAppOtpRepository webAppOtpRepository,
                          WebAppOtpMapper webAppOtpMapper,
<span class="fc" id="L47">                          DateTimeService dateTimeService) {</span>
<span class="fc" id="L48">        this.apiAuthRefreshHistoryRepository = apiAuthRefreshHistoryRepository;</span>
<span class="fc" id="L49">        this.apiAuthSessionRepository = apiAuthSessionRepository;</span>
<span class="fc" id="L50">        this.apiAuthSessionMapper = apiAuthSessionMapper;</span>
<span class="fc" id="L51">        this.apiClientRepository = apiClientRepository;</span>
<span class="fc" id="L52">        this.apiClientMapper = apiClientMapper;</span>
<span class="fc" id="L53">        this.webAppOtpRepository = webAppOtpRepository;</span>
<span class="fc" id="L54">        this.webAppOtpMapper = webAppOtpMapper;</span>
<span class="fc" id="L55">        this.dateTimeService = dateTimeService;</span>
<span class="fc" id="L56">    }</span>

    public Optional&lt;ApiClient&gt; findApiClientByApiId(String apiId) {
<span class="fc" id="L59">        var clients = apiClientRepository.getPublicApiClientsByApiId(apiId);</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (clients.isEmpty()) {</span>
<span class="fc" id="L61">            return Optional.empty();</span>
        }
<span class="fc" id="L63">        var client = clients.get(0);</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (!client.isEnabled()) {</span>
            // If the client has been disabled behave as if we didn't find it at all.
<span class="nc" id="L66">            return Optional.empty();</span>
        }
<span class="fc" id="L68">        return Optional.of(apiClientMapper.entityToDatamodel(client, new AvoidCyclicReferenceContext()));</span>
    }

    @Transactional
    public void saveAuthSession(ApiAuthSession session) {
<span class="fc" id="L73">        apiAuthSessionRepository.save(apiAuthSessionMapper.datamodelToEntity(session, new AvoidCyclicReferenceContext()));</span>
<span class="fc" id="L74">    }</span>

    public Optional&lt;ApiAuthSession&gt; findAuthSession(String sessionId) {
<span class="fc" id="L77">        var sessions = apiAuthSessionRepository.getPublicApiAuthSessionsBySessionId(sessionId);</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (sessions.isEmpty()) {</span>
<span class="nc" id="L79">            return Optional.empty();</span>
        }
<span class="fc" id="L81">        return Optional.of(apiAuthSessionMapper.entityToDatamodel(sessions.get(0), new AvoidCyclicReferenceContext()));</span>
    }

    public Optional&lt;List&lt;ApiAuthSession&gt;&gt; findAuthSessionsByAuthCode(String part) {
<span class="fc" id="L85">        var sessions = apiAuthSessionRepository.getPublicApiAuthSessionsByAuthCodePart(part);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (sessions.isEmpty()) {</span>
<span class="fc" id="L87">            return Optional.empty();</span>
        }
<span class="fc" id="L89">        return Optional.of(sessions</span>
<span class="fc" id="L90">                .stream()</span>
<span class="fc" id="L91">                .map(session -&gt; apiAuthSessionMapper.entityToDatamodel(session, new AvoidCyclicReferenceContext()))</span>
<span class="fc" id="L92">                .collect(Collectors.toList()));</span>
    }

    public Optional&lt;List&lt;ApiAuthSession&gt;&gt; findAuthSessionsByAccessToken(String part) {
<span class="fc" id="L96">        var sessions = apiAuthSessionRepository.getPublicApiAuthSessionsByAccessTokenPart(part);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (sessions.isEmpty()) {</span>
<span class="fc" id="L98">            return Optional.empty();</span>
        }
<span class="fc" id="L100">        return Optional.of(sessions</span>
<span class="fc" id="L101">                .stream()</span>
<span class="fc" id="L102">                .map(session -&gt; apiAuthSessionMapper.entityToDatamodel(session, new AvoidCyclicReferenceContext()))</span>
<span class="fc" id="L103">                .collect(Collectors.toList()));</span>
    }

    public Optional&lt;List&lt;ApiAuthSession&gt;&gt; findAuthSessionsByRefreshToken(@NotNull String part) {
<span class="fc" id="L107">        return Optional.of(apiAuthSessionRepository.getPublicApiAuthSessionsByRefreshTokenPart(part)</span>
<span class="fc" id="L108">                .stream()</span>
<span class="fc" id="L109">                .map(session -&gt; apiAuthSessionMapper.entityToDatamodel(session, new AvoidCyclicReferenceContext()))</span>
<span class="fc" id="L110">                .collect(Collectors.toList()));</span>
    }

    public Optional&lt;List&lt;ApiAuthSession&gt;&gt; findAuthSessionsInRefreshHistoryByRefreshToken(@NotNull String part) {
<span class="fc" id="L114">        return Optional.of(apiAuthRefreshHistoryRepository.getPublicApiAuthSessionsUsingRefreshTokenPart(part)</span>
<span class="fc" id="L115">                .stream()</span>
<span class="fc" id="L116">                .map(session -&gt; apiAuthSessionMapper.entityToDatamodel(session, new AvoidCyclicReferenceContext()))</span>
<span class="fc" id="L117">                .collect(Collectors.toList()));</span>
    }

    @Transactional
    public void createRefreshTokenInHistory(ApiAuthSession session, String refreshTokenPart, Instant serverNow) {
<span class="fc" id="L122">        var publicSession = apiAuthSessionMapper.datamodelToEntity(session, new AvoidCyclicReferenceContext());</span>
<span class="fc" id="L123">        var history = new PublicApiAuthRefreshHistory();</span>
<span class="fc" id="L124">        history.setIssued(publicSession.getAuthCodeIssued());</span>
<span class="fc" id="L125">        history.setUsed(serverNow);</span>
<span class="fc" id="L126">        history.setSession(publicSession);</span>
<span class="fc" id="L127">        history.setRefreshTokenPart(refreshTokenPart);</span>
<span class="fc" id="L128">        publicSession.getRefreshHistorySet().add(history);</span>
<span class="fc" id="L129">        apiAuthSessionRepository.save(publicSession);</span>
<span class="fc" id="L130">    }</span>

    /**
     * When a person changes their password, we have to expire any authenticated sessions for that user to be sure they
     * don't try to use those sessions. A session basically stores the user's password, encrypted. Doesn't affect
     * sessions that are status CREATED (these aren't yet authenticated and don't contain the password)
     *
     * @param personId the person whose sessions should be expired (normally because of a changed password)
     */
    @Transactional
    public void expireSessionsForUser(long personId) {
<span class="fc" id="L141">        apiAuthSessionRepository.updatePublicApiAuthSessionsExpireForUser(INVALID, personId, CREATED);</span>
<span class="fc" id="L142">    }</span>

    @Transactional
    public void invalidateAuthSession(ApiAuthSession session) {
<span class="fc" id="L146">        var sessionToUpdate = apiAuthSessionMapper.datamodelToEntity(session, new AvoidCyclicReferenceContext());</span>
<span class="fc" id="L147">        sessionToUpdate.setStatus(INVALID);</span>
<span class="fc" id="L148">        apiAuthSessionRepository.save(sessionToUpdate);</span>
<span class="fc" id="L149">    }</span>

    @Transactional
    public void createWebAppOtp(WebAppOtp otp) {
<span class="fc" id="L153">        webAppOtpRepository.save(webAppOtpMapper.datamodelToEntity(otp));</span>
<span class="fc" id="L154">    }</span>

    public Optional&lt;List&lt;WebAppOtp&gt;&gt; findWebAppOtpByLookupPart(String part) {
<span class="fc" id="L157">        return Optional.of(webAppOtpRepository.findPublicWebAppOtpsByLookupPart(part)</span>
<span class="fc" id="L158">                .stream()</span>
<span class="fc" id="L159">                .map(webAppOtpMapper::entityToDatamodel)</span>
<span class="fc" id="L160">                .collect(Collectors.toList()));</span>
    }

    @Transactional
    public void deactivateWebAppOtpForUser(String personId) {
        // Deactivate the currently active OTP, if present.
        // Should we delete the encrypted password, to limit the ciphertext available to an attacker? Probably.
<span class="fc" id="L167">        webAppOtpRepository.updatePublicWebAppOtpDeactivateForUser(personId);</span>
<span class="fc" id="L168">    }</span>

    @Transactional
    public void deactivateWebAppOtpForLookupPart(String part) {
<span class="nc" id="L172">        webAppOtpRepository.updatePublicWebAppOtpDeactivateForLookupPart(part);</span>
<span class="nc" id="L173">    }</span>

    @Transactional
    public void expireWebAppOtpForUser(long personId) {
<span class="fc" id="L177">        webAppOtpRepository.updatePublicWebAppOtpExpireForUser(dateTimeService.now(), Long.toString(personId));</span>
<span class="fc" id="L178">    }</span>

    @Transactional
    public void updateWebAppOtpStatusForLookupPart(WebAppOtpStatus status, String part) {
<span class="fc" id="L182">        webAppOtpRepository.updatePublicWebAppOtpStatusForLookupPart(status, dateTimeService.now(), part);</span>
<span class="fc" id="L183">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>