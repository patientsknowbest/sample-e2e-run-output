<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HL7XmlDoc.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.dataupload.hl7</a> &gt; <span class="el_source">HL7XmlDoc.java</span></div><h1>HL7XmlDoc.java</h1><pre class="source lang-java linenums">package com.pkb.service.dataupload.hl7;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.pkb.allergy.entity.Allergy;
import com.pkb.app.dto.ParticipantDTO;
import com.pkb.app.dto.ParticipantDTO.ParticipantDTOBuilder;
import com.pkb.app.dto.ParticipantDTO.ParticipantRole;
import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.SourceDetails;
import com.pkb.app.interfaces.EqualityKeySupport;
import com.pkb.calendar.entity.AppointmentDTO;
import com.pkb.calendar.entity.AppointmentRequestDTO;
import com.pkb.coding.entity.CodeableConcept;
import com.pkb.coding.entity.Coding;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.datamodel.ReferenceDatum;
import com.pkb.diagnosis.entity.Diagnosis;
import com.pkb.document.entity.Attachment;
import com.pkb.domain.ReferenceDatumService;
import com.pkb.encounter.entity.EncounterEvent;
import com.pkb.encounter.entity.GeographicLocation;
import com.pkb.encounter.entity.Message;
import com.pkb.encounter.entity.Message.MessageType;
import com.pkb.entities.enums.EncounterClass;
import com.pkb.exception.ApiCallMalformedException;
import com.pkb.exception.PKBPluginException;
import com.pkb.medication.entity.CDAMedicationFrequency;
import com.pkb.medication.entity.HL7UnitOfTime;
import com.pkb.medication.entity.Medication;
import com.pkb.medication.entity.Medication.MedicationStatus;
import com.pkb.medication.entity.PKBMedicationFrequency;
import com.pkb.phplan.entity.PHPlan;
import com.pkb.phplan.entity.PHPlan.ApprovalStatus;
import com.pkb.phplan.entity.PHPlan.EditableStatus;
import com.pkb.phplan.entity.PHPlan.PlanStatus;
import com.pkb.phplan.entity.PHPlanTemplate.TemplateFieldLabel;
import com.pkb.phplan.entity.PlanField;
import com.pkb.radiology.entity.RadiologyResult;
import com.pkb.radiology.entity.RadiologyResult.MediaActCategory;
import com.pkb.service.dataupload.hl7.field.HL7Code;
import com.pkb.service.dataupload.hl7.field.HL7HierarchicDesignator;
import com.pkb.service.dataupload.hl7.field.HL7Id;
import com.pkb.service.dataupload.hl7.field.HL7PersonRef;
import com.pkb.service.dataupload.hl7.segment.HL7Allergy;
import com.pkb.service.dataupload.hl7.segment.HL7Appointment;
import com.pkb.service.dataupload.hl7.segment.HL7CustomAppointment;
import com.pkb.service.dataupload.hl7.segment.HL7DatapointExternalIntegrationUrl;
import com.pkb.service.dataupload.hl7.segment.HL7Diagnosis;
import com.pkb.service.dataupload.hl7.segment.HL7EventType;
import com.pkb.service.dataupload.hl7.segment.HL7Medication;
import com.pkb.service.dataupload.hl7.segment.HL7MessageHeader;
import com.pkb.service.dataupload.hl7.segment.HL7Observation;
import com.pkb.service.dataupload.hl7.segment.HL7OrderGroup;
import com.pkb.service.dataupload.hl7.segment.HL7Patient;
import com.pkb.service.dataupload.hl7.segment.HL7PatientVisit1;
import com.pkb.service.dataupload.hl7.segment.HL7PatientVisit2;
import com.pkb.service.dataupload.hl7.segment.HL7ResourceGroup;
import com.pkb.service.dataupload.hl7.segment.parser.HL7ObservationParser;
import com.pkb.service.dataupload.hl7.validation.HL7ValueExpectation;
import com.pkb.service.dataupload.hl7.value.HL7Date;
import com.pkb.service.dataupload.hl7.value.HL7String;
import com.pkb.service.dataupload.hl7.value.HL7Value;
import com.pkb.service.reference.ReferenceDataManager;
import com.pkb.service.test.LoincManager;
import com.pkb.test.UploadedDataDeletionMetadata;
import com.pkb.test.entity.LoincMapping;
import com.pkb.test.entity.LoincTest;
import com.pkb.test.entity.MeasurementDTO;
import com.pkb.test.entity.MeasurementType;
import com.pkb.test.entity.MeasurementTypeId;
import com.pkb.test.entity.PredefinedMeasurementType;
import com.pkb.test.entity.TestResultDTO;
import com.pkb.user.entity.PKBPerson;
import com.pkb.util.XmlSanitiser;
import com.pkb.util.security.FileSecurityHandler;
import io.vavr.collection.Stream;
import io.vavr.control.Either;
import io.vavr.control.Option;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.IOException;
import java.io.Serializable;
import java.io.StringReader;
import java.lang.invoke.MethodHandles;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.text.ParsePosition;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.pkb.app.dto.ParticipantDTO.ParticipantRole.ATTENDER;
import static com.pkb.app.dto.ParticipantDTO.ParticipantRole.CONSULTANT;
import static com.pkb.app.dto.ParticipantDTO.ParticipantRole.REFERRER;
import static com.pkb.dataupload.entity.UploadedData.Destination;
import static com.pkb.entities.enums.ReferenceDataType.UNIT;
import static com.pkb.service.dataupload.hl7.validation.HL7ValueChecker.enforceMandatoryValue;
import static com.pkb.service.dataupload.hl7.validation.HL7ValueChecker.enforceMandatoryValueAtLeastOne;
import static com.pkb.service.dataupload.hl7.validation.HL7ValueChecker.enforcePermittedValue;
import static io.vavr.API.None;
import static io.vavr.API.Some;
import static io.vavr.API.unchecked;
import static java.lang.String.format;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

/**
 * Wrapper for an HL7 message in XML format; parses and provides access methods.
 * &lt;p&gt;
 * Future design note: create subclasses based on message type?
 * To-do when we have more than a couple of message types.
 *
 * @author robwhelan
 */
public class HL7XmlDoc implements Serializable {

    private static final long serialVersionUID = 1L;

<span class="fc" id="L162">    private static final DocumentBuilderFactory DOCUMENT_BUILDER_FACTORY = DocumentBuilderFactory.newInstance();</span>

<span class="fc" id="L164">    protected static final Map&lt;String, PredefinedMeasurementType&gt; snomedToMeasMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L165">    protected static final Map&lt;String, PredefinedMeasurementType&gt; snomedToMultiValMeasMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L166">    private static final ZoneId DEFAULT_ZONE_ID = ZoneId.of(&quot;Europe/London&quot;);</span>
    private static final String DOC_COMPLETION_STATUS_AU = &quot;AU&quot;;

    /**
     * http://dev.patientsknowbest.com/home/hl7-api/code-sets
     */
<span class="fc" id="L172">    private static final Map&lt;String, EncounterClass&gt; pkbCS04ValueToEncounterClassMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L174">    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

<span class="fc" id="L176">    public static final ImmutableSet&lt;String&gt; RADIOLOGY_SYSTEMS = ImmutableSet.of(&quot;CRISOCS&quot;, &quot;CRIS&quot;, &quot;RADIOLOGY&quot;, &quot;GERIS-ALF&quot;);</span>
<span class="fc" id="L177">    public static final ImmutableSet&lt;String&gt; ALLOWED_MDM_DOCUMENT_TYPES = ImmutableSet.of(&quot;DS&quot;, &quot;CL&quot;, &quot;RL&quot;, &quot;AL&quot;, &quot;TCI&quot;, &quot;MDT&quot;, &quot;AN&quot;, &quot;DL&quot;, &quot;BR&quot;, &quot;HS&quot;, &quot;TT&quot;, &quot;SP&quot;, &quot;ST&quot;);</span>

    /**
     * If modifying this whitelist remember to update AddMeasurementsTest.testAllSupportedDefaultSnomedMeasurements
     * and/or AddMeasurementsTest.testAllSupportedTaibaSnomedMeasurements.
     */
    static {

<span class="fc" id="L185">        snomedToMeasMap.put(&quot;366161004&quot;, PredefinedMeasurementType.CENTRAL_VENOUS_PRESSURE); // Taiba</span>
<span class="fc" id="L186">        snomedToMeasMap.put(&quot;366162006&quot;, PredefinedMeasurementType.CENTRAL_VENOUS_PRESSURE); // PKB default</span>

        // unit: kg or lbs or stone
<span class="fc" id="L189">        snomedToMeasMap.put(&quot;27113001&quot;, PredefinedMeasurementType.WEIGHT); // Taiba</span>
<span class="fc" id="L190">        snomedToMeasMap.put(&quot;107647005&quot;, PredefinedMeasurementType.WEIGHT); // PKB default</span>

        // unit: inches or cm
<span class="fc" id="L193">        snomedToMeasMap.put(&quot;50373000&quot;, PredefinedMeasurementType.HEIGHT); // Taiba</span>
<span class="fc" id="L194">        snomedToMeasMap.put(&quot;162755006&quot;, PredefinedMeasurementType.HEIGHT); // PKB default</span>

        // unit: inches or cm
<span class="fc" id="L197">        snomedToMeasMap.put(&quot;33673004&quot;, PredefinedMeasurementType.WAIST_SIZE); // Taiba</span>
<span class="fc" id="L198">        snomedToMeasMap.put(&quot;276361009&quot;, PredefinedMeasurementType.WAIST_SIZE); // PKB default</span>

<span class="fc" id="L200">        snomedToMeasMap.put(&quot;363812007&quot;, PredefinedMeasurementType.HEAD_CIRCUMFERENCE); // Taiba</span>
<span class="fc" id="L201">        snomedToMeasMap.put(&quot;301338002&quot;, PredefinedMeasurementType.HEAD_CIRCUMFERENCE); // PKB default</span>

<span class="fc" id="L203">        snomedToMeasMap.put(&quot;301898006&quot;, PredefinedMeasurementType.BODY_SURFACE_AREA); // PKB default</span>

<span class="fc" id="L205">        snomedToMeasMap.put(&quot;60621009&quot;, PredefinedMeasurementType.BMI); // Taiba</span>
<span class="fc" id="L206">        snomedToMeasMap.put(&quot;301331008&quot;, PredefinedMeasurementType.BMI); // PKB default</span>

<span class="fc" id="L208">        snomedToMeasMap.put(&quot;170804003&quot;, PredefinedMeasurementType.IDEAL_BODY_WEIGHT); // PKB default</span>

<span class="fc" id="L210">        snomedToMeasMap.put(&quot;8499008&quot;, PredefinedMeasurementType.PULSE); // Taiba</span>
<span class="fc" id="L211">        snomedToMeasMap.put(&quot;162986007&quot;, PredefinedMeasurementType.PULSE); // PKB default</span>

<span class="fc" id="L213">        snomedToMeasMap.put(&quot;86290005&quot;, PredefinedMeasurementType.RESPIRATION); // Taiba</span>
<span class="fc" id="L214">        snomedToMeasMap.put(&quot;162913005&quot;, PredefinedMeasurementType.RESPIRATION); // PKB default</span>

<span class="fc" id="L216">        snomedToMeasMap.put(&quot;386725007&quot;, PredefinedMeasurementType.TEMPERATURE); // Taiba</span>
<span class="fc" id="L217">        snomedToMeasMap.put(&quot;105723007&quot;, PredefinedMeasurementType.TEMPERATURE); // PKB default</span>

<span class="fc" id="L219">        snomedToMeasMap.put(&quot;1036631000000109&quot;, PredefinedMeasurementType.MSK_HQ); // PKB default</span>

<span class="fc" id="L221">        snomedToMeasMap.put(&quot;431314004&quot;, PredefinedMeasurementType.SPO2); // PKB default</span>

<span class="fc" id="L223">        snomedToMeasMap.put(&quot;257733005&quot;, PredefinedMeasurementType.ACTIVITY); // PKB default</span>
<span class="fc" id="L224">        snomedToMeasMap.put(&quot;415882003&quot;, PredefinedMeasurementType.AXILLARY); // PKB default</span>

<span class="fc" id="L226">        snomedToMeasMap.put(&quot;15527001&quot;, PredefinedMeasurementType.CAPILLARY); // PKB default</span>
<span class="fc" id="L227">        snomedToMeasMap.put(&quot;251843005&quot;, PredefinedMeasurementType.DRAIN); // PKB default</span>

<span class="fc" id="L229">        snomedToMeasMap.put(&quot;18491006&quot;, PredefinedMeasurementType.PEF); // Taiba</span>
<span class="fc" id="L230">        snomedToMeasMap.put(&quot;366156001&quot;, PredefinedMeasurementType.PEF); // PKB default</span>

<span class="fc" id="L232">        snomedToMeasMap.put(&quot;313222007&quot;, PredefinedMeasurementType.FEV1_FVC); // PKB default</span>
<span class="fc" id="L233">        snomedToMeasMap.put(&quot;59328004&quot;, PredefinedMeasurementType.FEV1); // PKB default</span>
<span class="fc" id="L234">        snomedToMeasMap.put(&quot;366151006&quot;, PredefinedMeasurementType.FVC); // PKB default</span>

<span class="fc" id="L236">        snomedToMeasMap.put(&quot;873921000000106&quot;, PredefinedMeasurementType.FEV6); // PKB default</span>

<span class="fc" id="L238">        snomedToMeasMap.put(&quot;251932003&quot;, PredefinedMeasurementType.FEF_25_75); // PKB default</span>

<span class="fc" id="L240">        snomedToMeasMap.put(&quot;273648008&quot;, PredefinedMeasurementType.NINE_HOLE_PEG_TEST); // PKB default</span>

<span class="fc" id="L242">        snomedToMeasMap.put(&quot;414059009&quot;, PredefinedMeasurementType.NUMBER_OF_MISSED_MEDICATIONS_TODAY); // PKB default</span>

<span class="fc" id="L244">        snomedToMeasMap.put(&quot;786441000000107&quot;, PredefinedMeasurementType.GRIP_STRENGTH_LEFT_HAND);</span>
<span class="fc" id="L245">        snomedToMeasMap.put(&quot;786451000000105&quot;, PredefinedMeasurementType.GRIP_STRENGTH_RIGHT_HAND);</span>

<span class="fc" id="L247">        snomedToMeasMap.put(&quot;78564009&quot;, PredefinedMeasurementType.HEART_RATE_MEASURED_AT_SYSTEMIC_ARTERY);</span>
<span class="fc" id="L248">        snomedToMeasMap.put(&quot;1091811000000102&quot;, PredefinedMeasurementType.DIASTOLIC_ARTERIAL_PRESSURE);</span>
<span class="fc" id="L249">        snomedToMeasMap.put(&quot;72313002&quot;, PredefinedMeasurementType.SYSTOLIC_ARTERIAL_PRESSURE);</span>
<span class="fc" id="L250">        snomedToMeasMap.put(&quot;810931000000108&quot;, PredefinedMeasurementType.QRISK2_CALCULATED_HEART_AGE);</span>
<span class="fc" id="L251">        snomedToMeasMap.put(&quot;718087004&quot;, PredefinedMeasurementType.QRISK2_CARDIOVASCULARDISEASE_10YR_RISK_SCORE);</span>
<span class="fc" id="L252">        snomedToMeasMap.put(&quot;1082641000000106&quot;, PredefinedMeasurementType.ALCOHOL_UNITS_CONSUMED_PER_WEEK);</span>
<span class="fc" id="L253">        snomedToMeasMap.put(&quot;230085005&quot;, PredefinedMeasurementType.BEER_INTAKE);</span>
<span class="fc" id="L254">        snomedToMeasMap.put(&quot;230086006&quot;, PredefinedMeasurementType.WINE_INTAKE);</span>
<span class="fc" id="L255">        snomedToMeasMap.put(&quot;230088007&quot;, PredefinedMeasurementType.SPIRITS_INTAKE);</span>
<span class="fc" id="L256">        snomedToMeasMap.put(&quot;442547005&quot;, PredefinedMeasurementType.ALCOHOL_UNITS_HEAVIEST_DAY);</span>
<span class="fc" id="L257">        snomedToMeasMap.put(&quot;230056004&quot;, PredefinedMeasurementType.CIGARETTE_CONSUMPTION);</span>
<span class="fc" id="L258">        snomedToMeasMap.put(&quot;230057008&quot;, PredefinedMeasurementType.CIGAR_CONSUMPTION);</span>
<span class="fc" id="L259">        snomedToMeasMap.put(&quot;230058003&quot;, PredefinedMeasurementType.PIPE_TOBACCO_CONSUMPTION);</span>
<span class="fc" id="L260">        snomedToMeasMap.put(&quot;413173009&quot;, PredefinedMeasurementType.MINUTES_FROM_WAKING_TO_FIRST_TOBACCO_CONSUMPTION);</span>
<span class="fc" id="L261">        snomedToMeasMap.put(&quot;836001000000109&quot;, PredefinedMeasurementType.WATERPIPE_TOBACCO_CONSUMPTION);</span>
<span class="fc" id="L262">        snomedToMeasMap.put(&quot;401070008&quot;, PredefinedMeasurementType.NUMBER_PORTIONS_FRUIT_VEG_DAILY);</span>

        // BP
        // How to handle acceptable units?
        //    	BP recommendation: use 3 OBXs for each reading; first the general SNOMED code that includes the patient position (with no value):
        //		BP (observable entity): 75367002
        //		Sitting BP (observable entity): 163035008
        //		Standing BP (observable entity): 163034007
        //		Lying/supine BP (observable entity): 163033001

        //		Then OBXes for systolic and diastolic values:
        //		Systolic BP reading (finding): 163030003
        //		Diastolic BP reading (finding): 163031004
        //		unit1/unit2: &quot;mmHg (systolic)&quot;, &quot;mmHg (diastolic)&quot;

        //    	special handling below for multi-value measurements -- values 1 &amp; 2 for any of these above BP readings.
        //    	these SNOMED codes are in the PredefinedMeasurementType enum class already.

        //		Systolic BP reading (finding): 163030003
        //		Diastolic BP reading (finding): 163031004
        //		unit1/unit2: &quot;mmHg (systolic)&quot;, &quot;mmHg (diastolic)&quot;

<span class="fc" id="L284">        snomedToMultiValMeasMap.put(&quot;75367002&quot;, PredefinedMeasurementType.BLOOD_PRESSURE); // PKB default</span>
<span class="fc" id="L285">        snomedToMultiValMeasMap.put(&quot;163035008&quot;, PredefinedMeasurementType.BLOOD_PRESSURE_SITTING); // PKB default</span>
<span class="fc" id="L286">        snomedToMultiValMeasMap.put(&quot;163034007&quot;, PredefinedMeasurementType.BLOOD_PRESSURE_STANDING); // PKB default</span>
<span class="fc" id="L287">        snomedToMultiValMeasMap.put(&quot;163033001&quot;, PredefinedMeasurementType.BLOOD_PRESSURE_SUPINE); // PKB default</span>

        // Mapping PKBCS04 Encounter Class Identifiers to the actual EncounterClass enumerated type
        // http://dev.patientsknowbest.com/home/hl7-api/code-sets
<span class="fc" id="L291">        pkbCS04ValueToEncounterClassMap.put(&quot;I&quot;, EncounterClass.IN_PATIENT);</span>
<span class="fc" id="L292">        pkbCS04ValueToEncounterClassMap.put(&quot;O&quot;, EncounterClass.OUT_PATIENT);</span>
<span class="fc" id="L293">        pkbCS04ValueToEncounterClassMap.put(&quot;A&quot;, EncounterClass.AMBULATORY);</span>
<span class="fc" id="L294">        pkbCS04ValueToEncounterClassMap.put(&quot;E&quot;, EncounterClass.EMERGENCY);</span>
<span class="fc" id="L295">        pkbCS04ValueToEncounterClassMap.put(&quot;H&quot;, EncounterClass.HOME);</span>
<span class="fc" id="L296">        pkbCS04ValueToEncounterClassMap.put(&quot;F&quot;, EncounterClass.FIELD);</span>
<span class="fc" id="L297">        pkbCS04ValueToEncounterClassMap.put(&quot;D&quot;, EncounterClass.DAYTIME);</span>
<span class="fc" id="L298">        pkbCS04ValueToEncounterClassMap.put(&quot;V&quot;, EncounterClass.VIRTUAL);</span>
    }

<span class="fc" id="L301">    private static final DateTimeFormatter HL7_TIMESTAMP_SECONDS_FORMAT_WITH_TZ = DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmssZ&quot;);</span>
<span class="fc" id="L302">    private static final DateTimeFormatter HL7_TIMESTAMP_MILLI_FORMAT_WITH_TZ = new DateTimeFormatterBuilder().parseCaseInsensitive()</span>
<span class="fc" id="L303">            .appendPattern(&quot;yyyyMMddHHmmss.SSSZ&quot;).toFormatter();</span>
<span class="fc" id="L304">    private static final DateTimeFormatter HL7_TIMESTAMP_MILLI_FORMAT_WITHOUT_TZ = new DateTimeFormatterBuilder().parseCaseInsensitive()</span>
<span class="fc" id="L305">            .appendPattern(&quot;yyyyMMddHHmmss.SSS&quot;).toFormatter().withZone(DEFAULT_ZONE_ID);</span>

    private String xml;
<span class="fc" id="L308">    private Optional&lt;Either&lt;ApiCallMalformedException, List&lt;HL7OrderGroup&gt;&gt;&gt; orderGroups = Optional.empty();</span>
    private Document dom;
    protected Element root;
    protected HL7MessageProperties messageProperties;
<span class="fc" id="L312">    private Map&lt;Object, List&lt;?&gt;&gt; parsedSegmentCache = new HashMap&lt;&gt;();</span>
    private PhrConfig config;
    private DateTimeService dateTimeService;
    private final FileSecurityHandler fileSecurityHandler;
<span class="fc" id="L316">    private Supplier&lt;ObjectMapper&gt; loggingObjectMapper = () -&gt; {</span>
<span class="fc" id="L317">        ObjectMapper mapper = getLoggingObjectMapper();</span>
<span class="pc" id="L318">        loggingObjectMapper = () -&gt; mapper;</span>
<span class="fc" id="L319">        return mapper;</span>
    };

<span class="fc" id="L322">    enum ObrValidationMode {</span>
<span class="fc" id="L323">        ALLOW_MULTIPLE,</span>
<span class="fc" id="L324">        REJECT_MULTIPLE</span>
    }

    /**
     * This enum only exists so that it can be added to method signatures to make it clear to callers the method should only be used for testing.
     */
<span class="nc" id="L330">    enum UsingThisFor {</span>
<span class="nc" id="L331">        TESTING_ONLY</span>
    }

    HL7XmlDoc(UsingThisFor testingFlag, List&lt;HL7OrderGroup&gt; orderGroups, @NotNull PhrConfig config, @NotNull FileSecurityHandler fileSecurityHandler, @NotNull DateTimeService dateTimeService) {
<span class="nc" id="L335">        this(&quot;&lt;unused&gt;&lt;MSH.7&gt;&lt;MSH.7.1&gt;20210727111213.000+0000&lt;/MSH.7.1&gt;&lt;/MSH.7&gt;&lt;MSH.9&gt;&lt;MSH.9.1&gt;MDM&lt;/MSH.9.1&gt;&lt;MSH.9.2&gt;T02&lt;/MSH.9.2&gt;&lt;/MSH.9&gt;&lt;/unused&gt;&quot;, config, fileSecurityHandler, dateTimeService);</span>
<span class="nc" id="L336">        this.orderGroups = Optional.of(Either.right(orderGroups));</span>
<span class="nc" id="L337">    }</span>

<span class="fc" id="L339">    public HL7XmlDoc(String xml, @NotNull PhrConfig config, @NotNull FileSecurityHandler fileSecurityHandler, @NotNull DateTimeService dateTimeService) {</span>
<span class="fc" id="L340">        this.config = config;</span>
<span class="fc" id="L341">        this.xml = xml;</span>
<span class="fc" id="L342">        this.fileSecurityHandler = fileSecurityHandler;</span>
<span class="fc" id="L343">        this.dateTimeService = dateTimeService;</span>

        try {
<span class="fc" id="L346">            DocumentBuilder db = DOCUMENT_BUILDER_FACTORY.newDocumentBuilder();</span>
<span class="fc" id="L347">            InputSource source = new InputSource(new StringReader(this.xml));</span>
<span class="fc" id="L348">            dom = db.parse(source);</span>
<span class="fc" id="L349">            root = dom.getDocumentElement();</span>

<span class="fc" id="L351">            initMessageProperties();</span>
<span class="nc" id="L352">        } catch (Exception e) {</span>
<span class="nc" id="L353">            LOGGER.error(&quot;failed parsing XML; root error&quot;, e);</span>
<span class="nc" id="L354">            throw new ApiCallMalformedException(&quot;Error in HL7 message structure&quot;, e);</span>
<span class="fc" id="L355">        }</span>
<span class="fc" id="L356">    }</span>

    public Element getRoot() {
<span class="fc" id="L359">        return root;</span>
    }

    public HL7MessageProperties getMessageProperties() {
<span class="fc" id="L363">        return messageProperties;</span>
    }

    public String getOriginalXml() {
<span class="fc" id="L367">        return this.xml;</span>
    }

    // ========================= MSH SEGMENT

    /**
     * Initialises properties for this specific message.
     */
    private void initMessageProperties() {
<span class="fc" id="L376">        messageProperties = new HL7MessageProperties();</span>

<span class="fc" id="L378">        String msh7TimestampOffset = parseTimestampOffset(HL7XmlDoc.getHl7Text(root, &quot;MSH.7.1&quot;).getString());</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (StringUtils.isNotBlank(msh7TimestampOffset)) {</span>
<span class="fc" id="L380">            LOGGER.info(&quot;MSH.7.1 contained timezone [{}]&quot;, msh7TimestampOffset);</span>
<span class="fc" id="L381">            messageProperties.setDefaultTimestampOffset(msh7TimestampOffset);</span>
        }
<span class="fc" id="L383">    }</span>

    public HL7MessageHeader parseHL7MessageHeader() {
<span class="fc" id="L386">        HL7MessageHeader msh = null;</span>

<span class="fc" id="L388">        NodeList nodeList = root.getElementsByTagName(&quot;MSH&quot;);</span>

<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        if ((nodeList != null) &amp;&amp; (nodeList.getLength() &gt; 0)) {</span>
<span class="fc" id="L391">            Element element = (Element) nodeList.item(0);</span>
<span class="fc" id="L392">            msh = new HL7MessageHeader(messageProperties, element);</span>
        }

<span class="fc" id="L395">        return msh;</span>
    }

    /**
     * Single MSH Segment
     */
    public HL7MessageHeader getHL7MessageHeader() {
<span class="fc" id="L402">        parsedSegmentCache.putIfAbsent(HL7MessageHeader.class, Arrays.asList(parseHL7MessageHeader()));</span>
<span class="fc" id="L403">        return (HL7MessageHeader) parsedSegmentCache.get(HL7MessageHeader.class).get(0);</span>
    }

    public HL7MessageHeader getMSH() {
<span class="fc" id="L407">        return getHL7MessageHeader();</span>
    }

    public String getMessageIdString() {
<span class="fc" id="L411">        HL7MessageHeader msh = getMSH();</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (msh != null) {</span>
<span class="fc" id="L413">            HL7String hl7MessageId = msh.getMessageControlId();</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if (hl7MessageId != null) {</span>
<span class="fc" id="L415">                return hl7MessageId.getString();</span>
            }
        }
<span class="nc" id="L418">        return &quot;&quot;;</span>
    }

    public @NotNull HL7MessageType getMessageType() {
<span class="fc" id="L422">        String messageCode = getHl7Text(root, &quot;MSH.9.1&quot;).getString();</span>
<span class="fc" id="L423">        String messageTrigger = getHl7Text(root, &quot;MSH.9.2&quot;).getString();</span>
<span class="fc" id="L424">        String messageTypeKey = messageCode + &quot;^&quot; + messageTrigger;</span>
<span class="fc" id="L425">        return Optional.ofNullable(HL7MessageType.get(messageTypeKey)).orElseThrow(</span>
<span class="fc" id="L426">                () -&gt; new ApiCallMalformedException(String.format(&quot;Unsupported message type: %s %s&quot;, messageCode, messageTrigger)));</span>
    }

    public HL7Date getMessageDate() throws ApiCallMalformedException {
<span class="fc" id="L430">        return parseDateOrTimestamp(getHl7Text(root, &quot;MSH.7.1&quot;), &quot;MSH.7.1&quot;, messageProperties);</span>
    }

    public HL7HierarchicDesignator getSendingApp() {
<span class="fc" id="L434">        HL7HierarchicDesignator hl7Hd = new HL7HierarchicDesignator();</span>
<span class="fc" id="L435">        hl7Hd.parseHd(root, &quot;MSH&quot;, 3);</span>
<span class="fc" id="L436">        return hl7Hd;</span>
    }

    /**
     * we hide our own details in this field -- authenticating username and IP
     * format: optional_facility_id:username@ip_address
     */
    private SendingFacilityWithAuth getSendingFacilityWithAuth() {
<span class="fc" id="L444">        String sendingFacility = getHl7Text(root, &quot;MSH.4.1&quot;).getString();</span>

        // PIE doesn't put the auth details in where we expect them... let's find them where they are
<span class="fc" id="L447">        List&lt;String&gt; foundAuthDetailsInFields = Lists.newArrayList(getHl7Text(root, &quot;MSH.4.1&quot;),</span>
<span class="fc" id="L448">                        getHl7Text(root, &quot;MSH.4.2&quot;),</span>
<span class="fc" id="L449">                        getHl7Text(root, &quot;MSH.4.3&quot;))</span>
<span class="fc" id="L450">                .stream()</span>
<span class="fc" id="L451">                .filter(HL7String::isNotBlank)</span>
<span class="fc" id="L452">                .map(HL7String::getString)</span>
<span class="pc bpc" id="L453" title="2 of 4 branches missed.">                .filter(s -&gt; s.indexOf(':') &gt; -1 &amp;&amp; s.indexOf('@') &gt; 1)</span>
<span class="fc" id="L454">                .collect(toList());</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (foundAuthDetailsInFields.size() &lt; 1) {</span>
<span class="nc" id="L456">            throw new RuntimeException(&quot;Web Services input failure: didn't include principal and ip: &quot; + sendingFacility);</span>
        }

<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (foundAuthDetailsInFields.size() &gt; 1) {</span>
<span class="nc" id="L460">            throw new RuntimeException(&quot;Web Service input failure: found auth details in more than one field &quot; + foundAuthDetailsInFields);</span>
        }

        // If there's a 4.4, that breaks the spec
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (getHl7Text(root, &quot;MSH.4.4&quot;).isProvided()) {</span>
<span class="nc" id="L465">            throw new ApiCallMalformedException(&quot;MSH-4.4 value not supported&quot;);</span>
        }

<span class="fc" id="L468">        String authDetailsIncluded = foundAuthDetailsInFields.get(0);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        if (authDetailsIncluded.equals(sendingFacility)) {</span>
<span class="fc" id="L470">            sendingFacility = StringUtils.substringBefore(sendingFacility, &quot;:&quot;);</span>
        }

        // ensure the separators for username &amp; ip
<span class="fc" id="L474">        int lastColon = authDetailsIncluded.lastIndexOf(':');</span>
<span class="fc" id="L475">        int lastAtSign = authDetailsIncluded.lastIndexOf('@');</span>
<span class="fc" id="L476">        return new SendingFacilityWithAuth(</span>
                sendingFacility,
<span class="fc" id="L478">                authDetailsIncluded.substring(lastColon + 1, lastAtSign),</span>
<span class="fc" id="L479">                authDetailsIncluded.substring(lastAtSign + 1));</span>
    }

    /**
     * Example: &quot;devon:principal@23.23.23.23&quot;
     * - &quot;devon&quot; is their own entry; this may be useful for
     * - &quot;principal&quot; is the username they used to authenticate. May be either:
     * - an org id, in format oid_1234 (phasing this out)
     * - a team id, in format tid_1234 (phasing this out)
     * - an org code, in format org_thecode
     * - a team code, in format team_thecode
     * - a team code (phasing this out)
     * - &quot;23.23.23.23&quot; is the IP address of the remote server... we can verify this as well
     */
    public String parseAuthPrincipal() {
<span class="fc" id="L494">        return getSendingFacilityWithAuth().authPrincipal;</span>
    }

    public String parseSenderIp() {
<span class="fc" id="L498">        return getSendingFacilityWithAuth().ip;</span>
    }

    public String getSendingFacility() {
<span class="fc" id="L502">        return getSendingFacilityWithAuth().sendingFacility;</span>
    }

    // ========================= PID SEGMENT

    public List&lt;HL7Id&gt; getIDs(HL7ConnContext hl7ConnContext) throws ApiCallMalformedException {
<span class="fc" id="L508">        List&lt;HL7Id&gt; ids = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L510">        NodeList pid2List = root.getElementsByTagName(&quot;PID.2&quot;);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (pid2List != null) {</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            if (pid2List.getLength() &gt; 0) {</span>
<span class="fc" id="L513">                Element pid2Element = (Element) pid2List.item(0);</span>
<span class="fc" id="L514">                HL7Id id = new HL7Id();</span>
<span class="fc" id="L515">                id.parseCx(pid2Element, &quot;PID&quot;, 2);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                if (id.isValid()) {</span>
<span class="fc" id="L517">                    ids.add(id);</span>
                } else {
                    // Log a warning only if a value was provided, but do not log the value itself
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">                    if (id.getValue().isProvided()) {</span>
<span class="nc" id="L521">                        LOGGER.warn(&quot;Ignoring invalid PID-2 ID for {} [{}] [{}]&quot;,</span>
<span class="nc" id="L522">                                hl7ConnContext.toString(), id.getAssigningAuthority().getRawValue(), id.getIdTypeCode().getRawValue());</span>
                    }
                }
            }
        }

<span class="fc" id="L528">        NodeList pid3List = root.getElementsByTagName(&quot;PID.3&quot;);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if (pid3List != null) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">            for (int i = 0; i &lt; pid3List.getLength(); i++) {</span>
<span class="fc" id="L531">                Element pid3Element = (Element) pid3List.item(i);</span>
<span class="fc" id="L532">                HL7Id id = new HL7Id();</span>
<span class="fc" id="L533">                id.parseCx(pid3Element, &quot;PID&quot;, 3);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">                if (id.isValid()) {</span>
<span class="fc" id="L535">                    ids.add(id);</span>
                } else {
                    // Log a warning only if a value was provided, but do not log the value itself
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">                    if (id.getValue().isProvided()) {</span>
<span class="nc" id="L539">                        LOGGER.warn(&quot;Ignoring invalid PID-3 ID for {} [{}] [{}]&quot;,</span>
<span class="nc" id="L540">                                hl7ConnContext.toString(), id.getAssigningAuthority().getRawValue(), id.getIdTypeCode().getRawValue());</span>
                    }
                }
            }
        }

<span class="fc" id="L546">        return ids;</span>
    }

    public String getPidIdFields(HL7ConnContext hl7ConnContext) throws ApiCallMalformedException {
<span class="nc" id="L550">        List&lt;HL7Id&gt; ids = getIDs(hl7ConnContext);</span>
<span class="nc" id="L551">        String idString = &quot;&quot;;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (HL7Id id : ids) {</span>
<span class="nc" id="L553">            idString += &quot;[&quot; + id.getValue().getString() + &quot;, &quot; + id.getAssigningAuthority().getString() + &quot;, &quot;</span>
<span class="nc" id="L554">                    + id.getIdTypeCode().getString() + &quot;] &quot;;</span>
<span class="nc" id="L555">        }</span>
<span class="nc" id="L556">        return idString;</span>
    }

    /**
     * Returns true if, and only if, this HL7 XML doc contains at least 1 PID
     * segment.
     *
     * @return
     */
    public boolean containsPID() {
<span class="fc" id="L566">        NodeList pidNodes = root.getElementsByTagName(&quot;PID&quot;);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        return pidNodes.getLength() &gt;= 1;</span>
    }

    /**
     * Parses information from a PID segment into an {@code HL7Patient}.
     *
     * @param hl7ConnContext Details of who is connecting
     * @return
     * @throws ApiCallMalformedException If there was not exactly 1 PID segment provided
     */
    public HL7Patient parsePatient(HL7ConnContext hl7ConnContext) throws ApiCallMalformedException {
        // split out the SINGLE pid segment
        // double-check: there's only one:
<span class="fc" id="L580">        NodeList pidNodes = expectSingleSegment(&quot;PID&quot;);</span>

<span class="fc" id="L582">        Element pidElement = (Element) pidNodes.item(0);</span>

<span class="fc" id="L584">        HL7Patient patient = new HL7Patient(messageProperties);</span>
<span class="fc" id="L585">        patient.parsePid(pidElement, hl7ConnContext, getIDs(hl7ConnContext), dateTimeService, getMessageIdString());</span>

<span class="fc" id="L587">        return patient;</span>
    }

    //======================== ADT^A28 OR ADT^A31 MESSAGE HANDLING

    public List&lt;HL7Allergy&gt; parseHL7Allergies() {
        // list of 0-* AL1 nodes
<span class="fc" id="L594">        NodeList nodeList = root.getElementsByTagName(&quot;AL1&quot;);</span>

<span class="fc" id="L596">        List&lt;HL7Allergy&gt; dtoList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        if (nodeList != null) {</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">            for (int i = 0; i &lt; nodeList.getLength(); ++i) {</span>
<span class="fc" id="L599">                Element al1 = (Element) nodeList.item(i);</span>
<span class="fc" id="L600">                Element nte = null;</span>
<span class="fc" id="L601">                Element nextElement = (Element) al1.getNextSibling();</span>
<span class="fc bfc" id="L602" title="All 4 branches covered.">                if ((nextElement != null) &amp;&amp; nextElement.getTagName().equals(&quot;NTE&quot;)) {</span>
<span class="fc" id="L603">                    nte = nextElement;</span>
                }

<span class="fc" id="L606">                HL7Allergy dto = new HL7Allergy(messageProperties);</span>
<span class="fc" id="L607">                dto.parseAl1(al1);</span>
<span class="fc" id="L608">                dto.parseNte(nte);</span>

<span class="fc" id="L610">                HL7ValueExpectation expectation_1 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L611">                        .withId(&quot;AL1-3.1&quot;)</span>
<span class="fc" id="L612">                        .withName(&quot;Allergen code ID&quot;)</span>
<span class="fc" id="L613">                        .withProvidedHL7Value(dto.getAllergenCode().getId())</span>
<span class="fc" id="L614">                        .build();</span>
<span class="fc" id="L615">                HL7ValueExpectation expectation_2 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L616">                        .withId(&quot;AL1-3.2&quot;)</span>
<span class="fc" id="L617">                        .withName(&quot;Allergen code text&quot;)</span>
<span class="fc" id="L618">                        .withProvidedHL7Value(dto.getAllergenCode().getText())</span>
<span class="fc" id="L619">                        .build();</span>
<span class="fc" id="L620">                List&lt;HL7ValueExpectation&gt; expectations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L621">                expectations.add(expectation_1);</span>
<span class="fc" id="L622">                expectations.add(expectation_2);</span>
<span class="fc" id="L623">                enforceMandatoryValueAtLeastOne(expectations, false/*absentAllowed*/);</span>

<span class="fc" id="L625">                dtoList.add(dto);</span>
            }
        }
<span class="fc" id="L628">        checkDatapointListForDuplicates(dtoList, &quot;allergies&quot;);</span>
<span class="fc" id="L629">        return dtoList;</span>
    }

    private &lt;T extends EqualityKeySupport&gt; void checkDatapointListForDuplicates(List&lt;T&gt; dataPointList, String dataPointType) {
<span class="fc bfc" id="L633" title="All 2 branches covered.">        if (dataPointList.stream().collect(Collectors.groupingBy(T::equalityKey)).size() != dataPointList.size()) {</span>
<span class="fc" id="L634">            LOGGER.error(&quot;PHR-7245: Duplicate entries for datatype {} : {} &quot;, dataPointType, obfuscateDataPoints(dataPointList));</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">            if (config.isHl7DuplicateDatapointRejectionEnabled()) {</span>
<span class="fc" id="L636">                throw new ApiCallMalformedException(&quot;Duplicate entries for &quot; + dataPointType);</span>
            }
        }
<span class="fc" id="L639">    }</span>

    private &lt;T&gt; String obfuscateDataPoints(List&lt;T&gt; dataPointList) {
<span class="fc" id="L642">        ObjectMapper mapper = loggingObjectMapper.get();</span>
        try {
<span class="fc" id="L644">            return dataPointList.stream().map(unchecked(mapper::writeValueAsString)).collect(joining());</span>
<span class="nc" id="L645">        } catch (Exception e) {</span>
<span class="nc" id="L646">            LOGGER.error(&quot;Error attempting to serialize duplicated datapoints&quot;, e);</span>
<span class="nc" id="L647">            return &quot;{ERROR}&quot;;</span>
        }
    }

    private static ObjectMapper getLoggingObjectMapper() {
<span class="fc" id="L652">        ObjectMapper mapper = new ObjectMapper();</span>
<span class="fc" id="L653">        SimpleModule module = new SimpleModule(&quot;HL7ObfuscationModule&quot;, new Version(1, 0, 0, null, null, null));</span>
<span class="fc" id="L654">        module.addSerializer(HL7Value.class, new Hl7ValueSerializer());</span>
<span class="fc" id="L655">        return mapper.registerModule(module)</span>
<span class="fc" id="L656">                .addMixIn(HL7Medication.class, InstructionsObfuscateMixin.class)</span>
<span class="fc" id="L657">                .addMixIn(HL7Code.class, HL7CodeObfuscateMixin.class);</span>
    }

    public static List&lt;Allergy&gt; convertAllergies(List&lt;HL7Allergy&gt; hl7AllergyList, Long uploadedDataId, Long patientAccountId, HL7ConnContext hl7ConnContext) {
<span class="fc" id="L661">        List&lt;Allergy&gt; dtoList = new ArrayList&lt;&gt;(hl7AllergyList.size());</span>
<span class="fc" id="L662">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">        for (HL7Allergy hl7Dto : hl7AllergyList) {</span>
<span class="fc" id="L664">            var sourceDetails = new SourceDetails(requestContext);</span>
<span class="fc" id="L665">            Allergy dto = new Allergy(sourceDetails);</span>
<span class="fc" id="L666">            dto.setPatientIsAllergic(true);</span>
<span class="fc" id="L667">            dto.setPatientAccountId(patientAccountId);</span>
<span class="fc" id="L668">            dto.getBaseFields().setUploadedDataId(uploadedDataId);</span>
<span class="fc" id="L669">            dto.setStatus(Allergy.AllergyStatus.ACTIVE);</span>

<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (hl7Dto.getEnteredBy().isValid()) {</span>
<span class="fc" id="L672">                sourceDetails.setText(hl7Dto.getEnteredBy().makeDisplayText());</span>
            }

            // reactions are *not* properly coded in HL7; it's an ST data type, not CE
<span class="fc" id="L676">            List&lt;CodeableConcept&gt; reactions = new ArrayList&lt;&gt;(hl7Dto.getAllergyReactionCodeList().size());</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">            for (HL7String hl7String : hl7Dto.getAllergyReactionCodeList()) {</span>
<span class="fc" id="L678">                reactions.add(new CodeableConcept.Builder(hl7String.getString()).build());</span>
<span class="fc" id="L679">            }</span>

<span class="fc" id="L681">            dto.setAllergen(hl7Dto.getAllergenCode().asCodeableConcept());</span>
<span class="fc" id="L682">            dto.setOnsetOfSymptoms(Optional.ofNullable(hl7Dto.getIdentificationDate().getInstant()).map(Date::from).orElse(null));</span>
<span class="fc" id="L683">            dto.setReactions(reactions);</span>
<span class="fc" id="L684">            dto.setSeverity(hl7Dto.getAllergenSeverityCode().asCodeableConcept());</span>

<span class="fc" id="L686">            dtoList.add(dto);</span>
<span class="fc" id="L687">        }</span>
<span class="fc" id="L688">        return dtoList;</span>
    }

    public static List&lt;Medication&gt; convertMedications(List&lt;HL7Medication&gt; hl7MedicationList, Long uploadedDataId,
                                                      long patientId, Long patientAccountId, HL7ConnContext hl7ConnContext) {
<span class="fc" id="L693">        List&lt;Medication&gt; dtoList = new ArrayList&lt;&gt;(hl7MedicationList.size());</span>
<span class="fc" id="L694">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">        for (HL7Medication hl7Dto : hl7MedicationList) {</span>
<span class="fc" id="L696">            var sourceDetails = new SourceDetails(requestContext);</span>
<span class="fc" id="L697">            Medication dto = new Medication(sourceDetails);</span>
<span class="fc" id="L698">            dto.setPatientOnMedication(true);</span>
<span class="fc" id="L699">            dto.setPatientAccountId(patientAccountId);</span>
<span class="fc" id="L700">            dto.getBaseFields().setUploadedDataId(uploadedDataId);</span>
<span class="fc" id="L701">            dto.setStatus(MedicationStatus.ACTIVE);</span>

<span class="pc bpc" id="L703" title="1 of 2 branches missed.">            if (hl7Dto.getReqBy().isValid()) {</span>
<span class="fc" id="L704">                sourceDetails.setText(hl7Dto.getReqBy().makeDisplayText());</span>
            }

<span class="fc" id="L707">            dto.setDoseUnit(hl7Dto.getUnitCode().asCodeableConcept());</span>

<span class="pc bpc" id="L709" title="1 of 2 branches missed.">            if (hl7Dto.getDoseQuantity().isProvided()) {</span>
<span class="fc" id="L710">                double parsedQty = NumberUtils.toDouble(hl7Dto.getDoseQuantity().getString(), Double.NaN);</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">                if (Double.isNaN(parsedQty)) {</span>
<span class="nc" id="L712">                    LOGGER.error(&quot;PHR-8160 dose value (null = {}) ignored in uploaded data {} from {}&quot;, hl7Dto.getDoseQuantity().isHL7Null(), uploadedDataId, hl7ConnContext);</span>
                } else {
<span class="fc" id="L714">                    dto.setDoseValue(parsedQty);</span>
                }
            }

<span class="fc" id="L718">            dto.setMedication(hl7Dto.getMedicationCode().asCodeableConcept());</span>

<span class="fc" id="L720">            dto.setStartDate(Optional.ofNullable(hl7Dto.getStartTimestamp().getInstant()).map(Date::from).orElse(null));</span>
<span class="fc" id="L721">            dto.setEndDate(Optional.ofNullable(hl7Dto.getEndTimestamp().getInstant()).map(Date::from).orElse(null));</span>

<span class="fc" id="L723">            String freqText = hl7Dto.getRepeatPattern().getString().toLowerCase();</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">            if (StringUtils.isBlank(freqText)) {</span>
<span class="nc" id="L725">                dto.setFrequency(PKBMedicationFrequency.BLANK);</span>
            } else {
                // temporary hack: this is what we're getting from Taiba
<span class="pc bpc" id="L728" title="3 of 4 branches missed.">                if (freqText.startsWith(&quot;every &quot;) &amp;&amp; (freqText.indexOf(&quot; hour&quot;) &gt; 0)) {</span>
<span class="nc" id="L729">                    int startX = &quot;every &quot;.length();</span>
<span class="nc" id="L730">                    String everyString = freqText.substring(startX, freqText.indexOf(' ', startX));</span>
<span class="nc" id="L731">                    Long everyVal = NumberUtils.toLong(everyString, 0);</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                    if (everyVal != 0) {</span>
<span class="nc" id="L733">                        CDAMedicationFrequency cdaFreq = new CDAMedicationFrequency();</span>
<span class="nc" id="L734">                        cdaFreq.setUnit(HL7UnitOfTime.HOUR);</span>
<span class="nc" id="L735">                        cdaFreq.setValue(everyVal);</span>
                        try {
<span class="nc" id="L737">                            PKBMedicationFrequency freq = PKBMedicationFrequency.fromCDAMedicationFrequency(cdaFreq);</span>
<span class="nc" id="L738">                            dto.setFrequency(freq);</span>
<span class="nc" id="L739">                        } catch (PKBPluginException e) {</span>
<span class="nc" id="L740">                            LOGGER.error(&quot;failed converting med freq {}&quot;, everyString, e);</span>
<span class="nc" id="L741">                        }</span>
                    }
                }
                // didn't successfully parse it?
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">                if (dto.getFrequency() == null) {</span>
<span class="fc" id="L746">                    dto.setFrequencyDisplayStr(hl7Dto.getRepeatPattern().getString().trim());</span>
                }
            }

<span class="fc" id="L750">            dto.setInstructions(hl7Dto.getInstructions());</span>

<span class="fc" id="L752">            dtoList.add(dto);</span>
<span class="fc" id="L753">        }</span>
<span class="fc" id="L754">        return dtoList;</span>
    }

    public List&lt;HL7Medication&gt; parseHL7Medications() {
        // list of 0-* ZRX nodes
<span class="fc" id="L759">        NodeList nodeList = root.getElementsByTagName(&quot;ZRX&quot;);</span>

<span class="fc" id="L761">        List&lt;HL7Medication&gt; dtoList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        if (nodeList != null) {</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">            for (int i = 0; i &lt; nodeList.getLength(); ++i) {</span>
<span class="fc" id="L764">                HL7Medication dto = new HL7Medication(messageProperties);</span>
<span class="fc" id="L765">                dto.parseZrx((Element) nodeList.item(i), i + 1);</span>

<span class="fc" id="L767">                HL7ValueExpectation expectation = HL7ValueExpectation.builder()</span>
<span class="fc" id="L768">                        .withId(&quot;ZRX-2.2&quot;)</span>
<span class="fc" id="L769">                        .withName(&quot;give code text&quot;)</span>
<span class="fc" id="L770">                        .withProvidedHL7Value(dto.getMedicationCode().getText())</span>
<span class="fc" id="L771">                        .build();</span>
<span class="fc" id="L772">                enforceMandatoryValue(expectation, false/*absentAllowed*/);</span>

<span class="fc" id="L774">                dtoList.add(dto);</span>
            }
        }
<span class="fc" id="L777">        checkDatapointListForDuplicates(dtoList, &quot;medications&quot;);</span>
<span class="fc" id="L778">        return dtoList;</span>
    }

    public static List&lt;Diagnosis&gt; convertDiagnoses(List&lt;HL7Diagnosis&gt; hl7DiagnosisList, Long uploadedDataId,
                                                   long patientId, Long patientAccountId, HL7ConnContext hl7ConnContext) {
<span class="fc" id="L783">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc" id="L784">        List&lt;Diagnosis&gt; dtoList = new ArrayList&lt;&gt;(hl7DiagnosisList.size());</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">        for (HL7Diagnosis hl7Dto : hl7DiagnosisList) {</span>
<span class="fc" id="L786">            var sourceDetails = new SourceDetails(requestContext);</span>
<span class="fc" id="L787">            Diagnosis dto = new Diagnosis(sourceDetails);</span>
<span class="fc" id="L788">            dto.setPatientAccountId(patientAccountId);</span>
<span class="fc" id="L789">            dto.getBaseFields().setUploadedDataId(uploadedDataId);</span>
            //dto.setStatus( DiagnosisStatus.ACTIVE );

<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            if (hl7Dto.getDiagnosingClinician().isValid()) {</span>
<span class="fc" id="L793">                sourceDetails.setText(hl7Dto.getDiagnosingClinician().makeDisplayText());</span>
            }

<span class="fc" id="L796">            dto.setDiagnosis(hl7Dto.getDiagnosisCode().asCodeableConcept());</span>
<span class="fc" id="L797">            dto.setStartDate(Optional.ofNullable(hl7Dto.getDiagnosisTimestamp().getInstant()).map(Date::from).orElse(null));</span>

<span class="fc" id="L799">            dtoList.add(dto);</span>
<span class="fc" id="L800">        }</span>
<span class="fc" id="L801">        return dtoList;</span>
    }

    public List&lt;HL7Diagnosis&gt; parseHL7Diagnoses() {
        // list of 0-* DG1 nodes
<span class="fc" id="L806">        NodeList nodeList = root.getElementsByTagName(&quot;DG1&quot;);</span>

<span class="fc" id="L808">        List&lt;HL7Diagnosis&gt; dtoList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        if (nodeList != null) {</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">            for (int i = 0; i &lt; nodeList.getLength(); ++i) {</span>
<span class="fc" id="L811">                HL7Diagnosis dto = new HL7Diagnosis(messageProperties);</span>
<span class="fc" id="L812">                dto.parseDg1((Element) nodeList.item(i));</span>

<span class="fc" id="L814">                HL7ValueExpectation expectation_1 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L815">                        .withId(&quot;DG1-3.1&quot;)</span>
<span class="fc" id="L816">                        .withName(&quot;Diagnosis code ID&quot;)</span>
<span class="fc" id="L817">                        .withProvidedHL7Value(dto.getDiagnosisCode().getId())</span>
<span class="fc" id="L818">                        .build();</span>
<span class="fc" id="L819">                HL7ValueExpectation expectation_2 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L820">                        .withId(&quot;DG1-3.2&quot;)</span>
<span class="fc" id="L821">                        .withName(&quot;Diagnosis code text&quot;)</span>
<span class="fc" id="L822">                        .withProvidedHL7Value(dto.getDiagnosisCode().getText())</span>
<span class="fc" id="L823">                        .build();</span>
<span class="fc" id="L824">                List&lt;HL7ValueExpectation&gt; expectations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L825">                expectations.add(expectation_1);</span>
<span class="fc" id="L826">                expectations.add(expectation_2);</span>
<span class="fc" id="L827">                enforceMandatoryValueAtLeastOne(expectations, false/*absentAllowed*/);</span>

<span class="fc" id="L829">                dtoList.add(dto);</span>
            }
        }
<span class="fc" id="L832">        checkDatapointListForDuplicates(dtoList, &quot;diagnoses&quot;);</span>
<span class="fc" id="L833">        return dtoList;</span>
    }

    //======================== ORU MESSAGE HANDLING (SEVERAL SEGMENTS)

    private void validateOrderGroups(List&lt;HL7OrderGroup&gt; orderGroups, ObrValidationMode obrValidationMode, HL7ConnContext context, Destination destination) throws ApiCallMalformedException {
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (this.getMessageType() == HL7MessageType.ORU_R01) {</span>

            // If validation mode is REJECT_MULTIPLE, then forbid &gt;1 result for any test ID within a group
<span class="fc bfc" id="L842" title="All 2 branches covered.">            if (obrValidationMode == ObrValidationMode.REJECT_MULTIPLE) {</span>
<span class="fc" id="L843">                List&lt;HL7OrderGroup&gt; groupsToReject = orderGroups.stream().filter(group -&gt; {</span>
<span class="fc" id="L844">                    List&lt;List&lt;HL7Observation&gt;&gt; observationsByTestId = new ArrayList&lt;&gt;(</span>
<span class="fc" id="L845">                            group.getObservationList()</span>
<span class="fc" id="L846">                                    .stream()</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">                                    .filter(obs -&gt; !obs.isProcessed())</span>
<span class="fc" id="L848">                                    .collect(Collectors.groupingBy(HL7Observation::getTestId))</span>
<span class="fc" id="L849">                                    .values());</span>

<span class="fc bfc" id="L851" title="All 2 branches covered.">                    boolean qualifiesAsTextReport = observationsByTestId.size() == 1</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">                            &amp;&amp; Stream.ofAll(group.getObservationList()).forAll(HL7Observation::isTextValueType);</span>

<span class="fc" id="L854">                    long nrOfRejects = observationsByTestId.stream()</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">                            .filter(observationsWithSameTestId -&gt; observationsWithSameTestId.size() &gt; 1)</span>
<span class="fc" id="L856">                            .count();</span>

<span class="fc bfc" id="L858" title="All 4 branches covered.">                    return !qualifiesAsTextReport &amp;&amp; nrOfRejects &gt; 0;</span>
<span class="fc" id="L859">                }).collect(toList());</span>

<span class="fc bfc" id="L861" title="All 2 branches covered.">                if (!groupsToReject.isEmpty()) {</span>
<span class="fc" id="L862">                    String message = &quot;OBR group contains more than one result for a single test ID.&quot;;</span>

<span class="fc" id="L864">                    LOGGER.warn(&quot;{} HL7ConnContext {}&quot;, message, context);</span>
<span class="fc" id="L865">                    throw new ApiCallMalformedException(message);</span>
                }
            }

            // Regardless of validation mode, ensure each OBR group in a radiology report or test results message has
            // exactly 1 Filler Order Number.
            //
            // 2021-02-12: Ultimately this check should be done for all data types, but we are not yet able to mandate
            // it for measurements.
            // 2022-03-09: We can prohibit conflicting FONs for all data types, but it still needs to remain optional
            // for measurements.
            //
            // See: PHR-5674, PHR-7689, PHR-7711
<span class="fc bfc" id="L878" title="All 2 branches covered.">            boolean enforceMandatory = (Destination.MEASUREMENT != destination);</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">            for (HL7OrderGroup group : orderGroups) {</span>

                // If the OBR group contained only measurements (a measurement is identified because isProcessed
                // will have been set to true) then it is not an error for there to have been no FON, because there
                // are no lab results to store it on.
                //
                // This will remain an annoying edge case until we can mandate FON for measurements too.
                //
                // See: PHR-7983, PHR-7711
<span class="fc bfc" id="L888" title="All 2 branches covered.">                if (Destination.TEST_RESULT == destination) {</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">                    if (group.getObservationList().stream().allMatch(HL7Observation::isProcessed)) {</span>
<span class="fc" id="L890">                        continue;</span>
                    }
                }

<span class="fc" id="L894">                validateFillerOrderNumber(group, enforceMandatory);</span>
<span class="fc" id="L895">            }</span>

            // Regardless of validation mode or data type, ensure no R01 message group contains &gt;1 Filler Order Number.
            // This is possible because the R01 message can contain more than one OBR group, each of which declares its
            // own FON.
            // See: PHR-7941
<span class="fc" id="L901">            Set&lt;String&gt; fillerOrderNumbers = orderGroups.stream().map(x -&gt; x.getMostSignificantFON().getString())</span>
<span class="fc" id="L902">                    .filter(StringUtils::isNotBlank)</span>
<span class="fc" id="L903">                    .collect(Collectors.toSet());</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            if (fillerOrderNumbers.size() &gt; 1) {</span>
<span class="fc" id="L905">                throw new ApiCallMalformedException(format(&quot;An ORU R01 message must contain exactly 1 Filler Order Number. You provided: %s&quot;, fillerOrderNumbers));</span>
            }
        }
<span class="fc" id="L908">    }</span>

    private void validateFillerOrderNumber(HL7OrderGroup orderGroup, boolean enforceMandatory) {
<span class="fc" id="L911">        HL7String obrFON = orderGroup.getObrFillerOrderNumber();</span>
<span class="fc" id="L912">        HL7String orcFON = orderGroup.getOrcFillerOrderNumber();</span>

        // Deletions are based on the FON, so a deletion status always implies a mandatory FON
<span class="fc bfc" id="L915" title="All 4 branches covered.">        if (enforceMandatory || orderGroup.isDeletionStatus()) {</span>
<span class="fc" id="L916">            HL7ValueExpectation expectation_ORC_FON = HL7ValueExpectation.builder()</span>
<span class="fc" id="L917">                    .withId(&quot;ORC-3.1&quot;)</span>
<span class="fc" id="L918">                    .withName(&quot;filler order number&quot;)</span>
<span class="fc" id="L919">                    .withProvidedHL7Value(orcFON)</span>
<span class="fc" id="L920">                    .build();</span>
<span class="fc" id="L921">            HL7ValueExpectation expectation_OBR_FON = HL7ValueExpectation.builder()</span>
<span class="fc" id="L922">                    .withId(&quot;OBR-3.1&quot;)</span>
<span class="fc" id="L923">                    .withName(&quot;filler order number&quot;)</span>
<span class="fc" id="L924">                    .withProvidedHL7Value(obrFON)</span>
<span class="fc" id="L925">                    .build();</span>
<span class="fc" id="L926">            List&lt;HL7ValueExpectation&gt; expectations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L927">            expectations.add(expectation_ORC_FON);</span>
<span class="fc" id="L928">            expectations.add(expectation_OBR_FON);</span>
<span class="fc" id="L929">            enforceMandatoryValueAtLeastOne(expectations);</span>
        }

        // Even when not mandating a FON it is still an error to provide conflicting values
<span class="fc bfc" id="L933" title="All 4 branches covered.">        if (obrFON.isProvided() &amp;&amp; orcFON.isProvided()) {</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">            if (!obrFON.equals(orcFON)) {</span>
<span class="fc" id="L935">                throw new ApiCallMalformedException(&quot;ORC-3.1 and OBR-3.1 must not be different&quot;);</span>
            }
        }
<span class="fc" id="L938">    }</span>

    /**
     * Structure view: see here: http://www.corepointhealth.com/resource-center/hl7-resources/hl7-oru-message
     * Here we're interested in the OrderGroup (may have multiple in a row in a message)
     * Structure (in this sequence):
     * ORC (0-1) Common order details (can contain lab order id)
     * OBR (1) Observation request (lab order id, fallback date of obs if not in OBX records)
     * NTE (0-*) Note at the order level (we attach these to all results)
     * Observation Group (0-*) sub-group
     * OBX (0-1) Observation
     * NTE (0-*) Note attached to OBX
     * &lt;p&gt;
     * Some variations: multiple lines in a text value in the OBX are handled in a few ways:
     * by including linebreaks
     * by separating lines with the multiple value separator ~
     * by putting lines in additional OBX records with the same set ID (in OBX-1)
     * by putting lines in additional OBX records with DIFFERENT set IDs, but all &quot;text&quot; value type
     *
     * @return
     */
    private List&lt;HL7OrderGroup&gt; parseOrderGroups(ObrValidationMode obrValidationMode, HL7ConnContext context, Destination destination) {
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (this.orderGroups.isPresent()) {</span>
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">            if (this.orderGroups.get().isRight()) {</span>
<span class="fc" id="L962">                List&lt;HL7OrderGroup&gt; result = this.orderGroups.get().get();</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">                validateOrderGroups(result.stream().filter(orderGroup -&gt; !orderGroup.isProcessed()).collect(toList()), obrValidationMode, context, destination);</span>
<span class="fc" id="L964">                return result;</span>
            } else {
<span class="nc" id="L966">                throw this.orderGroups.get().getLeft();</span>
            }
        }

<span class="fc" id="L970">        List&lt;HL7OrderGroup&gt; groupList = new ArrayList&lt;&gt;();</span>

        // loop the segments of the message -- to grab the OBR record (at the start) for each set of OBX records
        // note: &lt;HL7Message&gt; is root
<span class="fc" id="L974">        NodeList segListRaw = root.getChildNodes();</span>
<span class="fc" id="L975">        Element[] segList = Stream.range(0, segListRaw.getLength())</span>
<span class="fc" id="L976">                .map(i -&gt; segListRaw.item(i))</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">                .filter(node -&gt; node.getNodeType() == Node.ELEMENT_NODE)</span>
<span class="fc" id="L978">                .map(node -&gt; (Element) node)</span>
<span class="fc" id="L979">                .toJavaArray(Element[]::new);</span>

<span class="fc" id="L981">        HL7OrderGroup group = null;</span>

<span class="fc bfc" id="L983" title="All 2 branches covered.">        for (int segX = 0; segX &lt; segList.length; segX++) {</span>
<span class="fc" id="L984">            Element seg = segList[segX];</span>
<span class="fc" id="L985">            String segName = seg.getTagName();</span>

<span class="fc bfc" id="L987" title="All 2 branches covered.">            if (segName.equals(&quot;OBR&quot;)) {</span>
                // start a new group, and gather ORC data (if the prev segment was an ORC)
                // ORCs are optional, so we'll only check for them as preceding an OBR.
<span class="fc" id="L990">                group = new HL7OrderGroup(messageProperties);</span>
<span class="fc" id="L991">                groupList.add(group); // add it to the list BEFORE populating it</span>

<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                if (segX &gt; 0) {</span>
<span class="fc" id="L994">                    Element prevSeg = segList[segX - 1];</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">                    if (prevSeg.getTagName().equals(&quot;ORC&quot;)) {</span>
<span class="fc" id="L996">                        group.parseOrc(prevSeg);</span>
                    }
                }

<span class="fc" id="L1000">                group.parseObr(seg);</span>

                // 2018-03-13: Tom: Gathering info for PHR-3827
<span class="fc" id="L1003">                HL7String obr25 = HL7XmlDoc.getHl7Text(seg, &quot;OBR.25.1&quot;);</span>
<span class="fc" id="L1004">                LOGGER.info(&quot;PHR-3827: value=[{}] raw=[{}]&quot;, obr25.getString(), obr25.getRawValue());</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                if (StringUtils.isBlank(obr25.getString())) {</span>
                    // Specific log line for missing value
<span class="fc" id="L1007">                    LOGGER.info(&quot;PHR-3827: OBR-25 was blank&quot;);</span>
<span class="fc bfc" id="L1008" title="All 4 branches covered.">                } else if (!&quot;F&quot;.equals(obr25.getString()) &amp;&amp; !&quot;C&quot;.equals(obr25.getString())) {</span>
                    // Expecting most values to be F or C, log specific line when this is not true
<span class="fc" id="L1010">                    LOGGER.info(&quot;PHR-3827: OBR-25 was not F or C: value=[{}] raw=[{}]&quot;, obr25.getString(), obr25.getRawValue());</span>
                }

<span class="fc bfc" id="L1013" title="All 2 branches covered.">            } else if (seg.getTagName().equals(&quot;NTE&quot;)) {</span>

                // if the group has OBXes, the note is added to the latest (NTEs after an OBX attach to it)
                // otherwise, it's an OBR note.

                // if group is NULL, this is a NTE on something outside an order group; ignore
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">                if (group != null) {</span>
<span class="fc" id="L1020">                    group.parseNte(seg);</span>
                }
<span class="fc bfc" id="L1022" title="All 2 branches covered.">            } else if (seg.getTagName().equals(&quot;OBX&quot;)) {</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">                if (group != null) {</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">                    if (group.isDeletionStatus()) {</span>
                        // No need to parse the OBX segments, we already know we will delete the entire OBR group
                    } else {
<span class="fc" id="L1027">                        group.parseObx(seg);</span>
                    }
                }
            }
        }

        // If we processed all segments and did not find an OBR group, then throw an error
<span class="fc bfc" id="L1034" title="All 2 branches covered.">        if (group == null) {</span>
<span class="fc" id="L1035">            throw new ApiCallMalformedException(&quot;OBR segment not found&quot;);</span>
        }

        try {
<span class="fc" id="L1039">            validateOrderGroups(groupList, obrValidationMode, context, destination);</span>
<span class="fc" id="L1040">            this.orderGroups = Optional.of(Either.right(groupList));</span>
<span class="fc" id="L1041">        } catch (ApiCallMalformedException e) {</span>
<span class="fc" id="L1042">            this.orderGroups = Optional.of(Either.left(e));</span>
<span class="fc" id="L1043">            throw e;</span>
<span class="fc" id="L1044">        }</span>

<span class="fc" id="L1046">        return groupList;</span>
    }

    /**
     * Returns an optional UploadedDataDeletionMetadata, representing lab orders to be deleted.
     *
     * @param hl7ConnContext The HL7 connection context.
     * @param uploadedDataId The uploaded data entry triggering the deletion - used for source tracking.
     * @return An optional UploadedDataDeletionMetadata, capturing information about the deletion.
     */
    public Optional&lt;UploadedDataDeletionMetadata&gt; parseLabBulkDeletions(HL7ConnContext hl7ConnContext, Long uploadedDataId) {
<span class="fc" id="L1057">        List&lt;HL7OrderGroup&gt; orderGroups = parseOrderGroups(ObrValidationMode.REJECT_MULTIPLE, hl7ConnContext, Destination.TEST_RESULT);</span>
<span class="fc" id="L1058">        return getDeletedObrInformation(hl7ConnContext, orderGroups, uploadedDataId);</span>
    }

    /**
     * Returns an optional UploadedDataDeletionMetadata, representing measurements to be deleted.
     *
     * @param hl7ConnContext The HL7 connection context.
     * @param uploadedDataId The uploaded data entry triggering the deletion - used for source tracking.
     * @return An optional UploadedDataDeletionMetadata, capturing information about the deletion.
     */
    public Optional&lt;UploadedDataDeletionMetadata&gt; parseMeasurementDeletions(HL7ConnContext hl7ConnContext, Long uploadedDataId) {
<span class="fc" id="L1069">        List&lt;HL7OrderGroup&gt; orderGroups = parseOrderGroups(ObrValidationMode.ALLOW_MULTIPLE, hl7ConnContext, Destination.MEASUREMENT);</span>
<span class="fc" id="L1070">        return getDeletedObrInformation(hl7ConnContext, orderGroups, uploadedDataId);</span>
    }

    /**
     * Iterates through the provided order groups and sets processed to true for any that are flagged for deletion.
     * &lt;p&gt;
     * If any are marked for deletion, then the Filler Order Number along with deletion metadata are returned in an
     * UploadedDataDeletionMetadata object. The nature of the syntax is that a list of FON+metadata pairs is generated,
     * but we return just the first. The reason we only need one of each attribute in the pair is explained below.
     * &lt;p&gt;
     * Filler Order Number: It is an error for more than one FON to be specified in a single R01 message, and this is
     * validated elsewhere.
     * &lt;p&gt;
     * Deletion metadata: It is syntactically possible for a different ordering clinician to be provided inside each OBR
     * group, but tracking different source metadata for panel-level deletions is not supported by PKB because we have
     * only a best-efforts approach to tracking panels. As such, this method will simply return a single set of deletion
     * metadata.
     *
     * @param hl7ConnContext
     * @param orderGroups
     * @param uploadedDataId
     * @return
     */
    private Optional&lt;UploadedDataDeletionMetadata&gt; getDeletedObrInformation(HL7ConnContext hl7ConnContext, List&lt;HL7OrderGroup&gt; orderGroups, Long uploadedDataId) {
<span class="fc" id="L1094">        EHRRequestContext requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc" id="L1095">        return orderGroups.stream()</span>
<span class="fc" id="L1096">                .filter(HL7OrderGroup::isDeletionStatus)</span>
<span class="fc" id="L1097">                .map(group -&gt; {</span>
<span class="fc" id="L1098">                    var sourceDetails = new SourceDetails(requestContext);</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">                    if (group.getReqBy().isValid()) {</span>
<span class="fc" id="L1100">                        sourceDetails.setText(group.getReqBy().makeDisplayText());</span>
                    }
<span class="fc" id="L1102">                    group.setProcessed(true);</span>
<span class="fc" id="L1103">                    return new UploadedDataDeletionMetadata(group.getMostSignificantFON().toString(), sourceDetails, getMessageDate().getInstant(), uploadedDataId);</span>
                })
<span class="fc" id="L1105">                .findFirst();</span>
    }

    /**
     * Allows a caller to specify the reason they are making a call. Methods can use this reason to determine e.g.
     * whether it is appropriate to persist to the database.
     */
<span class="fc" id="L1112">    public enum CallReason {</span>
        /**
         * Indicates that this is a &quot;dry run&quot; to validate the data, and no data is required to be persisted to the
         * medical record.
         */
<span class="fc" id="L1117">        VALIDATION_ONLY,</span>
        /**
         * Indicates that this is a &quot;real&quot; call and data is required to be persisted to the medical record.
         */
<span class="fc" id="L1121">        PROCESS_AND_PERSIST</span>
    }

    public List&lt;TestResultDTO&gt; parseLabResults(HL7ConnContext hl7ConnContext, ReferenceDatumService referenceDatumService, LoincManager loincManager) {
<span class="fc" id="L1125">        return parseLabResults(hl7ConnContext, referenceDatumService, loincManager, CallReason.PROCESS_AND_PERSIST);</span>
    }

    public List&lt;TestResultDTO&gt; parseLabResults(HL7ConnContext hl7ConnContext, ReferenceDatumService referenceDatumService, LoincManager loincManager, CallReason callReason) {
<span class="fc" id="L1129">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc" id="L1130">        List&lt;HL7OrderGroup&gt; orderGroups = parseOrderGroups(ObrValidationMode.REJECT_MULTIPLE, hl7ConnContext, Destination.TEST_RESULT);</span>
<span class="fc" id="L1131">        List&lt;TestResultDTO&gt; resultList = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1133">        long sourceOrgId = hl7ConnContext.getSourceOrgId();</span>

<span class="fc" id="L1135">        Map&lt;UniqueHl7ObservationKey, List&lt;HL7Observation&gt;&gt; observationsByTestCode = new HashMap&lt;&gt;();</span>

<span class="fc" id="L1137">        String msh10 = getMessageIdString();</span>

<span class="fc bfc" id="L1139" title="All 2 branches covered.">        List&lt;HL7OrderGroup&gt; groupsNotProcessed = orderGroups.stream().filter(g -&gt; !g.isProcessed()).collect(Collectors.toList());</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        for (HL7OrderGroup orderGroup : groupsNotProcessed) {</span>
            // merge OBXs that are just lines in a (single) textual report
<span class="fc" id="L1142">            boolean isTextualReport = orderGroup.collapseTextReports();</span>
            // make sure we have valid set IDs (to affect sorting on display)
<span class="fc" id="L1144">            orderGroup.forceObxSetIds();</span>

<span class="fc" id="L1146">            String fillerOrderNumber = orderGroup.getMostSignificantFON().getString();</span>

<span class="fc" id="L1148">            String serviceName = orderGroup.getObrServiceCode().getText().getString();</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">            if (StringUtils.isEmpty(serviceName)) {</span>
<span class="fc" id="L1150">                serviceName = StringUtils.trimToNull(orderGroup.getObrServiceCode().getAltText().getString());</span>
<span class="fc" id="L1151">                LOGGER.warn(&quot;HL7 Code Confusion: Reading alt text for parseLabResults obrServiceCode ({}) in message {} from {}&quot;,</span>
<span class="fc" id="L1152">                        orderGroup.getObrServiceCode().getAltText().isBlank(), getMessageIdString(), hl7ConnContext);</span>
            }

<span class="fc" id="L1155">            String reqBySource = null;</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            if (orderGroup.getReqBy().isValid()) {</span>
<span class="fc" id="L1157">                reqBySource = orderGroup.getReqBy().makeDisplayText();</span>
            }

<span class="fc" id="L1160">            int obxSequence = 0; // for capturing sequence rec'd in LoincMappings</span>

            loopObservations:
<span class="fc bfc" id="L1163" title="All 2 branches covered.">            for (HL7Observation obx : orderGroup.getObservationList()) {</span>
<span class="fc" id="L1164">                obxSequence++;</span>

<span class="fc bfc" id="L1166" title="All 2 branches covered.">                if (obx.isProcessed()) {</span>
<span class="fc" id="L1167">                    continue;</span>
                }

                // PHR-8381: Log an error if this result is not a duplicate of any result already provided for this test code.
                // Note: earlier validation will have ensured that if there is more than one result for a given test code that each result was provided in a different panel.
<span class="fc" id="L1172">                int countOfObservationsByTestCode = observationsByTestCode.compute(new UniqueHl7ObservationKey(fillerOrderNumber, obx), (key, observations) -&gt; {</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                    if (observations == null) {</span>
<span class="fc" id="L1174">                        observations = new LinkedList&lt;&gt;();</span>
                    }
<span class="fc bfc" id="L1176" title="All 2 branches covered.">                    if (!observations.isEmpty()) {</span>
<span class="fc" id="L1177">                        LOGGER.warn(&quot;PHR-5589: Repeated reporting of single test across multiple profiles. Filler Order Number {} in message {} from {}&quot;,</span>
                                fillerOrderNumber, msh10, hl7ConnContext);
                    }
<span class="fc bfc" id="L1180" title="All 4 branches covered.">                    if (observations.stream().filter(x -&gt; !x.isDuplicateHl7Obx(obx)).count() &gt; 0) {</span>
<span class="fc" id="L1181">                        LOGGER.error(&quot;PHR-8381: Different values in repeated reporting of single test across multiple profiles. Filler Order Number {} in message {} from {}&quot;,</span>
                                fillerOrderNumber, msh10, hl7ConnContext);
                    }
<span class="fc" id="L1184">                    observations.add(obx);</span>
<span class="fc" id="L1185">                    return observations;</span>
<span class="fc" id="L1186">                }).size();</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">                if (countOfObservationsByTestCode != 1) {</span>
                    // Silently skip this result, because it is not the first for this test code within this order.
                    // See PHR-5672 for a discussion about whether to reject the message instead.
<span class="fc" id="L1190">                    continue;</span>
                }

<span class="fc bfc" id="L1193" title="All 2 branches covered.">                HL7Code mostSignificantCode = (isTextualReport) ? orderGroup.getObrServiceCode() : obx.getTestCode();</span>

<span class="fc" id="L1195">                String obxTrace = &quot;OBR[&quot; + orderGroup.getObrSetId().getString() + &quot;].OBX[&quot; + obx.getObxSetId().getString() + &quot;]&quot;;</span>

                // now we're in the Observation group... take OBX &amp; notes

<span class="fc" id="L1199">                HL7String testName = mostSignificantCode.getText();</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">                if (!testName.isProvided()) {</span>
<span class="fc" id="L1201">                    testName = mostSignificantCode.getAltText();</span>
<span class="fc" id="L1202">                    LOGGER.warn(&quot;HL7 Code Confusion: Reading alt text for parseLabResults mostSignificantCode: ({}) in message {} from {}&quot;,</span>
<span class="fc" id="L1203">                            mostSignificantCode.getAltText().isBlank(), getMessageIdString(), hl7ConnContext);</span>
                }

                // If this org has a mapping for this unit, apply it now
                // TODO: actually changing data should be at display-time, not here.
                // Initial step fixing this (2016-05-12): store the unit code and coding system if provided in the LoincMapping
                // See PHR-5210 to review how this works.
<span class="fc" id="L1210">                HL7String unitText = obx.getUnitCode().getText();</span>
<span class="fc" id="L1211">                String unitTextElseIdMaybeMapped = unitText.getString();</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">                if (unitText.isBlank()) {</span>
<span class="fc" id="L1213">                    HL7String unitId = obx.getUnitCode().getId();</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">                    if (unitId.isNotBlank()) {</span>
<span class="fc" id="L1215">                        ReferenceDatum datum = referenceDatumService.getReferenceDatum(sourceOrgId, UNIT, unitId.getString()).getOrNull();</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">                        if (datum != null) {</span>
<span class="fc" id="L1217">                            unitTextElseIdMaybeMapped = datum.getDataText();</span>
                        } else {
<span class="fc" id="L1219">                            unitTextElseIdMaybeMapped = unitId.getString();</span>
                        }
                    }
                }

                // ignore valueTypes that we know are not test results
                // indented items in list below are IGNORED
                //                Code	Description
                //                	AD	Address
                //                CF	Coded Element With Formatted Values
                //                CK	Composite ID With Check Digit
                //                CN	Composite ID And Name
                //                	CP	Composite Price
                //                CT	Text Data (Display) NON-STANDARD but used by ChelWest
                //                CWE	Coded Entry
                //                CX	Extended Composite ID With Check Digit
                //                	DT	Date
                //                	DTM	Time Stamp (Date &amp; Time)
                //                	ED	Encapsulated Data
                //                FT	Formatted Text (Display)
                //                	MO	Money
                //                NM	Numeric
                //                	PN	Person Name
                //                	RP	Reference Pointer
                //                SN	Structured Numeric
                //                ST	String Data.
                //                	TM	Time
                //                	TN	Telephone Number
                //                TX	Text Data (Display)
                //                	XAD	Extended Address
                //                	XCN	Extended Composite Name And Number For Persons
                //                	XON	Extended Composite Name And Number For Organizations
                //                	XPN	Extended Person Name
                //                	XTN	Extended Telecommunications Number
                // blacklist (not whitelist) so we accept as test result if we don't recognize it
                // e.g., getting CE from St Marks IF...
<span class="fc" id="L1255">                String[] ignoreValueTypes = new String[]{&quot;AD&quot;, &quot;CP&quot;, &quot;DT&quot;, &quot;DTM&quot;, &quot;ED&quot;, &quot;MO&quot;, &quot;PN&quot;, &quot;RP&quot;, &quot;TM&quot;, &quot;TN&quot;, &quot;XAD&quot;, &quot;XCN&quot;,</span>
                        &quot;XON&quot;, &quot;XPN&quot;, &quot;XTN&quot;};
<span class="fc bfc" id="L1257" title="All 2 branches covered.">                if (ArrayUtils.contains(ignoreValueTypes, obx.getValueType().getString())) {</span>
<span class="fc" id="L1258">                    LOGGER.info(&quot;{}: value type {}; skipping&quot;, obxTrace, obx.getValueType().getString());</span>
<span class="fc" id="L1259">                    continue loopObservations;</span>
                }

                // if they didn't provide a coding system, make sure it's set to empty string
<span class="fc bfc" id="L1263" title="All 2 branches covered.">                if (mostSignificantCode.getCodingSystem().isBlank()) {</span>
<span class="fc" id="L1264">                    mostSignificantCode.setCodingSystem(&quot;&quot;);</span>
                }

                // required fields
<span class="fc" id="L1268">                String notFound = &quot;&quot;;</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">                if (mostSignificantCode.getId().isBlank()) {</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">                    notFound += (isTextualReport) ? &quot;OBR-4.1 (service ID), &quot; : &quot;OBX-3.1 (test ID), &quot;;</span>
                }
<span class="fc bfc" id="L1272" title="All 4 branches covered.">                if (obx.getValueText().isBlank() &amp;&amp; obx.getValueNumeric() == null) {</span>
<span class="fc" id="L1273">                    boolean allEmpty = true;</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">                    for (HL7String note : obx.getNoteList()) {</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">                        if (note.isNotBlank()) {</span>
<span class="fc" id="L1276">                            allEmpty = false;</span>
<span class="fc" id="L1277">                            break;</span>
                        }
<span class="nc" id="L1279">                    }</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                    if (allEmpty) {</span>
<span class="fc" id="L1281">                        notFound += &quot;OBX-5.1 (result value or report), &quot;;</span>
                    }
                }

                // validate valueText below

<span class="fc bfc" id="L1287" title="All 2 branches covered.">                if (StringUtils.isNotEmpty(notFound)) {</span>
<span class="fc" id="L1288">                    throw new ApiCallMalformedException(</span>
<span class="fc" id="L1289">                            &quot;Missing data in &quot; + obxTrace + &quot;: &quot; + notFound.substring(0, notFound.length() - 2));</span>
                }

<span class="fc" id="L1292">                Instant timestamp = obx.getTimestamp().getInstant();</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">                if (timestamp == null) {</span>
<span class="fc" id="L1294">                    timestamp = orderGroup.getObrTimestamp().getInstant();</span>
                }
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">                if (timestamp == null) {</span>
<span class="nc" id="L1297">                    throw new ApiCallMalformedException(obxTrace + &quot;: No observation timestamp in OBX or OBR&quot;);</span>
                }

<span class="fc" id="L1300">                var sourceDetails = new SourceDetails(requestContext);</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">                if (reqBySource != null) {</span>
<span class="fc" id="L1302">                    sourceDetails.setText(reqBySource);</span>
                }
<span class="fc" id="L1304">                TestResultDTO result = new TestResultDTO(sourceDetails);</span>

                // Record obr service code for assigning privacy labels later
<span class="fc" id="L1307">                result.setObrServiceCode(orderGroup.getObrServiceCode().getId().getString());</span>
<span class="fc" id="L1308">                result.setLabOrderId(fillerOrderNumber);</span>
<span class="fc" id="L1309">                result.setServiceNameFromSource(serviceName);</span>

                // Since PHR-8243 all results are linked to a LoincMapping, and optionally a LoincTest.
<span class="fc" id="L1312">                LoincMapping loincMapping = loincManager.findLoincMapping(sourceOrgId, mostSignificantCode.getId().getString(),</span>
<span class="fc" id="L1313">                        mostSignificantCode.getCodingSystem().getString(), unitTextElseIdMaybeMapped);</span>
<span class="fc" id="L1314">                Optional&lt;LoincTest&gt; loincTest = Optional.empty();</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">                if (LoincTest.CODING_SYSTEM.equalsIgnoreCase(mostSignificantCode.getCodingSystem().getString())) {</span>
<span class="fc" id="L1316">                    loincTest = loincManager.findLoincTestByLoincCodeAndUnits(mostSignificantCode.getId().getString(), unitTextElseIdMaybeMapped);</span>
                }
<span class="fc bfc" id="L1318" title="All 2 branches covered.">                if (loincMapping == null) {</span>
                    // Create a new LoincMapping entry
<span class="fc" id="L1320">                    LoincMapping newLoincMapping = new LoincMapping();</span>
<span class="fc" id="L1321">                    newLoincMapping.setOrg(hl7ConnContext.getSourceOrg());</span>
<span class="fc" id="L1322">                    hl7ConnContext.getSourceTeam().ifPresent(newLoincMapping::setTeam);</span>
<span class="fc" id="L1323">                    hl7ConnContext.getHl7Partner().ifPresent(hl7partner -&gt; newLoincMapping.setHl7PartnerId(hl7partner.getId().getOrElse((Long) null)));</span>
<span class="fc" id="L1324">                    newLoincMapping.setTestCodingSystem(mostSignificantCode.getCodingSystem().getString());</span>
<span class="fc" id="L1325">                    newLoincMapping.setTestCode(mostSignificantCode.getId().getString());</span>
<span class="fc" id="L1326">                    newLoincMapping.setName(testName.getString());</span>
<span class="fc" id="L1327">                    newLoincMapping.setUnitCode(obx.getUnitCode().getId().getString());</span>
<span class="fc" id="L1328">                    newLoincMapping.setUnitCodingSystem(obx.getUnitCode().getCodingSystem().getString());</span>
<span class="fc" id="L1329">                    newLoincMapping.setUnit(unitTextElseIdMaybeMapped);</span>
<span class="fc" id="L1330">                    newLoincMapping.setServiceName(serviceName);</span>
<span class="fc" id="L1331">                    newLoincMapping.setSequenceInGroup(obxSequence);</span>
<span class="fc" id="L1332">                    newLoincMapping.setEnteredDate(getMessageDate().getInstant());</span>
                    // If we have found a matching LoincTest, then automatically map the new LoincMapping
<span class="fc" id="L1334">                    loincTest.ifPresent(test -&gt; {</span>
<span class="fc" id="L1335">                        newLoincMapping.setLoincTest(test);</span>
<span class="fc" id="L1336">                        newLoincMapping.setExpectedValueType(test.getExpectedValueType());</span>
<span class="fc" id="L1337">                    });</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">                    if (CallReason.PROCESS_AND_PERSIST == callReason) {</span>
<span class="fc" id="L1339">                        loincManager.addLoincMapping(newLoincMapping);</span>
                    }
<span class="fc" id="L1341">                    loincMapping = newLoincMapping;</span>
<span class="fc bfc" id="L1342" title="All 2 branches covered.">                } else if (isNewerLoincMappingInfo(loincMapping.getEnteredDate(), getMessageDate().getInstant())) {</span>
                    // Update the existing LoincMapping entry
<span class="fc" id="L1344">                    boolean mappingUpdated = false;</span>
<span class="pc bpc" id="L1345" title="1 of 4 branches missed.">                    if (testName.isProvided() &amp;&amp; !testName.getString().equals(loincMapping.getName())) {</span>
<span class="fc" id="L1346">                        loincMapping.setName(testName.getString());</span>
<span class="fc" id="L1347">                        mappingUpdated = true;</span>
                    }
<span class="fc bfc" id="L1349" title="All 2 branches covered.">                    if (mappingUpdated) {</span>
<span class="fc" id="L1350">                        loincMapping.setEnteredDate(getMessageDate().getInstant());</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">                        if (CallReason.PROCESS_AND_PERSIST == callReason) {</span>
<span class="fc" id="L1352">                            loincManager.updateLoincMapping(loincMapping);</span>
                        }
                    }
                }
                // Record the LoincTest, if there is one.
                // Note: The LoincTest ID should not be stored in 2 differenct places; see PHR-10419.
<span class="fc" id="L1358">                LoincMapping finalLoincMapping = loincMapping;</span>
<span class="fc" id="L1359">                loincTest.or(() -&gt; Optional.ofNullable(finalLoincMapping.getLoincTest()))</span>
<span class="fc" id="L1360">                        .map(LoincTest::getId)</span>
<span class="fc" id="L1361">                        .ifPresent(result::setLoincTestId);</span>
                // Record the LoincMapping and original values directly into the result
<span class="fc bfc" id="L1363" title="All 2 branches covered.">                if (CallReason.PROCESS_AND_PERSIST == callReason) {</span>
<span class="fc" id="L1364">                    result.setLoincMappingId(loincMapping.getId());</span>
                }

<span class="fc" id="L1367">                var codeableConceptBuilder = new CodeableConcept.Builder()</span>
<span class="fc" id="L1368">                        .coding(new Coding.Builder(mostSignificantCode.getId().getString(), mostSignificantCode.getCodingSystem().getString()).build());</span>

<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">                if (mostSignificantCode.getAltId().isNotBlank()) {</span>
<span class="nc" id="L1371">                    codeableConceptBuilder.coding(new Coding.Builder(mostSignificantCode.getAltId().getString(), mostSignificantCode.getAltCodingSystem().getString()).build());</span>
                }

<span class="fc" id="L1374">                result.setCoding(codeableConceptBuilder.build());</span>

<span class="fc" id="L1376">                result.setTestCodeFromSource(mostSignificantCode.getId().getString());</span>
<span class="fc" id="L1377">                result.setTestCodingSystemFromSource(mostSignificantCode.getCodingSystem().getString());</span>

                // Set any sender-specified delay
<span class="fc" id="L1380">                HL7Util.getPatientDelayDays(obx.getAccessChecks().getString(), obxTrace).ifPresent(result::setDelayDisplayDays);</span>

<span class="fc bfc" id="L1382" title="All 2 branches covered.">                Optional&lt;TestResultDTO.ComparatorOperator&gt; dataModelComparator = obx.getValueComparator() == null</span>
<span class="fc" id="L1383">                        ? Optional.empty()</span>
<span class="fc" id="L1384">                        : obx.getValueComparator().dataModelEquivalent();</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">                if (loincMapping.expectsTextualValue()) {</span>
                    // If SN then construct a textual representation, otherwise just take the original text
<span class="fc bfc" id="L1387" title="All 4 branches covered.">                    if (obx.getValueNumeric() != null &amp;&amp; obx.getValueComparator() != null) {</span>
<span class="fc" id="L1388">                        String comparatorAsString = dataModelComparator.map(Object::toString).orElse(&quot;&quot;);</span>
<span class="fc" id="L1389">                        result.setTextValue(comparatorAsString + obx.getValueNumeric());</span>
<span class="fc" id="L1390">                    } else {</span>
<span class="fc" id="L1391">                        result.setTextValue(obx.getValueText().getString());</span>
                    }
                } else {
                    // Otherwise, check to see if the HL7Observation was able to parse valueNumeric from the provided value and if so set
                    // that numeric value into the result.
<span class="fc bfc" id="L1396" title="All 2 branches covered.">                    if (obx.getValueNumeric() != null) {</span>
<span class="fc" id="L1397">                        result.setValue(obx.getValueNumeric());</span>
<span class="fc" id="L1398">                        dataModelComparator.ifPresent(result::setValueComparator);</span>
                    } else {
                        // If that failed, then we were expecting a result that was allowed to be numeric (either NUMERIC or VARIES) but we
                        // could not parse the result as a number. So just treat the value as text.
<span class="fc" id="L1402">                        result.setTextValue(obx.getValueText().getString());</span>
                    }
                }

<span class="fc" id="L1406">                result.setTestDate(timestamp);</span>
<span class="fc" id="L1407">                result.setSpecimenReceivedTimestamp(orderGroup.getObrSpecimenReceivedTimestamp().getZonedDateTime());</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">                if (orderGroup.getObrLabDiscipline().isProvided()) {</span>
<span class="fc" id="L1409">                    result.setLabDiscipline(orderGroup.getObrLabDiscipline().getString());</span>
                }
<span class="fc" id="L1411">                result.setRangeLow(obx.getRangeLow());</span>
<span class="fc" id="L1412">                result.setRangeLowInclusive(obx.isRangeLowInclusive());</span>
<span class="fc" id="L1413">                result.setRangeHigh(obx.getRangeHigh());</span>
<span class="fc" id="L1414">                result.setRangeHighInclusive(obx.isRangeHighInclusive());</span>
<span class="fc" id="L1415">                result.setTextRange(obx.getTextRange().getString());</span>

                // add OBR comments (so they show up above result-specific comments; we can flip this sequence if customers prefer
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">                for (HL7String note : orderGroup.getObrNoteList()) {</span>
<span class="nc" id="L1419">                    result.addComment(note.getString());</span>
<span class="nc" id="L1420">                }</span>

<span class="fc bfc" id="L1422" title="All 2 branches covered.">                for (HL7String note : obx.getNoteList()) {</span>
<span class="fc" id="L1423">                    result.addComment(note.getString());</span>
<span class="fc" id="L1424">                }</span>

<span class="fc" id="L1426">                result.getBaseFields().setHospitalServiceCode(getHl7Text(root, &quot;PV1.10.1&quot;).getString());</span>
<span class="fc" id="L1427">                result.getBaseFields().setEnteredDate(Date.from(getMessageDate().getInstant()));</span>

<span class="fc bfc" id="L1429" title="All 2 branches covered.">                if (orderGroup.getEntererLocation().getLocationDescription().isNotBlank()) {</span>
<span class="fc" id="L1430">                    GeographicLocation geographicLocation = new GeographicLocation();</span>
<span class="fc" id="L1431">                    geographicLocation.setDescription(orderGroup.getEntererLocation().getLocationDescription().getString());</span>
<span class="fc" id="L1432">                    result.setEntererLocation(geographicLocation);</span>
                }

<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">                if (config.isDisplayOfSensitiveErrorInformationEnabled()) {</span>
<span class="fc" id="L1436">                    LOGGER.info(&quot;VALID result: {}&quot;, result.toString());</span>
                }
<span class="fc" id="L1438">                obx.setProcessed(true);</span>
<span class="fc" id="L1439">                resultList.add(result);</span>
<span class="fc" id="L1440">            } // end observation loop</span>

<span class="fc" id="L1442">        } // end ordergroup loop</span>

<span class="fc" id="L1444">        return resultList;</span>
    }

    private boolean isNewerLoincMappingInfo(Instant existingEnteredDate, Instant newEnteredDate) {
        // Safest to accept the data if we don't have enough information to reject it
<span class="pc bpc" id="L1449" title="2 of 4 branches missed.">        if (existingEnteredDate == null || newEnteredDate == null) {</span>
<span class="nc" id="L1450">            return true;</span>
        }
        // Equal timestamps will result in the data being accepted. This matches our policy for demographic updates.
<span class="fc bfc" id="L1453" title="All 2 branches covered.">        return !newEnteredDate.isBefore(existingEnteredDate);</span>
    }

    /*
     * Includes deletion requests (sets result.getBaseFields().setDeleted())
     */
    public List&lt;RadiologyResult&gt; parseRadiologyResults(HL7ConnContext hl7ConnContext) {
<span class="fc" id="L1460">        List&lt;HL7OrderGroup&gt; groups = parseOrderGroups(ObrValidationMode.ALLOW_MULTIPLE, hl7ConnContext, Destination.RADIOLOGY);</span>

        // PHR-7947: Multiple OBR groups are not supported for radiology reports
<span class="fc bfc" id="L1463" title="All 2 branches covered.">        if (groups.size() &gt; 1) {</span>
<span class="fc" id="L1464">            throw new ApiCallMalformedException(String.format(&quot;Radiology reports must contain exactly 1 OBR group. You provided [%d]&quot;, groups.size()));</span>
        }

<span class="fc" id="L1467">        Instant now = dateTimeService.now();</span>
<span class="fc" id="L1468">        List&lt;RadiologyResult&gt; resultList = new ArrayList&lt;&gt;(groups.size());</span>
<span class="fc" id="L1469">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        for (HL7OrderGroup orderGroup : groups) {</span>
<span class="fc" id="L1471">            var sourceDetails = new SourceDetails(requestContext);</span>
            // one radiology result per order group
<span class="fc" id="L1473">            RadiologyResult result = new RadiologyResult(sourceDetails);</span>
<span class="fc" id="L1474">            resultList.add(result); // put in list NOW so we don't need to fiddle with loops</span>

            // Record obr service code for assigning privacy labels later
<span class="fc" id="L1477">            result.setObrServiceCode(orderGroup.getObrServiceCode().getId().getString());</span>

<span class="fc" id="L1479">            Instant timestamp = orderGroup.getObrTimestamp().getInstant();</span>
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">            if (timestamp == null) {</span>
<span class="nc" id="L1481">                throw new ApiCallMalformedException(&quot;OBR[&quot; + orderGroup.getObrSetId().getString() + &quot;]: No observation timestamp in OBR&quot;);</span>
            }
<span class="fc" id="L1483">            result.setCreationTimestamp(timestamp);</span>

            // Set the title, or throw an error if one was not provided.
<span class="fc" id="L1486">            result.setTitle(getRadiologyReportName(orderGroup, hl7ConnContext));</span>

<span class="fc" id="L1488">            String labOrderId = orderGroup.getMostSignificantFON().getString();</span>
<span class="fc" id="L1489">            result.setLabOrderId(labOrderId);</span>

<span class="fc bfc" id="L1491" title="All 2 branches covered.">            if (orderGroup.getReqBy().isValid()) {</span>
<span class="fc" id="L1492">                sourceDetails.setText(orderGroup.getReqBy().makeDisplayText());</span>
            }

<span class="fc" id="L1495">            result.getBaseFields().setHospitalServiceCode(getHl7Text(root, &quot;PV1.10.1&quot;).getString());</span>

<span class="fc" id="L1497">            result.setCategory(MediaActCategory.IMAGING);</span>
<span class="fc" id="L1498">            result.setUploadTimestamp(now);</span>

<span class="fc bfc" id="L1500" title="All 2 branches covered.">            if (orderGroup.isDeletionStatus()) {</span>
                // If OBR.25.1 is 'R' this is a deletion
<span class="fc" id="L1502">                result.getBaseFields().setDeleted(orderGroup.isDeletionStatus());</span>
            } else {
                // process and validate content

                // add OBR comments (so they show up above result-specific comments; we can flip this sequence if customers prefer
<span class="pc bpc" id="L1507" title="1 of 2 branches missed.">                for (HL7String note : orderGroup.getObrNoteList()) {</span>
<span class="nc" id="L1508">                    result.addDescriptionLine(note.getString());</span>
<span class="nc" id="L1509">                }</span>

<span class="fc" id="L1511">                List&lt;HL7String&gt; delayList = new ArrayList&lt;&gt;();</span>
                loopObservations:
<span class="fc bfc" id="L1513" title="All 2 branches covered.">                for (HL7Observation obx : orderGroup.getObservationList()) {</span>
<span class="fc" id="L1514">                    String obxTrace = &quot;OBR[&quot; + orderGroup.getObrSetId().getString() + &quot;].OBX[&quot; + obx.getObxSetId().getString() + &quot;]&quot;;</span>

                    // Check for a test name
<span class="fc" id="L1517">                    String testName = obx.getTestCode().getText().getString();</span>
<span class="fc bfc" id="L1518" title="All 2 branches covered.">                    if (StringUtils.isBlank(testName)) {</span>
<span class="fc" id="L1519">                        testName = obx.getTestCode().getAltText().getString();</span>
<span class="fc" id="L1520">                        LOGGER.warn(&quot;HL7 Code Confusion: Reading alt text for parseRadiologyResults obxTestCode: ({}) in message {} from {}&quot;,</span>
<span class="fc" id="L1521">                                obx.getTestCode().getAltText().isBlank(), getMessageIdString(), hl7ConnContext);</span>
                    }

                    // for now: just whitelist the known text values -- FT and TX for text, ED for binary (full list in parseObrObxResults)
<span class="fc" id="L1525">                    String[] whitelistValueTypes = new String[]{&quot;FT&quot;, &quot;TX&quot;, &quot;ED&quot;};</span>
<span class="pc bpc" id="L1526" title="1 of 2 branches missed.">                    if (!ArrayUtils.contains(whitelistValueTypes, obx.getValueType().getString())) {</span>
                        // PHR-9458: See HL7OrderGroup.validateObx for the intended location of centralised OBX-2 enforcement.
<span class="nc" id="L1528">                        throw new ApiCallMalformedException(</span>
<span class="nc" id="L1529">                                obxTrace + &quot;: unhandled value type for radiology: &quot; + obx.getValueType().getString());</span>
                    }

<span class="fc bfc" id="L1532" title="All 2 branches covered.">                    if (&quot;ED&quot;.equals(obx.getValueType().getString())) {</span>
<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">                        if (obx.getEdValue() != null) {</span>
<span class="fc" id="L1534">                            String mediaType = StringUtils</span>
<span class="fc" id="L1535">                                    .lowerCase(obx.getEdDataType().getString() + &quot;/&quot; + obx.getEdSubDataType().getString());</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">                            if (mediaType.equals(&quot;text/html&quot;)) {</span>
                                // switch to HTML mode (if it wasn't already)
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">                                if (!result.isHtmlAllowed()) {</span>
<span class="nc" id="L1539">                                    result.setHtmlAllowed(true);</span>
                                }
<span class="fc" id="L1541">                                result.addDescriptionLine(new String(obx.getEdValue(), StandardCharsets.UTF_8));</span>
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">                            } else if (isSupportedBinaryTypeForRadiology(mediaType)) {</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">                                if (mediaType.startsWith(&quot;im/&quot;)) {</span>
<span class="fc" id="L1544">                                    mediaType = &quot;image/&quot; + StringUtils.lowerCase(obx.getEdSubDataType().getString());</span>
                                }
<span class="fc" id="L1546">                                Attachment attachment = new Attachment();</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">                                if (StringUtils.isBlank(testName)) {</span>
<span class="fc" id="L1548">                                    attachment.setFilename(&quot;radiology&quot; + dateTimeService.now().toEpochMilli() + &quot;.&quot; + StringUtils.lowerCase(obx.getEdSubDataType().getString()));</span>
                                } else {
<span class="fc" id="L1550">                                    attachment.setFilename(testName);</span>
                                }
<span class="fc" id="L1552">                                String fixedMediaType = fileSecurityHandler.runChecks(attachment.getFilename(), obx.getEdValue(), mediaType)</span>
<span class="fc" id="L1553">                                        .getOrElseThrow(ApiCallMalformedException::new);</span>
<span class="fc bfc" id="L1554" title="All 2 branches covered.">                                if (!mediaType.equals(fixedMediaType)) {</span>
<span class="fc" id="L1555">                                    LOGGER.warn(&quot;Media type changed from {} to {} in radiology message {} from {}&quot;, mediaType, fixedMediaType, getMessageIdString(), hl7ConnContext);</span>
                                }

<span class="fc" id="L1558">                                attachment.setMediaType(fixedMediaType);</span>
<span class="fc" id="L1559">                                attachment.setContent(obx.getEdValue());</span>
<span class="fc" id="L1560">                                attachment.setUploadTime(Date.from(dateTimeService.now()));</span>
<span class="fc" id="L1561">                                result.addAttachment(attachment);</span>
<span class="fc" id="L1562">                            } else {</span>
<span class="nc" id="L1563">                                throw new ApiCallMalformedException(&quot;ED media type not yet supported: &quot; + mediaType);</span>
                            }
<span class="fc" id="L1565">                        }</span>
                    } else {
<span class="fc" id="L1567">                        result.addDescriptionLine(obx.getValueText().getString());</span>
                    }

                    // Record any sender-specified delay to be set after iterating through the OBX list
<span class="fc" id="L1571">                    delayList.add(obx.getAccessChecks());</span>

<span class="fc bfc" id="L1573" title="All 2 branches covered.">                    for (HL7String note : obx.getNoteList()) {</span>
<span class="fc" id="L1574">                        result.addDescriptionLine(note.getString());</span>
<span class="fc" id="L1575">                    }</span>
<span class="fc" id="L1576">                } // end of observations loop</span>

                // PHR-7961: A delay can only be set in the first OBX segment. Some customers might set the same value
                // in every OBX segment. This is not an error, but we only check the first one.
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">                if (!delayList.isEmpty()) {</span>
<span class="fc" id="L1581">                    String obxTrace = &quot;OBR[&quot; + orderGroup.getObrSetId().getString() + &quot;].OBX[1]&quot;;</span>
<span class="fc" id="L1582">                    HL7Util.getPatientDelayDays(delayList.get(0).getString(), obxTrace).ifPresent(result::setDelayDisplayDays);</span>
                }

<span class="fc bfc" id="L1585" title="All 2 branches covered.">                if (orderGroup.getEntererLocation().getLocationDescription().isNotBlank()) {</span>
<span class="fc" id="L1586">                    GeographicLocation geographicLocation = new GeographicLocation();</span>
<span class="fc" id="L1587">                    geographicLocation.setDescription(orderGroup.getEntererLocation().getLocationDescription().getString());</span>
<span class="fc" id="L1588">                    result.setEntererLocation(geographicLocation);</span>
                }
            }

<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">            if (config.isDisplayOfSensitiveErrorInformationEnabled()) {</span>
<span class="fc" id="L1593">                LOGGER.info(&quot;VALID radiology result: {}&quot;, result.toString());</span>
            }
<span class="fc" id="L1595">        } // end of order group loop</span>

<span class="fc" id="L1597">        return resultList;</span>
    }

    @VisibleForTesting
    static boolean isSupportedBinaryTypeForRadiology(String mediaType) {
<span class="pc bpc" id="L1602" title="1 of 4 branches missed.">        return mediaType.startsWith(&quot;im/&quot;) || &quot;application/pdf&quot;.equals(mediaType);</span>
    }

    /**
     * Return the primary OBR service name (OBR-4.2) or else the alternative (OBR-4.5) if the primary name was blank.
     * &lt;p&gt;
     * An error is thrown if neither were provided.
     *
     * @param orderGroup     The OBR order group
     * @param hl7ConnContext The HL7 Connection Context
     * @return The primary or else alternative radiology report name
     */
    private String getRadiologyReportName(HL7OrderGroup orderGroup, HL7ConnContext hl7ConnContext) {
<span class="fc" id="L1615">        HL7ValueExpectation expectation_OBR_NAME = HL7ValueExpectation.builder()</span>
<span class="fc" id="L1616">                .withId(&quot;OBR-4.2&quot;)</span>
<span class="fc" id="L1617">                .withName(&quot;service name&quot;)</span>
<span class="fc" id="L1618">                .withProvidedHL7Value(orderGroup.getObrServiceCode().getText())</span>
<span class="fc" id="L1619">                .build();</span>
<span class="fc" id="L1620">        HL7ValueExpectation expectation_OBR_ALT_NAME = HL7ValueExpectation.builder()</span>
<span class="fc" id="L1621">                .withId(&quot;OBR-4.5&quot;)</span>
<span class="fc" id="L1622">                .withName(&quot;alternative service name&quot;)</span>
<span class="fc" id="L1623">                .withProvidedHL7Value(orderGroup.getObrServiceCode().getAltText())</span>
<span class="fc" id="L1624">                .build();</span>
<span class="fc" id="L1625">        List&lt;HL7ValueExpectation&gt; expectations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1626">        expectations.add(expectation_OBR_NAME);</span>
<span class="fc" id="L1627">        expectations.add(expectation_OBR_ALT_NAME);</span>
<span class="fc" id="L1628">        enforceMandatoryValueAtLeastOne(expectations);</span>

<span class="fc" id="L1630">        String serviceName = orderGroup.getObrServiceCode().getText().getString();</span>
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">        if (StringUtils.isBlank(serviceName)) {</span>
<span class="nc" id="L1632">            serviceName = orderGroup.getObrServiceCode().getAltText().getString();</span>
<span class="nc" id="L1633">            LOGGER.warn(&quot;HL7 Code Confusion: Reading alt text for parseRadiologyResults obrServiceCode: ({}) in message {} from {}&quot;,</span>
<span class="nc" id="L1634">                    orderGroup.getObrServiceCode().getAltText().isBlank(), getMessageIdString(), hl7ConnContext);</span>
        }

<span class="fc" id="L1637">        return serviceName;</span>
    }

    public List&lt;MeasurementDTO&gt; parseMeasurements(HL7ConnContext hl7ConnContext, ReferenceDataManager referenceDataManager) {
<span class="fc" id="L1641">        List&lt;HL7OrderGroup&gt; orderGroups = parseOrderGroups(ObrValidationMode.ALLOW_MULTIPLE, hl7ConnContext, Destination.MEASUREMENT);</span>

<span class="fc" id="L1643">        List&lt;MeasurementDTO&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1644">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>

<span class="fc bfc" id="L1646" title="All 2 branches covered.">        List&lt;HL7OrderGroup&gt; groupsNotProcessed = orderGroups.stream().filter(g -&gt; !g.isProcessed()).collect(Collectors.toList());</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">        for (HL7OrderGroup orderGroup : groupsNotProcessed) {</span>
<span class="fc" id="L1648">            String reqBySource = null;</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">            if (orderGroup.getReqBy().isValid()) {</span>
<span class="fc" id="L1650">                reqBySource = orderGroup.getReqBy().makeDisplayText();</span>
            }

<span class="fc" id="L1653">            HL7String fillerOrderNumber = orderGroup.getMostSignificantFON();</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">            if (fillerOrderNumber.isBlank()) {</span>
                // PHR-7794: Before mandating this, log who is not sending it
<span class="fc" id="L1656">                LOGGER.error(&quot;PHR-7794: FON missing for measurements. Message {} from {}&quot;, getMessageIdString(), hl7ConnContext);</span>
            }

            loopObservations:
<span class="fc bfc" id="L1660" title="All 2 branches covered.">            for (HL7Observation obx : orderGroup.getObservationList()) {</span>
<span class="pc bpc" id="L1661" title="1 of 2 branches missed.">                if (obx.isProcessed()) {</span>
<span class="nc" id="L1662">                    continue loopObservations;</span>
                }

<span class="fc" id="L1665">                String testSystem = obx.getTestCode().getCodingSystem().getString().toLowerCase();</span>
<span class="fc" id="L1666">                String testId = obx.getTestCode().getId().getString();</span>
<span class="fc" id="L1667">                String unitTextElseId = obx.getUnitCode().getText().getString();</span>

<span class="fc bfc" id="L1669" title="All 2 branches covered.">                if (obx.getUnitCode().getText().isBlank()) {</span>
<span class="fc" id="L1670">                    unitTextElseId = obx.getUnitCode().getId().getString();</span>
                }

                // Measurements must be send coded as SNOMED -- if not, move along
<span class="fc bfc" id="L1674" title="All 2 branches covered.">                if (!(testSystem.equals(&quot;sct&quot;) ||</span>
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">                        testSystem.equals(&quot;snomed-ct&quot;) ||</span>
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">                        testSystem.equals(&quot;snomed ct&quot;) ||</span>
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">                        testSystem.equals(&quot;snomedct&quot;) ||</span>
<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">                        testSystem.equals(&quot;http://snomed.info/sct&quot;) ||</span>
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">                        testSystem.equals(&quot;2.16.840.1.113883.6.96&quot;))) {</span>
<span class="fc" id="L1680">                    continue loopObservations;</span>
                }

<span class="fc" id="L1683">                String obxTrace = &quot;OBR[&quot; + orderGroup.getObrSetId().getString() + &quot;].OBX[&quot; + obx.getObxSetId().getString() + &quot;]&quot;;</span>

                // special handling for multivalue measurements: need to generalize this!
                //        		Systolic BP reading (finding): 163030003
                //        		Diastolic BP reading (finding): 163031004
                //        		unit1/unit2: &quot;mmHg (systolic)&quot;, &quot;mmHg (diastolic)&quot;

                // if it's a multiple OBX measurement, check if this is a Snomed code for value1 or value2 of the previous measurement

<span class="fc" id="L1692">                Option&lt;MeasurementDTO&gt; prevMultiValueDtoMaybe = None();</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">                if (!resultList.isEmpty()) {</span>
<span class="fc" id="L1694">                    MeasurementDTO prevDto = resultList.get(resultList.size() - 1);</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">                    if (prevDto.getMeasurementType().isMultiValueMeasurement()) {</span>
<span class="fc" id="L1696">                        prevMultiValueDtoMaybe = Some(prevDto);</span>
                    }
                }

<span class="fc" id="L1700">                Option&lt;PredefinedMeasurementType&gt; parentTypeMaybe = Option.of(snomedToMeasMap.get(testId));</span>
<span class="fc" id="L1701">                Option&lt;PredefinedMeasurementType&gt; parentMultiTypeMaybe = Option.of(snomedToMultiValMeasMap.get(testId));</span>
<span class="fc" id="L1702">                int multiTypeValue1or2 = -1; // 1 or 2</span>

<span class="pc bpc" id="L1704" title="1 of 6 branches missed.">                if (parentTypeMaybe.isEmpty() &amp;&amp; parentMultiTypeMaybe.isEmpty() &amp;&amp; prevMultiValueDtoMaybe.isEmpty()) {</span>
<span class="nc" id="L1705">                    continue loopObservations; // not a measurement (or part of one)</span>
                }

                // we have a match!  enforce unit match and reject message (as malformed) if no match.
<span class="fc" id="L1709">                Option&lt;PredefinedMeasurementType&gt; matchType = None();</span>
                // track supported units, for throwing error back
<span class="fc" id="L1711">                List&lt;String&gt; supportedUnitList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1713" title="All 2 branches covered.">                if (parentTypeMaybe.isDefined()) {</span>
<span class="fc" id="L1714">                    var parentType = parentTypeMaybe.get();</span>
<span class="pc bpc" id="L1715" title="1 of 2 branches missed.">                    if (parentType.unit().equalsIgnoreCase(unitTextElseId)) {</span>
<span class="fc" id="L1716">                        matchType = Some(parentType);</span>
                    } else {
<span class="nc" id="L1718">                        supportedUnitList.add(parentType.unit());</span>

                        // check if a child type matches
<span class="nc bnc" id="L1721" title="All 2 branches missed.">                        for (var childType : parentType.getChildTypes()) {</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">                            if (childType.getType().unit().equalsIgnoreCase(unitTextElseId)) {</span>
<span class="nc" id="L1723">                                matchType = Some(childType);</span>
<span class="nc" id="L1724">                                break;</span>
                            }
<span class="nc" id="L1726">                            supportedUnitList.add(childType.unit());</span>
<span class="nc" id="L1727">                        }</span>
                    }

<span class="pc bpc" id="L1730" title="1 of 2 branches missed.">                    if (matchType == null) {</span>
<span class="nc" id="L1731">                        throw new ApiCallMalformedException(obxTrace + &quot;: no unit match on SCT measurement. Received unit: &quot; + unitTextElseId +</span>
<span class="nc" id="L1732">                                &quot; for measurement type &quot; + parentType.apiRef() +</span>
<span class="nc" id="L1733">                                &quot;; supported units: &quot; + ArrayUtils.toString(supportedUnitList));</span>
                    }
<span class="fc bfc" id="L1735" title="All 2 branches covered.">                } else if (parentMultiTypeMaybe.isDefined()) {</span>
<span class="fc" id="L1736">                    matchType = parentMultiTypeMaybe;</span>
                    // don't check unit -- values / units coming in next OBXes
                } else {
                    // one of the value OBXes of a multiple value measurement

<span class="fc" id="L1741">                    parentMultiTypeMaybe = prevMultiValueDtoMaybe.map(MeasurementDTO::getMeasurementType)</span>
<span class="fc" id="L1742">                            .map(MeasurementType::id)</span>
<span class="fc" id="L1743">                            .flatMap(MeasurementTypeId::asInternalId)</span>
<span class="fc" id="L1744">                            .flatMap(id -&gt; Option.of(PredefinedMeasurementType.getById(id)));</span>

<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">                    if (parentMultiTypeMaybe.isDefined()) {</span>
<span class="fc" id="L1747">                        var parentMultiType = parentMultiTypeMaybe.get();</span>
<span class="fc bfc" id="L1748" title="All 2 branches covered.">                        if (parentMultiType.code().map(parentCode -&gt; parentCode.equals(testId)).getOrElse(false)) {</span>
                            // match unit 1 or error
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">                            if (parentMultiType.unit().equalsIgnoreCase(unitTextElseId)) {</span>
<span class="fc" id="L1751">                                matchType = Some(parentMultiType);</span>
<span class="fc" id="L1752">                                multiTypeValue1or2 = 1;</span>
                            } else {
<span class="nc" id="L1754">                                throw new ApiCallMalformedException(obxTrace + &quot;: no unit match on SCT measurement. Received unit: &quot; + unitTextElseId +</span>
<span class="nc" id="L1755">                                        &quot; for measurement type &quot; + parentMultiType.apiRef() +</span>
<span class="nc" id="L1756">                                        &quot;; value 1. Supported unit: &quot; + parentMultiType.unit());</span>
                            }
<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">                        } else if (parentMultiType.getType().code2().map(c2 -&gt; c2.equals(testId)).getOrElse(false)) {</span>
                            // match unit 2 or error
<span class="fc" id="L1760">                            String finalUnitTextElseId = unitTextElseId;</span>
<span class="pc bpc" id="L1761" title="5 of 6 branches missed.">                            if (parentMultiType.unit2().map(u2 -&gt; u2.equalsIgnoreCase(finalUnitTextElseId)).getOrElse(false) || (parentMultiType.unit2().isEmpty() &amp;&amp; unitTextElseId == null)) {</span>
<span class="fc" id="L1762">                                matchType = Some(parentMultiType);</span>
<span class="fc" id="L1763">                                multiTypeValue1or2 = 2;</span>
                            } else {
<span class="nc" id="L1765">                                throw new ApiCallMalformedException(obxTrace + &quot;: no unit match on SCT measurement. Received unit: &quot; + unitTextElseId +</span>
<span class="nc" id="L1766">                                        &quot; for measurement type &quot; + parentMultiType.apiRef() +</span>
<span class="nc" id="L1767">                                        &quot;; value 2. Supported unit: &quot; + parentMultiType.unit2());</span>
                            }
<span class="fc" id="L1769">                        } else {</span>
<span class="nc" id="L1770">                            throw new ApiCallMalformedException(</span>
<span class="nc" id="L1771">                                    obxTrace + &quot;: Expected coded value for parent measurement &quot; + parentMultiType.apiRef() +</span>
<span class="nc" id="L1772">                                            &quot;; value 1 SNOMED &quot; + parentMultiType.code() + &quot; or value 2 SNOMED &quot; + parentMultiType.getType().code2()</span>
                                            +
                                            &quot;. Found: &quot; + testId);
                        }
<span class="fc" id="L1776">                    } else {</span>
<span class="nc" id="L1777">                        throw new ApiCallMalformedException(</span>
                                obxTrace + &quot;: Expected coded value for parent measurement, none found. &quot;
                                        + &quot;. Found: &quot; + testId);
                    }
                }

                // matched measurement type: build DTO

<span class="fc" id="L1785">                MeasurementDTO dto = null;</span>

<span class="fc bfc" id="L1787" title="All 2 branches covered.">                if (multiTypeValue1or2 &gt; 0) {</span>
<span class="fc" id="L1788">                    dto = prevMultiValueDtoMaybe.get();</span>
<span class="fc bfc" id="L1789" title="All 2 branches covered.">                    if (multiTypeValue1or2 == 1) {</span>
<span class="fc" id="L1790">                        dto.setValue(obx.getValueNumeric());</span>
<span class="pc bpc" id="L1791" title="1 of 2 branches missed.">                    } else if (multiTypeValue1or2 == 2) {</span>
<span class="fc" id="L1792">                        dto.setValue2(obx.getValueNumeric());</span>
                    }
                } else {
<span class="fc" id="L1795">                    var sourceDetails = new SourceDetails(requestContext);</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">                    if (reqBySource != null) {</span>
<span class="fc" id="L1797">                        sourceDetails.setText(reqBySource);</span>
                    }
                    // either regular measurement, or the first (no-value) record in a multi-value one
<span class="fc" id="L1800">                    dto = new MeasurementDTO(sourceDetails);</span>
<span class="fc" id="L1801">                    dto.setMeasurementType(matchType.get());</span>

<span class="fc bfc" id="L1803" title="All 2 branches covered.">                    if (matchType != parentMultiTypeMaybe) {</span>
<span class="fc" id="L1804">                        dto.setValue(obx.getValueNumeric());</span>
                    }

<span class="fc bfc" id="L1807" title="All 2 branches covered.">                    if (obx.getTimestamp().getInstant() != null) {</span>
<span class="fc" id="L1808">                        dto.setMeasureDate(obx.getTimestamp().getInstant());</span>
                    } else {
<span class="fc bfc" id="L1810" title="All 2 branches covered.">                        if (orderGroup.getObrTimestamp().getInstant() != null) {</span>
<span class="fc" id="L1811">                            dto.setMeasureDate(orderGroup.getObrTimestamp().getInstant());</span>
                        }
                    }

<span class="fc" id="L1815">                    dto.getBaseFields().setHospitalServiceCode(getHl7Text(root, &quot;PV1.10.1&quot;).getString());</span>
<span class="fc" id="L1816">                    dto.getBaseFields().setEnteredDate(Date.from(getMessageDate().getInstant()));</span>
<span class="fc" id="L1817">                    dto.setLabOrderId(fillerOrderNumber.getString());</span>

                    // Apply privacy labels
<span class="fc" id="L1820">                    referenceDataManager.applyPrivacyLabels(dto, orderGroup.getObrServiceCode().getId().getString());</span>

<span class="fc" id="L1822">                    resultList.add(dto);</span>
                }
                // Mark as processed so it doesn't get stored as a lab result
<span class="fc" id="L1825">                obx.setProcessed(true);</span>
<span class="fc" id="L1826">            } // end loop observations</span>

            // Since multi-valued measurements are spread over more than one OBX segment, some validation cannot be
            // performed when parsing individual OBX segments and must be done here instead.
<span class="fc bfc" id="L1830" title="All 2 branches covered.">            for (MeasurementDTO dto : resultList) {</span>
<span class="pc bpc" id="L1831" title="1 of 4 branches missed.">                if (dto.getMeasurementType().isMultiValueMeasurement() &amp;&amp; !dto.isValidMultiValueMeasurement()) {</span>
<span class="nc" id="L1832">                    throw new ApiCallMalformedException(&quot;in group OBR[&quot; + orderGroup.getObrSetId().getString()</span>
                            + &quot;]: multi-value reading missing one or both values.&quot;);
                }
                // Measurements must have a timestamp
<span class="fc bfc" id="L1836" title="All 2 branches covered.">                if (dto.getMeasureDate() == null) {</span>
<span class="fc" id="L1837">                    throw new ApiCallMalformedException(&quot;Measurements must include a timestamp in either OBX-14 or OBR-7&quot;);</span>
                }
                // Measurements must have a value
<span class="fc bfc" id="L1840" title="All 2 branches covered.">                if (!dto.hasValue()) {</span>
<span class="fc" id="L1841">                    throw new ApiCallMalformedException(&quot;Measurements must include a value in OBX-5&quot;);</span>
                }
<span class="fc" id="L1843">            }</span>
<span class="fc" id="L1844">        } // end loop order groups</span>

<span class="fc" id="L1846">        return resultList;</span>
    }

    //============ PV1 SEGMENT

    public Optional&lt;HL7PatientVisit1&gt; getPV1() {
<span class="fc" id="L1852">        parsedSegmentCache.computeIfAbsent(HL7PatientVisit1.class, k -&gt; Arrays.asList(parseHL7PatientVisit1()));</span>
<span class="fc" id="L1853">        return (Optional&lt;HL7PatientVisit1&gt;) parsedSegmentCache.get(HL7PatientVisit1.class).get(0);</span>
    }

    public Optional&lt;HL7PatientVisit1&gt; parseHL7PatientVisit1() {
<span class="fc" id="L1857">        HL7PatientVisit1 pv1 = null;</span>
<span class="fc" id="L1858">        NodeList nodeList = root.getElementsByTagName(&quot;PV1&quot;);</span>

<span class="pc bpc" id="L1860" title="1 of 4 branches missed.">        if ((nodeList != null) &amp;&amp; (nodeList.getLength() &gt; 0)) {</span>
<span class="fc" id="L1861">            Element pv1Node = (Element) nodeList.item(0);</span>
<span class="fc" id="L1862">            pv1 = new HL7PatientVisit1(messageProperties, pv1Node);</span>
        }

<span class="fc" id="L1865">        return Optional.ofNullable(pv1);</span>
    }

    //============ PV2 SEGMENT

    public HL7PatientVisit2 getHL7PatientVisit2() {
<span class="fc" id="L1871">        parsedSegmentCache.putIfAbsent(HL7PatientVisit2.class, Arrays.asList(parseHL7PatientVisit2()));</span>
<span class="fc" id="L1872">        return (HL7PatientVisit2) parsedSegmentCache.get(HL7PatientVisit2.class).get(0);</span>
    }

    public HL7PatientVisit2 getPV2() {
<span class="fc" id="L1876">        return getHL7PatientVisit2();</span>
    }

    public HL7PatientVisit2 parseHL7PatientVisit2() {
<span class="fc" id="L1880">        HL7PatientVisit2 pv2 = null;</span>
<span class="fc" id="L1881">        NodeList nodeList = root.getElementsByTagName(&quot;PV2&quot;);</span>

<span class="pc bpc" id="L1883" title="2 of 4 branches missed.">        if ((nodeList != null) &amp;&amp; (nodeList.getLength() &gt; 0)) {</span>
<span class="nc" id="L1884">            Element pv2Node = (Element) nodeList.item(0);</span>
<span class="nc" id="L1885">            pv2 = new HL7PatientVisit2(messageProperties, pv2Node);</span>
        }

<span class="fc" id="L1888">        return pv2;</span>
    }

    //============ EVN SEGMENT

    public HL7EventType getHL7EventType() {
<span class="fc" id="L1894">        parsedSegmentCache.putIfAbsent(HL7EventType.class, Arrays.asList(parseHL7EventType()));</span>
<span class="fc" id="L1895">        return (HL7EventType) parsedSegmentCache.get(HL7EventType.class).get(0);</span>
    }

    public HL7EventType getEVN() {
<span class="fc" id="L1899">        return getHL7EventType();</span>
    }

    public HL7EventType parseHL7EventType() {
        // EVN Node (1 per HL7 Message)
<span class="fc" id="L1904">        HL7EventType hl7EventType = null;</span>
<span class="fc" id="L1905">        NodeList nodeList = root.getElementsByTagName(&quot;EVN&quot;);</span>

<span class="pc bpc" id="L1907" title="1 of 4 branches missed.">        if ((nodeList != null) &amp;&amp; (nodeList.getLength() &gt; 0)) {</span>
<span class="fc" id="L1908">            Element evn = (Element) nodeList.item(0);</span>
<span class="fc" id="L1909">            hl7EventType = new HL7EventType(messageProperties, evn);</span>
        }
<span class="fc" id="L1911">        return hl7EventType;</span>
    }

    //============ ZAP SEGMENT

    public Optional&lt;HL7DatapointExternalIntegrationUrl&gt; parseHL7DatapointExternalIntegrationUrl() {

<span class="fc" id="L1918">        NodeList nodeList = root.getElementsByTagName(&quot;ZAP&quot;);</span>

<span class="pc bpc" id="L1920" title="1 of 4 branches missed.">        if ((nodeList != null) &amp;&amp; (nodeList.getLength() &gt; 0)) {</span>
<span class="fc" id="L1921">            HL7DatapointExternalIntegrationUrl dto = new HL7DatapointExternalIntegrationUrl();</span>
<span class="fc" id="L1922">            dto.parseZap((Element) nodeList.item(0));</span>
<span class="fc" id="L1923">            return Optional.of(dto);</span>
        }
<span class="fc" id="L1925">        return Optional.empty();</span>
    }

    //===================== ZSC SEGMENT

    /**
     * A ZSC segment allows for customised fields not specified by the Standard.
     * Initially we are using it only to provide Appointment Type Codes in ZSC.8.1,
     * attached to A05/14 messages by Plymouth. See PHR-2043
     */

    public HL7Code getCustomAppointmentTypeCode() {
<span class="fc" id="L1937">        HL7CustomAppointment customAppointment = new HL7CustomAppointment();</span>
<span class="fc" id="L1938">        customAppointment.parse(root);</span>
<span class="fc" id="L1939">        return customAppointment.getCustomAppointmentTypeCode();</span>
    }

    //============ ZTM SEGMENT

    /**
     * A ZTM segment can be used to specify extra teams that a newly created
     * patient should be added to. The ZTM segment is optional. If present,
     * there must only be 1. It must contain only one field, which can
     * contain repeating values. E.g.
     * &lt;p&gt;
     * ZTM|first_key~second_key~third_key
     * &lt;p&gt;
     * The same whitelist used for sending facility mappings is used. As such,
     * a connecting entity can only grant access to a team they're already
     * allowed to connect as.
     *
     * @return A {@code List} of {@code String}s supplied in the ZTM segment.
     * @throws ApiCallMalformedException If the segment does not conform to the
     *                                   required format.
     */
    public List&lt;String&gt; parseZtm() throws ApiCallMalformedException {
<span class="fc" id="L1961">        List&lt;String&gt; requestedTeams = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1963">        NodeList ztmSegments = root.getElementsByTagName(&quot;ZTM&quot;);</span>
<span class="pc bpc" id="L1964" title="1 of 2 branches missed.">        if (ztmSegments != null) {</span>
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">            if (ztmSegments.getLength() &gt; 1) {</span>
<span class="nc" id="L1966">                throw new ApiCallMalformedException(&quot;A maximum of 1 ZTM segment is allowed&quot;);</span>
            }

<span class="fc" id="L1969">            Node ztmSegment = ztmSegments.item(0);</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">            if (ztmSegment != null) {</span>
<span class="fc" id="L1971">                NodeList fields = ztmSegment.getChildNodes();</span>
<span class="fc bfc" id="L1972" title="All 2 branches covered.">                for (int i = 0; i &lt; fields.getLength(); i++) {</span>
<span class="fc" id="L1973">                    Node field = fields.item(i);</span>
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">                    if (field.getNodeName().equals(&quot;ZTM.1&quot;)) {</span>
<span class="pc bpc" id="L1975" title="1 of 2 branches missed.">                        if (field.getChildNodes().getLength() != 1) {</span>
<span class="nc" id="L1976">                            throw new ApiCallMalformedException(&quot;Invalid ZTM segment&quot;);</span>
                        }
                        // TODO: There might be a subtle inconsistency here, where...
                        // ZTM|a&amp;b
                        // ...is treated like...
                        // ZTM|ab
                        // The teamname lookup will catch this anyway, but would be nice to catch here.
<span class="fc" id="L1983">                        String teamKey = field.getTextContent();</span>
<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">                        if (StringUtils.isNotBlank(teamKey)) {</span>
<span class="fc" id="L1985">                            requestedTeams.add(teamKey);</span>
                        }
<span class="fc" id="L1987">                    } else {</span>
<span class="nc" id="L1988">                        throw new ApiCallMalformedException(&quot;Invalid ZTM segment&quot;);</span>
                    }
                }
            }
        }

<span class="fc" id="L1994">        return requestedTeams;</span>
    }

    // ============== MDM MESSAGE HANDLING

    /**
     * TXA-2 Transcribed document type -- e.g., CL for clinic letter, DS for Discharge summary, CP for Care plan
     *
     * @return the code, or null if there's no TXA record (or no value for this field)
     */
    public HL7String getMdmDocumentType() {
<span class="fc" id="L2005">        return getHl7Text(root, &quot;TXA.2.1&quot;);</span>
    }

    public HL7String getMdmDocumentId() {
<span class="fc" id="L2009">        return getHl7Text(root, &quot;TXA.12.1&quot;);</span>
    }

    public HL7String getMdmDocumentStatus() {
<span class="nc" id="L2013">        return getHl7Text(root, &quot;TXA.17.1&quot;);</span>
    }

    public HL7String getPatientClass() {
<span class="fc" id="L2017">        return getHl7Text(root, &quot;PV1.2.1&quot;);</span>
    }

<span class="fc" id="L2020">    private final static HL7ObservationParser OBSERVATION_PARSER = new HL7ObservationParser();</span>

    public PHPlan parseMdmCarePlan(HL7ConnContext hl7ConnContext) {

<span class="fc" id="L2024">        expectSingleSegment(&quot;TXA&quot;);</span>

        // Enforce mandatory document ID
<span class="fc" id="L2027">        HL7String documentId = getMdmDocumentId();</span>
<span class="fc" id="L2028">        HL7ValueExpectation expectationTXA_12 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2029">                .withId(&quot;TXA-12.1&quot;)</span>
<span class="fc" id="L2030">                .withName(&quot;document ID&quot;)</span>
<span class="fc" id="L2031">                .withProvidedHL7Value(documentId)</span>
<span class="fc" id="L2032">                .build();</span>
<span class="fc" id="L2033">        enforceMandatoryValue(expectationTXA_12, false/*absentAllowed*/);</span>

        // Enforce mandatory document status, and validate equal to &quot;AU&quot;
<span class="fc" id="L2036">        HL7String completionStatus = getHl7Text(root, &quot;TXA.17.1&quot;);</span>
<span class="fc" id="L2037">        HL7ValueExpectation expectationTXA_17 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2038">                .withId(&quot;TXA-17.1&quot;)</span>
<span class="fc" id="L2039">                .withName(&quot;completion status&quot;)</span>
<span class="fc" id="L2040">                .withProvidedHL7Value(completionStatus)</span>
<span class="fc" id="L2041">                .build();</span>
<span class="fc" id="L2042">        enforceMandatoryValue(expectationTXA_17, false/*absentAllowed*/);</span>
<span class="fc" id="L2043">        enforcePermittedValue(expectationTXA_17, ImmutableSet.of(DOC_COMPLETION_STATUS_AU));</span>

        //    	MSH|^~\&amp;|SendingApp|SendingFacility|PKBAPI|PKB|20140529180000||MDM^T02|ID20140529180000-E85|P|2.3
        //    	EVN|T02
        //    	PID|1||1112388^BS||ESPARZA^MARIA
        //    	PV1|1|O|
        //    	TXA|1|CP|AP|ActivityDateTime|ProviderID^LastName^GivenName^^^Title|||||||UniqueDocNumber|||||AU
        //    	OBX|1|ED|CP^Care plan^L||^TEXT^HTML^Base64^BERi0xLjMKJeTjz9IKNSI (more bytes...)||||||F

<span class="fc" id="L2052">        HL7Date activityTimestamp = HL7XmlDoc.parseDateOrTimestamp(HL7XmlDoc.getHl7Text(root, &quot;TXA.4.1&quot;), &quot;TXA.4.1&quot;,</span>
                messageProperties);
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">        if (activityTimestamp.getInstant() == null) {</span>
<span class="nc" id="L2055">            throw new ApiCallMalformedException(&quot;TXA.4.1: No activity timestamp&quot;);</span>
        }

<span class="fc" id="L2058">        HL7PersonRef reqBy = new HL7PersonRef();</span>
<span class="fc" id="L2059">        reqBy.parseXcn(root, &quot;TXA&quot;, 5);</span>

<span class="fc" id="L2061">        var requestContext = hl7ConnContext.getEHRRequestContext();</span>
<span class="fc" id="L2062">        var sourceDetails = new SourceDetails(requestContext);</span>

<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">        if (reqBy.isValid()) {</span>
<span class="nc" id="L2065">            sourceDetails.setText(reqBy.makeDisplayText());</span>
        }

        // expecting ONE obx with HTML in it, for now. Don't make more flexible until needed.
        // OBX|1|ED|CP^Care plan^L||^TEXT^HTML^Base64^BERi0xLjMKJeTjz9IKNSI (more bytes...)||||||F
<span class="fc" id="L2070">        NodeList obxNodes = expectSingleSegment(&quot;OBX&quot;);</span>
<span class="fc" id="L2071">        Element obxNode = (Element) obxNodes.item(0);</span>
<span class="fc" id="L2072">        HL7Observation obx = new HL7Observation(messageProperties);</span>
<span class="fc" id="L2073">        OBSERVATION_PARSER.populate(obx, obxNode, &quot;&quot;/*no obr trace*/);</span>

<span class="fc" id="L2075">        PHPlan result = new PHPlan(sourceDetails);</span>
<span class="fc" id="L2076">        result.setEditableStatus(EditableStatus.ALL);</span>
<span class="fc" id="L2077">        result.setActiveVersionCount(1);</span>
<span class="fc" id="L2078">        result.setApprovalStatus(ApprovalStatus.APPROVED);</span>
<span class="fc" id="L2079">        result.setCreationDate(Optional.ofNullable(activityTimestamp.getInstant()).map(Date::from).orElse(null));</span>
<span class="fc" id="L2080">        result.setLastEditedOn(Optional.ofNullable(activityTimestamp.getInstant()).map(Date::from).orElse(null));</span>
<span class="fc" id="L2081">        result.setName(obx.getTestCode().getText().getString());</span>
<span class="fc bfc" id="L2082" title="All 2 branches covered.">        if (StringUtils.isBlank(result.getName())) {</span>
<span class="fc" id="L2083">            result.setName(obx.getTestCode().getAltText().getString());</span>
<span class="fc" id="L2084">            LOGGER.warn(&quot;HL7 Code Confusion: Reading alt text for parseMdmCarePlan obxTestCode: ({}) in message {} from {}&quot;,</span>
<span class="fc" id="L2085">                    obx.getTestCode().getAltText().isBlank(), getMessageIdString(), hl7ConnContext);</span>
        }
<span class="fc bfc" id="L2087" title="All 2 branches covered.">        if (StringUtils.isBlank(result.getName())) {</span>
<span class="fc" id="L2088">            result.setName(&quot;(unnamed)&quot;);</span>
        }
<span class="fc" id="L2090">        result.setStatus(PlanStatus.ACTIVE);</span>
<span class="fc" id="L2091">        result.setTemplateId(null);</span>
<span class="fc" id="L2092">        result.getBaseFields().generateNewRandomUniqueId();</span>
<span class="fc" id="L2093">        result.getBaseFields().setHospitalServiceCode(getPV1().map(pv1 -&gt; pv1.getHospitalService().getString()).orElse(null));</span>
<span class="fc" id="L2094">        result.setVersion(1L);</span>

<span class="fc" id="L2096">        String actionPlanText = null;</span>

<span class="fc" id="L2098">        boolean contentProvided = false;</span>
<span class="pc bpc" id="L2099" title="1 of 2 branches missed.">        if (&quot;ED&quot;.equals(obx.getValueType().getString())) {</span>
<span class="fc" id="L2100">            byte[] edValueBytes = obx.getEdValue();</span>
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">            if (edValueBytes != null) {</span>
<span class="fc" id="L2102">                String mediaType = StringUtils.lowerCase(obx.getEdDataType().getString() + &quot;/&quot; + obx.getEdSubDataType().getString());</span>
                // for now we only support text/html and im/various
<span class="fc bfc" id="L2104" title="All 2 branches covered.">                if (mediaType.equals(&quot;text/html&quot;)) {</span>
<span class="fc" id="L2105">                    String edValue = new String(edValueBytes, StandardCharsets.UTF_8);</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">                    if (StringUtils.isNotEmpty(edValue)) {</span>
<span class="fc" id="L2107">                        contentProvided = true;</span>
                    }
<span class="fc bfc" id="L2109" title="All 2 branches covered.">                    if (!edValue.trim().toLowerCase().startsWith(&quot;&lt;div&quot;)) {</span>
<span class="fc" id="L2110">                        edValue = &quot;&lt;div&gt;&quot; + edValue + &quot;&lt;/div&gt;&quot;;</span>
                    }

<span class="fc" id="L2113">                    actionPlanText = edValue;</span>
<span class="pc bpc" id="L2114" title="1 of 4 branches missed.">                } else if (mediaType.equals(&quot;application/pdf&quot;) || mediaType.equals(&quot;text/pdf&quot;)) {</span>
<span class="fc" id="L2115">                    HL7String filename = getHl7Text(root, &quot;TXA.16.1&quot;);</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">                    if (filename.isBlank()) {</span>
<span class="nc" id="L2117">                        filename = HL7String.of(&quot;PDF-CarePlan.pdf&quot;);</span>
                    }

<span class="fc" id="L2120">                    String fixedMediaType = fileSecurityHandler.runChecks(filename.getString(), edValueBytes, mediaType)</span>
<span class="fc" id="L2121">                            .getOrElseThrow(ApiCallMalformedException::new);</span>
<span class="fc bfc" id="L2122" title="All 2 branches covered.">                    if (!mediaType.equals(fixedMediaType)) {</span>
<span class="fc" id="L2123">                        LOGGER.warn(&quot;Media type changed from {} to {} in care plan message {} from {}&quot;, mediaType, fixedMediaType, getMessageIdString(), hl7ConnContext);</span>
                    }

<span class="pc bpc" id="L2126" title="1 of 2 branches missed.">                    if (edValueBytes.length &gt; 0) {</span>
<span class="fc" id="L2127">                        contentProvided = true;</span>
                    }

<span class="fc" id="L2130">                    Attachment attachment = new Attachment();</span>
<span class="fc" id="L2131">                    attachment.setContent(edValueBytes);</span>
<span class="fc" id="L2132">                    attachment.setMediaType(fixedMediaType);</span>
<span class="fc" id="L2133">                    attachment.setFilename(filename.getString());</span>
<span class="fc" id="L2134">                    result.setAttachmentAsActionPlanContent(attachment);</span>
<span class="fc" id="L2135">                } else {</span>
<span class="nc" id="L2136">                    throw new ApiCallMalformedException(&quot;ED media type not yet supported: &quot; + mediaType);</span>
                }
<span class="fc" id="L2138">            } else {</span>
<span class="nc" id="L2139">                throw new ApiCallMalformedException(&quot;No ED content found&quot;);</span>
            }
<span class="fc" id="L2141">        } else {</span>
<span class="nc" id="L2142">            throw new ApiCallMalformedException(&quot;Care plans currently only support ED value type; found &quot; + obx.getValueType().getString());</span>
        }

        // PHR-7707: Care plans should always have content
<span class="fc bfc" id="L2146" title="All 2 branches covered.">        if (!contentProvided) {</span>
<span class="fc" id="L2147">            throw new ApiCallMalformedException(&quot;No care plan content found&quot;);</span>
        }

<span class="fc" id="L2150">        PlanField planField = new PlanField();</span>
<span class="fc" id="L2151">        planField.setLabel(TemplateFieldLabel.ACTION_PLAN);</span>
<span class="fc" id="L2152">        planField.setSequence(0L);</span>
<span class="fc" id="L2153">        planField.setText(actionPlanText);</span>
<span class="fc" id="L2154">        result.addField(planField);</span>

<span class="fc" id="L2156">        planField = new PlanField();</span>
<span class="fc" id="L2157">        planField.setLabel(TemplateFieldLabel.GREEN);</span>
<span class="fc" id="L2158">        planField.setSequence(1L);</span>
<span class="fc" id="L2159">        planField.setText(&quot;&quot;);</span>
<span class="fc" id="L2160">        result.addField(planField);</span>

<span class="fc" id="L2162">        planField = new PlanField();</span>
<span class="fc" id="L2163">        planField.setLabel(TemplateFieldLabel.AMBER);</span>
<span class="fc" id="L2164">        planField.setSequence(2L);</span>
<span class="fc" id="L2165">        planField.setText(&quot;&quot;);</span>
<span class="fc" id="L2166">        result.addField(planField);</span>

<span class="fc" id="L2168">        planField = new PlanField();</span>
<span class="fc" id="L2169">        planField.setLabel(TemplateFieldLabel.RED);</span>
<span class="fc" id="L2170">        planField.setSequence(3L);</span>
<span class="fc" id="L2171">        planField.setText(&quot;&quot;);</span>
<span class="fc" id="L2172">        result.addField(planField);</span>

<span class="fc" id="L2174">        return result;</span>
    }

    /**
     * Parses document of type (&quot;DS&quot;, &quot;CL&quot;, &quot;RL&quot;, &quot;AL&quot;, &quot;TCI&quot;, &quot;MDT&quot;, &quot;DL&quot;, &quot;BR&quot;, &quot;HS&quot;, &quot;TT&quot;, &quot;SP&quot;, &quot;ST&quot;) from an MDM^T02 message.
     * The method returns the message object, which does not actually include the file content.
     * See also parseMdmDocumentAttachment().
     *
     * @return A new {@code EncounterEvent}, partially populated.
     */
    public EncounterEvent parseMdmT02DocumentMessage(SourceDetails sourceDetails) {

        // Expecting _one_ TXA segmant
<span class="fc" id="L2187">        expectSingleSegment(&quot;TXA&quot;);</span>

        // Enforce mandatory document ID
<span class="fc" id="L2190">        HL7String documentId = getMdmDocumentId();</span>
<span class="fc" id="L2191">        HL7ValueExpectation expectationTXA_12 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2192">                .withId(&quot;TXA-12.1&quot;)</span>
<span class="fc" id="L2193">                .withName(&quot;document ID&quot;)</span>
<span class="fc" id="L2194">                .withProvidedHL7Value(documentId)</span>
<span class="fc" id="L2195">                .build();</span>
<span class="fc" id="L2196">        enforceMandatoryValue(expectationTXA_12, false/*absentAllowed*/);</span>

        // Enforce mandatory document status, and validate equal to &quot;AU&quot;
<span class="fc" id="L2199">        HL7String completionStatus = getHl7Text(root, &quot;TXA.17.1&quot;);</span>
<span class="fc" id="L2200">        HL7ValueExpectation expectationTXA_17 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2201">                .withId(&quot;TXA-17.1&quot;)</span>
<span class="fc" id="L2202">                .withName(&quot;completion status&quot;)</span>
<span class="fc" id="L2203">                .withProvidedHL7Value(completionStatus)</span>
<span class="fc" id="L2204">                .build();</span>
<span class="fc" id="L2205">        enforceMandatoryValue(expectationTXA_17, false/*absentAllowed*/);</span>
<span class="fc" id="L2206">        enforcePermittedValue(expectationTXA_17, ImmutableSet.of(DOC_COMPLETION_STATUS_AU));</span>

        // The enteredDate is meant to capture the last time a human touched
        // this document. There are 4 possible dates available in the TXA
        // segment, this method will try them in priority order. Failing that,
        // the current time will be used.

<span class="fc" id="L2213">        Instant enteredDate = null;</span>

<span class="fc" id="L2215">        HL7String editDateTimeString = HL7XmlDoc.getHl7Text(root, &quot;TXA.8.1&quot;);</span>
<span class="fc" id="L2216">        Instant editDateTime = HL7XmlDoc.parseDateOrTimestamp(editDateTimeString, &quot;TXA.8.1&quot;, messageProperties).getInstant();</span>

<span class="fc bfc" id="L2218" title="All 2 branches covered.">        if (editDateTime != null) {</span>
<span class="fc" id="L2219">            enteredDate = editDateTime;</span>
        } else {
<span class="fc" id="L2221">            HL7String transcriptionDateTimeString = HL7XmlDoc.getHl7Text(root, &quot;TXA.7.1&quot;);</span>
<span class="fc" id="L2222">            Instant transcriptionDateTime = HL7XmlDoc.parseDateOrTimestamp(transcriptionDateTimeString, &quot;TXA.7.1&quot;, messageProperties)</span>
<span class="fc" id="L2223">                    .getInstant();</span>

<span class="fc bfc" id="L2225" title="All 2 branches covered.">            if (transcriptionDateTime != null) {</span>
<span class="fc" id="L2226">                enteredDate = transcriptionDateTime;</span>
            } else {
<span class="fc" id="L2228">                HL7String originationDateTimeString = HL7XmlDoc.getHl7Text(root, &quot;TXA.6.1&quot;);</span>
<span class="fc" id="L2229">                Instant originationDateTime = HL7XmlDoc.parseDateOrTimestamp(originationDateTimeString, &quot;TXA.6.1&quot;, messageProperties)</span>
<span class="fc" id="L2230">                        .getInstant();</span>

<span class="fc bfc" id="L2232" title="All 2 branches covered.">                if (originationDateTime != null) {</span>
<span class="fc" id="L2233">                    enteredDate = originationDateTime;</span>
                } else {
<span class="fc" id="L2235">                    HL7String activityDateTimeString = HL7XmlDoc.getHl7Text(root, &quot;TXA.4.1&quot;);</span>
<span class="fc" id="L2236">                    Instant activityDateTime = HL7XmlDoc.parseDateOrTimestamp(activityDateTimeString, &quot;TXA.4.1&quot;, messageProperties)</span>
<span class="fc" id="L2237">                            .getInstant();</span>

<span class="fc bfc" id="L2239" title="All 2 branches covered.">                    if (activityDateTime != null) {</span>
<span class="fc" id="L2240">                        enteredDate = activityDateTime;</span>
                    } else {
<span class="fc" id="L2242">                        HL7String messageDateTimeString = HL7XmlDoc.getHl7Text(root, &quot;MSH.7.1&quot;);</span>
<span class="fc" id="L2243">                        Instant messageDateTime = HL7XmlDoc.parseDateOrTimestamp(messageDateTimeString, &quot;MSH.7.1&quot;, messageProperties)</span>
<span class="fc" id="L2244">                                .getInstant();</span>
<span class="pc bpc" id="L2245" title="1 of 2 branches missed.">                        if (messageDateTime != null) {</span>
<span class="fc" id="L2246">                            enteredDate = messageDateTime;</span>
                        } else {
                            // OK, I give up!
<span class="nc" id="L2249">                            enteredDate = dateTimeService.now();</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L2256">        EncounterEvent encounterEvent = new EncounterEvent(sourceDetails);</span>
<span class="fc" id="L2257">        encounterEvent.generateNewRandomUniqueId();</span>
<span class="fc" id="L2258">        encounterEvent.getBaseFields().setEnteredDate(Date.from(enteredDate));</span>
<span class="fc" id="L2259">        encounterEvent.setPostalDate(getDocumentPostalDate());</span>

<span class="fc" id="L2261">        return encounterEvent;</span>
    }

    @Nullable
    private Instant getDocumentPostalDate() {
<span class="fc" id="L2266">        HL7String postalDateString = HL7XmlDoc.getHl7Text(root, &quot;ZPM.1.1&quot;);</span>
<span class="fc" id="L2267">        return HL7XmlDoc.parseDateOrTimestamp(postalDateString, &quot;ZPM.1.1&quot;, messageProperties).getInstant();</span>
    }

    /**
     * Validates an MDM^T11 document deletion message.
     *
     * @throws ApiCallMalformedException if TXA.12.1 is missing or empty or if there is more than one TXA segment
     */
    public void validateMdmT11DocumentDeletionMessage() {

        // Expecting _one_ TXA segmant
<span class="fc" id="L2278">        expectSingleSegment(&quot;TXA&quot;);</span>

<span class="fc" id="L2280">        HL7String externalDocId = HL7XmlDoc.getHl7Text(root, &quot;TXA.12.1&quot;);</span>
<span class="fc" id="L2281">        HL7String documentType = HL7XmlDoc.getHl7Text(root, &quot;TXA.2.1&quot;);</span>

<span class="pc bpc" id="L2283" title="1 of 2 branches missed.">        if (externalDocId.getString().isEmpty()) {</span>
<span class="nc" id="L2284">            throw new ApiCallMalformedException(&quot;Invalid external document ID in TXA.12&quot;);</span>
        }
<span class="fc bfc" id="L2286" title="All 2 branches covered.">        if (&quot;CP&quot;.equals(documentType.getString())) {</span>
<span class="fc" id="L2287">            throw new ApiCallMalformedException(&quot;Invalid document type &quot; + documentType.getString());</span>
        }
<span class="fc" id="L2289">    }</span>

    /**
     * Parses a document from an MDM T02 message. The method returns the attachment object containing the file content.
     *
     * @param message        The message to which this attachment belongs
     * @param hl7ConnContext The HL7 connection context
     * @return A new {@code Attachment}, with the file content already set.
     */
    public Attachment parseMdmDocumentAttachment(Message message, HL7ConnContext hl7ConnContext) {

<span class="fc" id="L2300">        byte[] content = null;</span>

        // Expecting _one_ OBX with RTF in it, for now. Don't make more flexible until needed.
<span class="fc" id="L2303">        NodeList obxNodes = expectSingleSegment(&quot;OBX&quot;);</span>

<span class="fc" id="L2305">        Element obxNode = (Element) obxNodes.item(0);</span>
<span class="fc" id="L2306">        HL7Observation obx = new HL7Observation(messageProperties);</span>
        // No OBR trace to send because there is no OBR segment in an MDM^T02 message
<span class="fc" id="L2308">        OBSERVATION_PARSER.populate(obx, obxNode, &quot;&quot;);</span>

<span class="fc" id="L2310">        String obxTrace = &quot;OBX[&quot; + obx.getObxSetId().getString() + &quot;]&quot;;</span>

        // Set any sender-specified delay
<span class="fc" id="L2313">        HL7Util.getPatientDelayDays(obx.getAccessChecks().getString(), obxTrace).ifPresent(message::setDelayDisplayDays);</span>

<span class="fc" id="L2315">        String mediaType = &quot;&quot;;</span>
<span class="pc bpc" id="L2316" title="1 of 2 branches missed.">        if (&quot;ED&quot;.equals(obx.getValueType().getString())) {</span>
<span class="fc" id="L2317">            byte[] edValueBytes = obx.getEdValue();</span>

<span class="pc bpc" id="L2319" title="1 of 2 branches missed.">            if (edValueBytes != null) {</span>
<span class="fc" id="L2320">                mediaType = StringUtils.lowerCase(obx.getEdDataType().getString() + &quot;/&quot; + obx.getEdSubDataType().getString());</span>
                try {
<span class="fc" id="L2322">                    HL7DocumentMimeType documentMimeType = HL7DocumentMimeType.getConvertedMediaType(mediaType);</span>

                    // parsing the obx took care of confirming we have a supported encoding
<span class="fc" id="L2325">                    mediaType = documentMimeType.toString();</span>
<span class="fc" id="L2326">                    content = edValueBytes;</span>
<span class="fc" id="L2327">                } catch (IllegalArgumentException ignored) {</span>
<span class="fc" id="L2328">                    throw new ApiCallMalformedException(&quot;ED media type not yet supported: &quot; + mediaType);</span>
<span class="fc" id="L2329">                }</span>
            } else {
<span class="nc" id="L2331">                throw new ApiCallMalformedException(&quot;No ED content found&quot;);</span>
            }
<span class="fc" id="L2333">        } else {</span>
<span class="nc" id="L2334">            throw new ApiCallMalformedException(&quot;We currently only support ED value type; found &quot; + obx.getValueType().getString());</span>
        }

<span class="fc" id="L2337">        HL7String filename = HL7XmlDoc.getHl7Text(root, &quot;TXA.16.1&quot;);</span>

<span class="fc" id="L2339">        String fixedMediaType = fileSecurityHandler.runChecks(filename.getString(), content, mediaType)</span>
<span class="fc" id="L2340">                .getOrElseThrow(e -&gt; new ApiCallMalformedException(e));</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">        if (!mediaType.equals(fixedMediaType)) {</span>
<span class="fc" id="L2342">            LOGGER.warn(&quot;Media type changed from {} to {} in document message {} from {}&quot;, mediaType, fixedMediaType, getMessageIdString(), hl7ConnContext);</span>
        }

<span class="fc" id="L2345">        Attachment attachment = new Attachment();</span>
<span class="fc" id="L2346">        attachment.setContent(content);</span>
<span class="fc" id="L2347">        attachment.setMediaType(fixedMediaType);</span>
<span class="fc" id="L2348">        attachment.setFilename(filename.getString());</span>

<span class="fc" id="L2350">        return attachment;</span>
    }

    // =========== ADT (MANAGE ENCOUNTER) MESSAGE HANDLING

    public EncounterEvent parseEncounterMessage(SourceDetails sourceDetails) {

<span class="fc" id="L2357">        HL7MessageHeader msh = getHL7MessageHeader(); // MSH Segment</span>
<span class="fc" id="L2358">        HL7EventType evn = getHL7EventType(); // EVN</span>
<span class="fc" id="L2359">        HL7PatientVisit1 pv1 = getPV1().orElseThrow(</span>
<span class="nc" id="L2360">                () -&gt; new ApiCallMalformedException(&quot;Cannot handle &quot; + getMSH().getMessageType() + &quot; message: PV1 segment missing&quot;)); // PV1 Segment</span>
<span class="fc" id="L2361">        HL7PatientVisit2 pv2 = getHL7PatientVisit2(); // PV2 Segment</span>

<span class="fc" id="L2363">        EncounterEvent encounterEvent = new EncounterEvent(sourceDetails);</span>
<span class="fc" id="L2364">        encounterEvent.generateNewRandomUniqueId();</span>
<span class="fc" id="L2365">        encounterEvent.setMessageType(MessageType.getPKBMessageTypeFromHL7ADTMessageType(getHL7MessageHeader().getMessageType().getString()));</span>
<span class="fc" id="L2366">        encounterEvent.setEncounterClass(getPkbCS04ValueToEncounterClassMap(pv1.getPatientClass().getString()));</span>

<span class="fc bfc" id="L2368" title="All 2 branches covered.">        if (encounterEvent.getEncounterClass() == null) {</span>
            // fall back to EncounterClass.OTHER
            // see: https://www.hl7.org/fhir/valueset-encounter-class.html
            // not quite OTHER as per definition from link, really NOT_PROVIDED or UNKNOWN but OTHER is closest we have
<span class="fc" id="L2372">            encounterEvent.setEncounterClass(EncounterClass.OTHER);</span>
<span class="fc" id="L2373">            LOGGER.warn(&quot;PV1-2 Encounter Class not provided.&quot;);</span>
        }

<span class="fc" id="L2376">        GeographicLocation geo = new GeographicLocation();</span>
<span class="fc" id="L2377">        geo.setDescription(pv1.getAssignedPatientLocation().getLocationDescription().getString());</span>
<span class="fc" id="L2378">        encounterEvent.setLocation(geo);</span>

<span class="fc" id="L2380">        List&lt;ParticipantDTO&gt; participantsNonPkb = getNonPkbParticipants(pv1);</span>

<span class="fc bfc" id="L2382" title="All 2 branches covered.">        if (!participantsNonPkb.isEmpty()) {</span>
<span class="fc" id="L2383">            encounterEvent.setParticipantsNonPKB(participantsNonPkb);</span>
        }

<span class="fc" id="L2386">        encounterEvent.setExternalEncounterId(pv1.getVisitNumber().getString());</span>
<span class="fc" id="L2387">        encounterEvent.getBaseFields().setHospitalServiceCode(pv1.getHospitalService().getString());</span>

        // validation checks

        // All Messages: PV1-2 mandatory patient class
<span class="pc bpc" id="L2392" title="1 of 2 branches missed.">        if (encounterEvent.getEncounterClass() == null) {</span>
<span class="nc" id="L2393">            LOGGER.warn(&quot;Encounter Class not set on Encounter Message&quot;);</span>
        }

        // All Messages: PV1-19 mandatory visit ID to track encounter
<span class="fc bfc" id="L2397" title="All 2 branches covered.">        if (StringUtils.isBlank(encounterEvent.getExternalEncounterId())) {</span>
<span class="fc" id="L2398">            throw new ApiCallMalformedException(&quot;There was no VisitID provided in PV1-19.&quot;);</span>
        }

        // A01 mandatory values check
<span class="fc bfc" id="L2402" title="All 2 branches covered.">        if (encounterEvent.getMessageType() == MessageType.PATIENT_ADMIT) {</span>
            // PV1-44
<span class="fc bfc" id="L2404" title="All 2 branches covered.">            if (pv1.getAdmitDateTime().isBlank()) {</span>
<span class="pc bpc" id="L2405" title="1 of 2 branches missed.">                if (msh.getDateTimeOfMessage().isBlank()) {</span>
<span class="nc" id="L2406">                    throw new ApiCallMalformedException(&quot;Could not obtain Patient Admit Date.&quot;);</span>
                }
            }
        }

        // A02 mandatory values check
<span class="fc bfc" id="L2412" title="All 2 branches covered.">        if (encounterEvent.getMessageType() == MessageType.PATIENT_TRANSFER) {</span>
            // Timestamp of event occurred, from either EVN-6 or MSH-7
<span class="pc bpc" id="L2414" title="2 of 4 branches missed.">            if (evn == null || evn.getEventOccurredDate().isBlank()) {</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">                if (msh.getDateTimeOfMessage().isBlank()) {</span>
<span class="nc" id="L2416">                    throw new ApiCallMalformedException(&quot;Could not obtain event occurred date.&quot;);</span>
                }
            }
        }

        // A03 mandatory values check
<span class="fc bfc" id="L2422" title="All 2 branches covered.">        if (encounterEvent.getMessageType() == MessageType.PATIENT_DISCHARGE) {</span>
            // PV1-45
<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">            if (pv1.getDischargeDateTime().isBlank()) {</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">                if (msh.getDateTimeOfMessage().isBlank()) {</span>
<span class="nc" id="L2426">                    throw new ApiCallMalformedException(&quot;Could not obtain Patient Discharge Date.&quot;);</span>
                }
            }
        }

        // A05 and A14 mandatory values check
<span class="fc bfc" id="L2432" title="All 4 branches covered.">        if (encounterEvent.getMessageType() == MessageType.PATIENT_PRE_ADMIT || encounterEvent.getMessageType() == MessageType.PATIENT_PENDING_ADMIT) {</span>
            // Timestamp of planned event, from either PV2-8, EVN-3, PV1-44
<span class="pc bpc" id="L2434" title="3 of 4 branches missed.">            if (pv2 == null || pv2.getExpectedAdmitDateTime().isBlank()) { // PV2-8</span>
<span class="pc bpc" id="L2435" title="1 of 4 branches missed.">                if (evn == null || evn.getEventPlannedDate().isBlank()) { // EVN-3</span>
<span class="fc bfc" id="L2436" title="All 2 branches covered.">                    if (pv1.getAdmitDateTime().isBlank()) { // PV1.44</span>
<span class="pc bpc" id="L2437" title="1 of 2 branches missed.">                        if (msh.getDateTimeOfMessage().isBlank()) { // finally, MSH-7</span>
<span class="nc" id="L2438">                            throw new ApiCallMalformedException(&quot;Could not obtain scheduled encounter date.&quot;);</span>
                        }
                    }
                }
            }
        }

        // A08 mandatory values check
<span class="fc bfc" id="L2446" title="All 2 branches covered.">        if (encounterEvent.getMessageType() == MessageType.PATIENT_INFORMATION_UPDATE) {</span>
            // Timestamp of event occurred, from either EVN-6 or MSH-7
<span class="pc bpc" id="L2448" title="3 of 4 branches missed.">            if (evn == null || evn.getEventOccurredDate().isBlank()) {</span>
<span class="pc bpc" id="L2449" title="1 of 2 branches missed.">                if (msh.getDateTimeOfMessage().isBlank()) {</span>
<span class="nc" id="L2450">                    throw new ApiCallMalformedException(&quot;Could not obtain event occurred date.&quot;);</span>
                }
            }
            // Admission and discharge timestamps can be omitted, but must not be the HL7 Null Value
<span class="fc bfc" id="L2454" title="All 2 branches covered.">            if (pv1.getAdmitDateTime().isHL7Null()) {</span>
<span class="fc" id="L2455">                throw new ApiCallMalformedException(&quot;Admit datetime must not be null in an A08 message. Use an A11 to cancel an admission.&quot;);</span>
            }
<span class="fc bfc" id="L2457" title="All 2 branches covered.">            if (pv1.getDischargeDateTime().isHL7Null()) {</span>
<span class="fc" id="L2458">                throw new ApiCallMalformedException(&quot;Discharge datetime must not be null in an A08 message. Use an A13 to cancel a discharge.&quot;);</span>
            }
        }

<span class="fc" id="L2462">        return encounterEvent;</span>
    }

    private List&lt;ParticipantDTO&gt; getNonPkbParticipants(HL7PatientVisit1 pv1) {
<span class="fc" id="L2466">        List&lt;ParticipantDTO&gt; participantsNonPkb = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2467">        handleNonPkbParticipant(ATTENDER, pv1.getAttendingDoctor()).ifPresent(participantsNonPkb::add);</span>
<span class="fc" id="L2468">        handleNonPkbParticipant(REFERRER, pv1.getReferringDoctor()).ifPresent(participantsNonPkb::add);</span>
<span class="fc" id="L2469">        handleNonPkbParticipant(CONSULTANT, pv1.getConsultingDoctor()).ifPresent(participantsNonPkb::add);</span>
<span class="fc" id="L2470">        return participantsNonPkb;</span>
    }

    private Optional&lt;ParticipantDTO&gt; handleNonPkbParticipant(ParticipantRole role, HL7PersonRef ref) {
<span class="pc bpc" id="L2474" title="1 of 4 branches missed.">        if (ref != null &amp;&amp; ref.isValid()) {</span>
<span class="fc" id="L2475">            return Optional.of(ParticipantDTOBuilder</span>
<span class="fc" id="L2476">                    .forNonPkbParticipant(ref.makeDisplayText()).withRole(role).get());</span>
        }
<span class="fc" id="L2478">        return Optional.empty();</span>
    }

    // =========== SIU (MANAGE SCHEDULED APPOINTMENTS) MESSAGE HANDLING
    private Optional&lt;HL7ResourceGroup&gt; parseResourceGroup() {
<span class="fc" id="L2483">        HL7ResourceGroup resourceGroup = null;</span>

<span class="fc" id="L2485">        NodeList segmentList = root.getChildNodes();</span>
<span class="fc" id="L2486">        int length = segmentList.getLength();</span>

<span class="fc bfc" id="L2488" title="All 2 branches covered.">        for (int index = 0; index &lt; length; index++) {</span>
<span class="fc" id="L2489">            Element segment = (Element) segmentList.item(index);</span>
<span class="fc" id="L2490">            String segmentName = segment.getTagName();</span>

<span class="fc bfc" id="L2492" title="All 3 branches covered.">            switch (segmentName) {</span>
                case &quot;RGS&quot;:
<span class="pc bpc" id="L2494" title="1 of 2 branches missed.">                    if (resourceGroup != null) {</span>
<span class="nc" id="L2495">                        throw new ApiCallMalformedException(&quot;Multiple RGS segment&quot;);</span>
                    }

<span class="fc" id="L2498">                    resourceGroup = new HL7ResourceGroup(messageProperties);</span>
<span class="fc" id="L2499">                    break;</span>
                case &quot;AIP&quot;:
<span class="fc bfc" id="L2501" title="All 2 branches covered.">                    if (resourceGroup == null) {</span>
<span class="fc" id="L2502">                        throw new ApiCallMalformedException(&quot;AIP segment must appear after an RGS segment&quot;);</span>
                    }

<span class="fc" id="L2505">                    resourceGroup.parseAip(segment);</span>
<span class="fc" id="L2506">                    break;</span>
                default:
                    break;
            }

        }

<span class="fc" id="L2513">        return Optional.ofNullable(resourceGroup);</span>
    }

    public AppointmentDTO parseNewAppointment(PKBPerson patient, SourceDetails sourceDetails) {

<span class="fc" id="L2518">        HL7Appointment hl7Appointment = new HL7Appointment(messageProperties);</span>
<span class="fc" id="L2519">        hl7Appointment.parseSch(root);</span>

<span class="fc" id="L2521">        HL7String comment = HL7XmlDoc.getHl7Text(root, &quot;NTE.3.1&quot;);</span>

<span class="fc" id="L2523">        HL7String visitLocation = HL7XmlDoc.getHl7Text(root, &quot;PV1.3.9&quot;);</span>

        // Enforce mandatory values

<span class="fc" id="L2527">        HL7ValueExpectation expectationSCH_1_1 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2528">                .withId(&quot;SCH-1.1&quot;)</span>
<span class="fc" id="L2529">                .withName(&quot;placer ID&quot;)</span>
<span class="fc" id="L2530">                .withProvidedHL7Value(hl7Appointment.getPlacerId())</span>
<span class="fc" id="L2531">                .build();</span>
<span class="fc" id="L2532">        enforceMandatoryValue(expectationSCH_1_1, false/*absentAllowed*/);</span>
<span class="fc" id="L2533">        HL7ValueExpectation expectationSCH_11_4 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2534">                .withId(&quot;SCH-11.4&quot;)</span>
<span class="fc" id="L2535">                .withName(&quot;start time&quot;)</span>
<span class="fc" id="L2536">                .withProvidedHL7Value(hl7Appointment.getStartTimestamp())</span>
<span class="fc" id="L2537">                .build();</span>
<span class="fc" id="L2538">        enforceMandatoryValue(expectationSCH_11_4, false/*absentAllowed*/);</span>
<span class="fc" id="L2539">        HL7ValueExpectation expectationPV1_3_9 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2540">                .withId(&quot;PV1-3.9&quot;)</span>
<span class="fc" id="L2541">                .withName(&quot;appointment location&quot;)</span>
<span class="fc" id="L2542">                .withProvidedHL7Value(visitLocation)</span>
<span class="fc" id="L2543">                .build();</span>
<span class="fc" id="L2544">        enforceMandatoryValue(expectationPV1_3_9, false/*absentAllowed*/);</span>

        // Apply defaults for some optional values

<span class="pc bpc" id="L2548" title="1 of 2 branches missed.">        if (hl7Appointment.getAppointmentReasonText().isBlank()) {</span>
            // TODO: i18n
<span class="nc" id="L2550">            hl7Appointment.setAppointmentReasonText(&quot;Appointment&quot;);</span>
        }

<span class="fc" id="L2553">        String specialty = HL7XmlDoc.getHl7Text(root, &quot;PV1.10.1&quot;).getString();</span>

<span class="fc" id="L2555">        AppointmentDTO appointmentDTO = new AppointmentDTO(sourceDetails);</span>
<span class="fc" id="L2556">        appointmentDTO.setId(null);</span>
<span class="fc" id="L2557">        appointmentDTO.setExternalId(hl7Appointment.getPlacerId().getString());</span>
<span class="fc" id="L2558">        appointmentDTO.setCommonId(UUID.randomUUID().toString());</span>
<span class="fc" id="L2559">        appointmentDTO.setPatientId(patient.getIdString());</span>
<span class="fc" id="L2560">        appointmentDTO.setPersonId(patient.getIdString());</span>
<span class="fc" id="L2561">        appointmentDTO.setStartTimestamp(hl7Appointment.getStartTimestamp().getInstant());</span>
<span class="fc" id="L2562">        appointmentDTO.setEndTimestamp(hl7Appointment.getEndTimestamp().getInstant());</span>
<span class="fc" id="L2563">        appointmentDTO.setDescription(comment.getString());</span>
<span class="fc" id="L2564">        appointmentDTO.setTypeCode(hl7Appointment.getAppointmentTypeCode().getId().getString());</span>
<span class="fc" id="L2565">        appointmentDTO.setTypeCodingSystem(hl7Appointment.getAppointmentTypeCode().getCodingSystem().getString());</span>
<span class="fc" id="L2566">        appointmentDTO.setSubject(hl7Appointment.getAppointmentReasonText().getString());</span>
<span class="fc" id="L2567">        appointmentDTO.setLocation(visitLocation.getString());</span>
<span class="fc" id="L2568">        appointmentDTO.getBaseFields().setHospitalServiceCode(specialty);</span>
<span class="fc" id="L2569">        appointmentDTO.setUpdatedSpeciality(specialty);</span>
<span class="fc" id="L2570">        parseResourceGroup().ifPresent(group -&gt; appointmentDTO.setNonPkbParticipants(group.getNonPkbParticipants()));</span>

<span class="fc" id="L2572">        AppointmentRequestDTO req = new AppointmentRequestDTO(sourceDetails);</span>
<span class="fc" id="L2573">        req.setParticipantId(patient.getIdString());</span>
<span class="fc" id="L2574">        req.setParticipant(patient);</span>
<span class="fc" id="L2575">        req.setCommonId(UUID.randomUUID().toString());</span>

<span class="fc" id="L2577">        List&lt;AppointmentRequestDTO&gt; reqList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2578">        reqList.add(req);</span>
<span class="fc" id="L2579">        appointmentDTO.setAppointmentRequestList(reqList);</span>
<span class="fc" id="L2580">        appointmentDTO.generateNewRandomUniqueId();</span>
<span class="fc" id="L2581">        return appointmentDTO;</span>
    }

    public boolean parseUpdatedAppointment(@NotNull AppointmentDTO existingAppointment) {
<span class="fc" id="L2585">        boolean result = false;</span>

<span class="fc" id="L2587">        HL7Appointment hl7Appointment = new HL7Appointment(messageProperties);</span>
<span class="fc" id="L2588">        hl7Appointment.parseSch(root);</span>

<span class="fc" id="L2590">        HL7String comment = HL7XmlDoc.getHl7Text(root, &quot;NTE.3.1&quot;);</span>

<span class="fc" id="L2592">        HL7String visitLocation = HL7XmlDoc.getHl7Text(root, &quot;PV1.3.9&quot;);</span>

        // Enforce mandatory values

<span class="fc" id="L2596">        HL7ValueExpectation expectationSCH_1_1 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2597">                .withId(&quot;SCH-1.1&quot;)</span>
<span class="fc" id="L2598">                .withName(&quot;placer ID&quot;)</span>
<span class="fc" id="L2599">                .withProvidedHL7Value(hl7Appointment.getPlacerId())</span>
<span class="fc" id="L2600">                .build();</span>
<span class="fc" id="L2601">        enforceMandatoryValue(expectationSCH_1_1, false/*absentAllowed*/);</span>
<span class="fc" id="L2602">        HL7ValueExpectation expectationSCH_11_4 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2603">                .withId(&quot;SCH-11.4&quot;)</span>
<span class="fc" id="L2604">                .withName(&quot;start time&quot;)</span>
<span class="fc" id="L2605">                .withProvidedHL7Value(hl7Appointment.getStartTimestamp())</span>
<span class="fc" id="L2606">                .build();</span>
<span class="fc" id="L2607">        enforceMandatoryValue(expectationSCH_11_4, true/*absentAllowed*/);</span>
<span class="fc" id="L2608">        HL7ValueExpectation expectationPV1_3_9 = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2609">                .withId(&quot;PV1-3.9&quot;)</span>
<span class="fc" id="L2610">                .withName(&quot;appointment location&quot;)</span>
<span class="fc" id="L2611">                .withProvidedHL7Value(visitLocation)</span>
<span class="fc" id="L2612">                .build();</span>
<span class="fc" id="L2613">        enforceMandatoryValue(expectationPV1_3_9, true/*absentAllowed*/);</span>

        // Update any provided values, applying defaults only if HL7 null value
        // was provided.

<span class="fc bfc" id="L2618" title="All 2 branches covered.">        if (hl7Appointment.getAppointmentReasonText().isProvided()) {</span>
<span class="pc bpc" id="L2619" title="1 of 2 branches missed.">            if (hl7Appointment.getAppointmentReasonText().isHL7Null()) {</span>
                // TODO: i18n
<span class="nc" id="L2621">                hl7Appointment.setAppointmentReasonText(&quot;Appointment&quot;);</span>
            }

<span class="fc" id="L2624">            existingAppointment.setSubject(hl7Appointment.getAppointmentReasonText().getString());</span>
<span class="fc" id="L2625">            result = true;</span>
        }

<span class="pc bpc" id="L2628" title="1 of 2 branches missed.">        if (hl7Appointment.getAppointmentTypeCode().getId().isProvided()) {</span>
<span class="nc" id="L2629">            existingAppointment.setTypeCode(hl7Appointment.getAppointmentTypeCode().getId().getString());</span>
<span class="nc" id="L2630">            result = true;</span>
        }

<span class="pc bpc" id="L2633" title="1 of 2 branches missed.">        if (hl7Appointment.getAppointmentTypeCode().getCodingSystem().isProvided()) {</span>
<span class="nc" id="L2634">            existingAppointment.setTypeCodingSystem(hl7Appointment.getAppointmentTypeCode().getCodingSystem().getString());</span>
<span class="nc" id="L2635">            result = true;</span>
        }

<span class="fc bfc" id="L2638" title="All 2 branches covered.">        if (hl7Appointment.getStartTimestamp().isProvided()) {</span>
<span class="fc" id="L2639">            existingAppointment.setStartTimestamp(hl7Appointment.getStartTimestamp().getInstant());</span>
<span class="fc" id="L2640">            result = true;</span>
        }

<span class="fc bfc" id="L2643" title="All 2 branches covered.">        if (hl7Appointment.getEndTimestamp().isProvided()) {</span>
<span class="fc" id="L2644">            existingAppointment.setEndTimestamp(hl7Appointment.getEndTimestamp().getInstant());</span>
<span class="fc" id="L2645">            result = true;</span>
        }

<span class="fc bfc" id="L2648" title="All 2 branches covered.">        if (comment.isProvided()) {</span>
<span class="fc" id="L2649">            existingAppointment.setDescription(comment.getString());</span>
<span class="fc" id="L2650">            result = true;</span>
        }

<span class="fc bfc" id="L2653" title="All 2 branches covered.">        if (visitLocation.isProvided()) {</span>
<span class="fc" id="L2654">            existingAppointment.setLocation(visitLocation.getString());</span>
<span class="fc" id="L2655">            result = true;</span>
        }

<span class="fc" id="L2658">        Optional&lt;HL7ResourceGroup&gt; group = parseResourceGroup();</span>
<span class="fc bfc" id="L2659" title="All 2 branches covered.">        if (group.isPresent()) {</span>
<span class="fc" id="L2660">            existingAppointment.setNonPkbParticipants(group.get().getNonPkbParticipants());</span>
<span class="fc" id="L2661">            result = true;</span>
        }

<span class="fc" id="L2664">        return result;</span>

        // TODO: Should we update the specialty, or not?
        // For now, do not.
    }

    public String parseMandatoryAppointmentId() {
<span class="fc" id="L2671">        HL7String placerId = HL7XmlDoc.getHl7Text(root, &quot;SCH.1.1&quot;);</span>

        // Only enforce placerId because that's all we need
<span class="fc" id="L2674">        HL7ValueExpectation expectation = HL7ValueExpectation.builder()</span>
<span class="fc" id="L2675">                .withId(&quot;SCH-1.1&quot;)</span>
<span class="fc" id="L2676">                .withName(&quot;placer ID&quot;)</span>
<span class="fc" id="L2677">                .withProvidedHL7Value(placerId)</span>
<span class="fc" id="L2678">                .build();</span>
<span class="fc" id="L2679">        enforceMandatoryValue(expectation, false/*absentAllowed*/);</span>

<span class="fc" id="L2681">        return placerId.getString();</span>
    }

    public static long parseToOffset(String input) {
<span class="fc" id="L2685">        return Instant.from(getHl7TsFormat(false).parse(input, new ParsePosition(0))).toEpochMilli();</span>
    }

    //======== PRIVATE HELPER FUNCTIONS
    private static DateTimeFormatter getHl7TsFormat(boolean includeTzOffset) {
<span class="pc bpc" id="L2690" title="1 of 2 branches missed.">        if (includeTzOffset) {</span>
<span class="nc" id="L2691">            return HL7_TIMESTAMP_MILLI_FORMAT_WITH_TZ;</span>
        }
<span class="fc" id="L2693">        return HL7_TIMESTAMP_MILLI_FORMAT_WITHOUT_TZ;</span>
    }

    //======== PUBLIC HELPER FUNCTIONS

    public static String hl7Escape(String s) {
<span class="fc bfc" id="L2699" title="All 2 branches covered.">        if (StringUtils.isEmpty(s)) {</span>
<span class="fc" id="L2700">            return s;</span>
        }
        //    	\F\     field separator  |
        //    	\S\     component separator  ^
        //    	\T\     subcomponent separator  &amp;
        //    	\R\     repetition separator  ~
        //    	\E\     escape character   \
<span class="fc" id="L2707">        s = StringUtils.replace(s, &quot;\\&quot;, &quot;\\E\\&quot;); // do this one first... or it'll sabotage the other escapes!</span>
<span class="fc" id="L2708">        s = StringUtils.replace(s, &quot;|&quot;, &quot;\\F\\&quot;);</span>
<span class="fc" id="L2709">        s = StringUtils.replace(s, &quot;^&quot;, &quot;\\S\\&quot;);</span>
<span class="fc" id="L2710">        s = StringUtils.replace(s, &quot;&amp;&quot;, &quot;\\T\\&quot;);</span>
<span class="fc" id="L2711">        s = StringUtils.replace(s, &quot;~&quot;, &quot;\\R\\&quot;);</span>

<span class="fc" id="L2713">        return s;</span>
    }

    public static String hl7Unescape(String s) {
<span class="pc bpc" id="L2717" title="1 of 2 branches missed.">        if (StringUtils.isBlank(s)) {</span>
<span class="nc" id="L2718">            return s;</span>
        }
        //    	\F\     field separator  |
        //    	\S\     component separator  ^
        //    	\T\     subcomponent separator  &amp;
        //    	\R\     repetition separator  ~
        //    	\E\     escape character   \
<span class="fc" id="L2725">        s = StringUtils.replace(s, &quot;\\E\\&quot;, &quot;\\&quot;); // do this one first, just in case the text was double-escaped</span>
<span class="fc" id="L2726">        s = StringUtils.replace(s, &quot;\\F\\&quot;, &quot;|&quot;);</span>
<span class="fc" id="L2727">        s = StringUtils.replace(s, &quot;\\S\\&quot;, &quot;^&quot;);</span>
<span class="fc" id="L2728">        s = StringUtils.replace(s, &quot;\\T\\&quot;, &quot;&amp;&quot;);</span>
<span class="fc" id="L2729">        s = StringUtils.replace(s, &quot;\\R\\&quot;, &quot;~&quot;);</span>
<span class="fc" id="L2730">        s = StringUtils.replace(s, &quot;\\.br\\&quot;, &quot;\n&quot;);</span>

<span class="fc" id="L2732">        return s;</span>
    }

    /**
     * @return String unescaped and trimmed by default
     */
    public static HL7String getHl7Text(Element parent, String tagName) {
<span class="fc" id="L2739">        return getHl7Text(parent, tagName, true/*unescape*/, true/*trim*/);</span>
    }

    /**
     * Only call this method if you are not providing true for both boolean
     * params; this will help us to see where strings are being handled
     * differently.
     *
     * @param parent
     * @param tagName
     * @param unescape
     * @param trim
     * @return
     */
    public static HL7String getHl7Text(Element parent, String tagName, boolean unescape, boolean trim) {
<span class="pc bpc" id="L2754" title="1 of 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L2755">            return HL7String.EMPTY;</span>
        }

<span class="fc" id="L2758">        NodeList nodeList = parent.getElementsByTagName(tagName);</span>
<span class="pc bpc" id="L2759" title="1 of 6 branches missed.">        if ((nodeList == null) || (nodeList.getLength() == 0) || !nodeList.item(0).hasChildNodes()) {</span>
<span class="fc" id="L2760">            return HL7String.EMPTY;</span>
        }

        // log warning if we're grabbing a single item when it's actually a list
<span class="fc bfc" id="L2764" title="All 2 branches covered.">        if (nodeList.getLength() &gt; 1) {</span>
<span class="fc" id="L2765">            LOGGER.warn(&quot;HL7 parse warning: selecting single value for tag {} (child of {}) but found list of {}&quot;,</span>
<span class="fc" id="L2766">                    tagName, parent.getTagName(), nodeList.getLength());</span>
        }

<span class="fc" id="L2769">        String textVal = nodeList.item(0).getFirstChild().getNodeValue();</span>
<span class="pc bpc" id="L2770" title="1 of 2 branches missed.">        String escaped = (unescape) ? hl7Unescape(textVal) : textVal;</span>
<span class="pc bpc" id="L2771" title="1 of 2 branches missed.">        String trimmed = (trim) ? StringUtils.trim(escaped) : escaped;</span>

<span class="fc" id="L2773">        return new HL7String(trimmed);</span>
    }

    /**
     * returns a non-null list (empty list if none are found)
     */
    public static List&lt;HL7String&gt; getHl7TextList(Element parent, String tagName) {
<span class="fc" id="L2780">        return getHl7TextList(parent, tagName, true/*unescape*/, true/*trim*/);</span>
    }

    public static String joinTextContentOfTags(Element parent, String tagName, boolean trim) {
<span class="fc" id="L2784">        return getHl7TextList(parent, tagName, true, trim).stream().map(HL7String::getString).collect(joining(&quot;\n&quot;));</span>
    }

    /**
     * returns a non-null list (empty list if none are found)
     */
    public static List&lt;HL7String&gt; getHl7TextList(Element parent, String tagName, boolean unescape, boolean trim) {
<span class="pc bpc" id="L2791" title="1 of 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L2792">            return Collections.emptyList();</span>
        }

<span class="fc" id="L2795">        List&lt;HL7String&gt; textVals = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2796">        NodeList nodeList = parent.getElementsByTagName(tagName);</span>
<span class="pc bpc" id="L2797" title="1 of 2 branches missed.">        if (nodeList != null) {</span>
<span class="fc bfc" id="L2798" title="All 2 branches covered.">            for (int i = 0; i &lt; nodeList.getLength(); ++i) {</span>
<span class="fc" id="L2799">                String textVal = nodeList.item(i).getTextContent();</span>
<span class="pc bpc" id="L2800" title="1 of 2 branches missed.">                String escaped = (unescape) ? hl7Unescape(textVal) : textVal;</span>
<span class="fc bfc" id="L2801" title="All 2 branches covered.">                String trimmed = (trim) ? StringUtils.trim(escaped) : escaped;</span>
<span class="fc" id="L2802">                textVals.add(new HL7String(trimmed)); // don't omit empty lines</span>
            }
        }

<span class="fc" id="L2806">        return textVals;</span>
    }

    /**
     * Extracts just the timestamp offset portion, if present, of the specified
     * timestamp.
     * &lt;p&gt;
     * Might return the empty string, will not return null.
     *
     * @param timestamp
     * @return
     */
    private static String parseTimestampOffset(String timestamp) {

<span class="fc" id="L2820">        String tzoVal = &quot;&quot;;</span>

<span class="fc" id="L2822">        int sp = timestamp.indexOf(&quot;+&quot;);</span>
<span class="fc" id="L2823">        int sm = timestamp.indexOf(&quot;-&quot;);</span>

<span class="fc bfc" id="L2825" title="All 2 branches covered.">        int sign = (sp &gt;= 0) ? sp : sm;</span>

<span class="fc bfc" id="L2827" title="All 2 branches covered.">        if (sign &gt;= 0) {</span>
<span class="fc" id="L2828">            tzoVal = timestamp.substring(sign);</span>
        }

<span class="fc" id="L2831">        return tzoVal;</span>
    }

    /**
     * proper parsing of an varying-length HL7 date or timestamp
     * valid format is yyyy[MM[dd[HH[mm[ss[.S[S[S[S]]]]]]]][+/-ZZZZ]
     * &lt;p&gt;
     * NOTE: for now we support only 3 (not 4) digits after the second decimal point, since that's
     * what it's easiest to parse in Java. We'll need to tweak this if we ever start getting data
     * where a ten-thousandth of a second matters in the timestamp.
     * &lt;p&gt;
     * Some of this is roughly based on util code in the HAPI project (http://hl7api.sourceforge.net)
     * which is licensed under the MPL 1.1 http://www.mozilla.org/MPL/1.1/ and GPLv2.
     * Classes referenced: CommonTS, CommonDT, CommonTM
     * &lt;p&gt;
     * &lt;p&gt;
     * Eh, their approach is too much.
     * We just need a parsing string that works for the FULL THING, then we can fill in
     * the missing bits of the timestamp string (a missing time = midnight)
     */
    public static HL7Date parseDateOrTimestamp(HL7String hl7Value, String trace, HL7MessageProperties messageProperties)
            throws ApiCallMalformedException {

        // short circuit if it's some form of empty
<span class="fc bfc" id="L2855" title="All 2 branches covered.">        if (hl7Value.isBlank()) {</span>
<span class="fc" id="L2856">            return new HL7Date(hl7Value.getRawValue(), null);</span>
        }

<span class="fc" id="L2859">        String value = hl7Value.getString();</span>

        // snip into pieces -- date, time (if found), and timezone offset (if found) sections
<span class="fc" id="L2862">        String dateVal = &quot;&quot;, timeVal = &quot;&quot;, tzoVal = &quot;&quot;;</span>
<span class="fc" id="L2863">        int sp = value.indexOf(&quot;+&quot;);</span>
<span class="fc" id="L2864">        int sm = value.indexOf(&quot;-&quot;);</span>
<span class="fc bfc" id="L2865" title="All 2 branches covered.">        int sign = (sp &gt;= 0) ? sp : sm; // pick the +/- sign we find (if any) for tz offset...</span>

<span class="fc" id="L2867">        String withoutTz = value;</span>
<span class="fc bfc" id="L2868" title="All 2 branches covered.">        if (sign &gt;= 0) {</span>
<span class="fc" id="L2869">            tzoVal = value.substring(sign);</span>
<span class="fc" id="L2870">            withoutTz = value.substring(0, sign);</span>
        }

<span class="fc" id="L2873">        dateVal = withoutTz;</span>
<span class="fc bfc" id="L2874" title="All 2 branches covered.">        if (withoutTz.length() &gt; 8) {</span>
<span class="fc" id="L2875">            dateVal = withoutTz.substring(0, 8);</span>
<span class="fc" id="L2876">            timeVal = withoutTz.substring(8);</span>
        }

        // DATE

        // short-circuit if it's not a valid length
<span class="fc" id="L2882">        int len = dateVal.length();</span>
<span class="pc bpc" id="L2883" title="3 of 6 branches missed.">        if ((len != 4) &amp;&amp; (len != 6) &amp;&amp; (len != 8)) {</span>
<span class="nc" id="L2884">            throw new ApiCallMalformedException(trace + &quot;: The length of the DT datatype value does not conform to an allowable&quot;</span>
                    + &quot; format. Format should conform to yyyy[MM[dd]] - value found: &quot; + dateVal);
        }

<span class="pc bpc" id="L2888" title="1 of 2 branches missed.">        if (len == 4) {</span>
<span class="nc" id="L2889">            dateVal += &quot;0101&quot;;</span>
<span class="pc bpc" id="L2890" title="1 of 2 branches missed.">        } else if (len == 6) {</span>
<span class="nc" id="L2891">            dateVal += &quot;01&quot;;</span>
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">        } else if (len == 8) {</span>
            // all set
        } else {
<span class="nc" id="L2895">            throw new ApiCallMalformedException(trace + &quot;: The length of the DT datatype value does not conform to an allowable&quot;</span>
                    + &quot; format. Format should conform to yyyy[MM[dd]] - value found: &quot; + dateVal);
        }

        // TIME

<span class="fc" id="L2901">        len = timeVal.length();</span>
<span class="pc bpc" id="L2902" title="1 of 4 branches missed.">        if ((len &gt; 6) &amp;&amp; (timeVal.charAt(6) != '.')) {</span>
<span class="nc" id="L2903">            throw new ApiCallMalformedException(</span>
                    trace + &quot;: Invalid time segment of timestamp; format should be yyyy[MM[dd[HH[mm[ss[.S[S[S[S]]]]]]]][+/-ZZZZ] - time value found: &quot;
                            + timeVal);
        }

<span class="fc bfc" id="L2908" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L2909">            timeVal += &quot;000000.000&quot;;</span>
<span class="pc bpc" id="L2910" title="1 of 2 branches missed.">        } else if (len == 2) {</span>
<span class="nc" id="L2911">            timeVal += &quot;0000.000&quot;;</span>
<span class="fc bfc" id="L2912" title="All 2 branches covered.">        } else if (len == 4) {</span>
<span class="fc" id="L2913">            timeVal += &quot;00.000&quot;;</span>
<span class="fc bfc" id="L2914" title="All 2 branches covered.">        } else if (len == 6) {</span>
<span class="fc" id="L2915">            timeVal += &quot;.000&quot;;</span>
<span class="fc bfc" id="L2916" title="All 2 branches covered.">        } else if (len == 8) {</span>
<span class="fc" id="L2917">            timeVal += &quot;00&quot;;</span>
<span class="fc bfc" id="L2918" title="All 2 branches covered.">        } else if (len == 9) {</span>
<span class="fc" id="L2919">            timeVal += &quot;0&quot;;</span>
<span class="pc bpc" id="L2920" title="1 of 2 branches missed.">        } else if (len == 10) {</span>
            // all set
<span class="nc bnc" id="L2922" title="All 2 branches missed.">        } else if (len == 11) {</span>
<span class="nc" id="L2923">            timeVal = timeVal.substring(0, 10);</span>
        } else {
<span class="nc" id="L2925">            throw new ApiCallMalformedException(</span>
                    trace + &quot;: Invalid time segment of timestamp; format should be yyyy[MM[dd[HH[mm[ss[.S[S[S[S]]]]]]]][+/-ZZZZ] - time value found: &quot;
                            + timeVal);
        }

        // TIMEZONE OFFSET
<span class="fc bfc" id="L2931" title="All 2 branches covered.">        if (StringUtils.isBlank(tzoVal)) {</span>
<span class="fc" id="L2932">            LOGGER.debug(&quot;We don't have a timezone offset value provided.&quot;);</span>
<span class="fc bfc" id="L2933" title="All 2 branches covered.">            if (messageProperties.getDefaultTimestampOffset() != null) {</span>
<span class="fc" id="L2934">                LOGGER.debug(&quot;Taking tzoffset from MSH-7 value provided in HL7 payload.&quot;);</span>
<span class="fc" id="L2935">                tzoVal = messageProperties.getDefaultTimestampOffset();</span>
<span class="fc bfc" id="L2936" title="All 2 branches covered.">            } else if (messageProperties.getSenderTimeZone() != null) {</span>
                int tzOffset;
                try {
<span class="fc" id="L2939">                    tzOffset = messageProperties</span>
<span class="fc" id="L2940">                            .getSenderTimeZone()</span>
<span class="fc" id="L2941">                            .getOffset(parseToOffset(dateVal + timeVal));</span>

<span class="fc" id="L2943">                    LOGGER.debug(&quot;Deriving timezone offset for this date in sender location: {}&quot;, messageProperties.getSenderTimeZone());</span>
<span class="pc bpc" id="L2944" title="1 of 2 branches missed.">                    String tzSign = tzOffset &lt; 0 ? &quot;-&quot; : &quot;+&quot;;</span>
<span class="fc" id="L2945">                    String tzHours = String.format(&quot;%02d&quot;, Math.abs(tzOffset) / 1000 / 60 / 60);</span>
<span class="fc" id="L2946">                    String tzMins = String.format(&quot;%02d&quot;, (Math.abs(tzOffset) / 1000 / 60) % 60);</span>
<span class="fc" id="L2947">                    tzoVal = tzSign + tzHours + tzMins;</span>
<span class="nc" id="L2948">                } catch (DateTimeParseException ignored) {</span>
<span class="nc" id="L2949">                    LOGGER.warn(&quot;Could not get the timezone offset for date given the timezone ID: {}. Default to UTC (no offset).&quot;,</span>
<span class="nc" id="L2950">                            messageProperties.getSenderTimeZone());</span>
<span class="pc" id="L2951">                }</span>
            } else {
<span class="fc" id="L2953">                LOGGER.debug(&quot;Falling back to UTC&quot;);</span>
<span class="fc" id="L2954">                tzoVal = &quot;+0000&quot;; // UTC</span>
            }
        }

<span class="fc" id="L2958">        len = tzoVal.length();</span>
<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">        if (len == 3) {</span>
<span class="nc" id="L2960">            tzoVal += &quot;00&quot;;</span>
<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">        } else if (len == 5) {</span>
            // all set!
        } else {
<span class="nc" id="L2964">            throw new ApiCallMalformedException(</span>
                    trace + &quot;: Invalid time zone offset value; format should be [+/-ZZZZ] - offset found: &quot; + tzoVal);
        }
        try {
<span class="fc" id="L2968">            return new HL7Date(value, ZonedDateTime.parse(dateVal + timeVal + tzoVal, HL7_TIMESTAMP_MILLI_FORMAT_WITH_TZ));</span>
<span class="fc" id="L2969">        } catch (DateTimeParseException pe) {</span>
<span class="fc" id="L2970">            throw new ApiCallMalformedException(</span>
                    trace + &quot;: Invalid timestamp value; format should be yyyy[MM[dd[HH[mm[ss[.S[S[S[S]]]]]]]][+/-ZZZZ] -&quot;
                            + &quot; input &quot; + value + &quot; cleaned to &quot; + dateVal + timeVal + tzoVal,
                    pe);
        }
    }

    public static String formatTimestamp(TemporalAccessor temporal) {
<span class="fc" id="L2978">        return HL7_TIMESTAMP_SECONDS_FORMAT_WITH_TZ.format(temporal);</span>
    }

    /**
     * Returns a sanitised version of the provided XML, suitable for logging.
     * &lt;p&gt;
     * Note: If an MSH segment is present, then only contents after the (first) MSH segment will be sanitised.
     *
     * @param xml The XML to be sanitised
     * @return A sanitised version of the XML
     */
    @Nullable
    public static String sanitiseXml(String xml) {
<span class="nc bnc" id="L2991" title="All 2 branches missed.">        if (xml == null) {</span>
<span class="nc" id="L2992">            return null;</span>
        }
<span class="nc" id="L2994">        StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L2995">        String xmlToBeSanitised = xml;</span>
        try {
<span class="nc" id="L2997">            String endMarker = &quot;&lt;/MSH&gt;&quot;;</span>
<span class="nc" id="L2998">            int headerEndX = xmlToBeSanitised.indexOf(endMarker);</span>
<span class="nc bnc" id="L2999" title="All 2 branches missed.">            if (headerEndX &gt; 0) {</span>
<span class="nc" id="L3000">                result.append(xmlToBeSanitised, 0, headerEndX + endMarker.length());</span>
<span class="nc" id="L3001">                xmlToBeSanitised = xmlToBeSanitised.substring(headerEndX + endMarker.length());</span>
            }
<span class="nc" id="L3003">            result.append(XmlSanitiser.sanitiseXml(xmlToBeSanitised));</span>
<span class="nc" id="L3004">        } catch (Exception e) {</span>
<span class="nc" id="L3005">            return &quot;Failed HL7 XML sanitisation: &quot; + e.getMessage();</span>
<span class="nc" id="L3006">        }</span>
<span class="nc" id="L3007">        return result.toString();</span>
    }

    /**
     * Helper method that returns the node name in the ER7 XML serialized XML data
     * for the given segment, field and component.
     *
     * @param segment
     * @param field
     * @param component
     * @return String The identifier of the xml element such as &quot;PV1.3.9&quot; where segment = PV1, field = 3, component=9
     */
    public static String getIdentifier(String segment, int field, int component) {
<span class="fc" id="L3020">        return segment + &quot;.&quot; + field + &quot;.&quot; + component;</span>
    }

    public static String getIdentifier(String segment, int field) {
<span class="nc" id="L3024">        return getIdentifier(segment, field, 1);</span>
    }

    public static EncounterClass getPkbCS04ValueToEncounterClassMap(String value) {
<span class="fc" id="L3028">        return pkbCS04ValueToEncounterClassMap.get(value);</span>
    }

    public static boolean tagByNameExists(Element obx, String tagName) {
<span class="fc" id="L3032">        NodeList tags = obx.getElementsByTagName(tagName);</span>
<span class="pc bpc" id="L3033" title="2 of 4 branches missed.">        return tags != null &amp;&amp; tags.getLength() &gt; 0;</span>
    }

    public boolean hasZtmSegment() {
<span class="fc bfc" id="L3037" title="All 2 branches covered.">        return root.getElementsByTagName(&quot;ZTM&quot;).getLength() &gt; 0;</span>
    }

    @NotNull
    private NodeList expectSingleSegment(String segmentTypeName) {
<span class="fc" id="L3042">        NodeList nodeList = root.getElementsByTagName(segmentTypeName);</span>
<span class="fc bfc" id="L3043" title="All 2 branches covered.">        if (nodeList.getLength() != 1) {</span>
<span class="fc" id="L3044">            throw new ApiCallMalformedException(String.format(&quot;Expected one %s segment; found %d %s segments&quot;,</span>
<span class="fc" id="L3045">                    segmentTypeName, nodeList.getLength(), segmentTypeName));</span>
        }
<span class="fc" id="L3047">        return nodeList;</span>
    }

    private static class UniqueHl7ObservationKey {

        private String fillerOrderNumber;
        private HL7String testId;
        private HL7String testCodingSystem;

<span class="fc" id="L3056">        public UniqueHl7ObservationKey(String fillerOrderNumber, HL7Observation obx) {</span>
<span class="fc" id="L3057">            this.fillerOrderNumber = fillerOrderNumber;</span>
<span class="fc" id="L3058">            this.testId = obx.getTestCode().getId();</span>
<span class="fc" id="L3059">            this.testCodingSystem = obx.getTestCode().getCodingSystem();</span>
<span class="fc" id="L3060">        }</span>

        public String getFillerOrderNumber() {
<span class="nc" id="L3063">            return fillerOrderNumber;</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L3068" title="1 of 2 branches missed.">            if (this == o) {</span>
<span class="nc" id="L3069">                return true;</span>
            }
<span class="pc bpc" id="L3071" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L3072">                return false;</span>
            }
<span class="fc" id="L3074">            UniqueHl7ObservationKey that = (UniqueHl7ObservationKey) o;</span>
<span class="pc bpc" id="L3075" title="1 of 2 branches missed.">            return Objects.equals(fillerOrderNumber, that.fillerOrderNumber) &amp;&amp;</span>
<span class="pc bpc" id="L3076" title="1 of 2 branches missed.">                    Objects.equals(testId, that.testId) &amp;&amp;</span>
<span class="pc bpc" id="L3077" title="1 of 2 branches missed.">                    Objects.equals(testCodingSystem, that.testCodingSystem);</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L3082">            return Objects.hash(fillerOrderNumber, testId, testCodingSystem);</span>
        }
    }

    private class SendingFacilityWithAuth {
        private String sendingFacility, authPrincipal, ip;

<span class="fc" id="L3089">        SendingFacilityWithAuth(String sendingFacility, String authPrincipal, String ip) {</span>
<span class="fc" id="L3090">            this.sendingFacility = sendingFacility;</span>
<span class="fc" id="L3091">            this.authPrincipal = authPrincipal;</span>
<span class="fc" id="L3092">            this.ip = ip;</span>
<span class="fc" id="L3093">        }</span>
    }

<span class="nc" id="L3096">    private abstract class InstructionsObfuscateMixin {</span>
        @JsonSerialize(using = InstructionsSerializer.class)
        public abstract String getInstructions();
    }

<span class="nc" id="L3101">    private abstract class HL7CodeObfuscateMixin {</span>
        @JsonSerialize(using = HL7CodingSystemSerializer.class)
        public abstract HL7Value getCodingSystem();

        @JsonSerialize(using = HL7CodingSystemSerializer.class)
        public abstract HL7Value getAltCodingSystem();
    }

    private static class InstructionsSerializer extends ObfuscatingStringSerializer&lt;String&gt; {
        InstructionsSerializer() {
<span class="fc" id="L3111">            super(String.class, false);</span>
<span class="fc" id="L3112">        }</span>
    }

    private static class HL7CodingSystemSerializer extends Hl7ValueSerializer {
        HL7CodingSystemSerializer() {
<span class="fc" id="L3117">            super(true);</span>
<span class="fc" id="L3118">        }</span>
    }

    private static class ObfuscatingStringSerializer&lt;T&gt; extends StdSerializer&lt;T&gt; {
<span class="fc" id="L3122">        private final byte[] salt = new byte[16];</span>
        private final boolean includeClearTextAsWell;

        ObfuscatingStringSerializer(Class&lt;T&gt; t, boolean includeClearTextAsWell) {
<span class="fc" id="L3126">            super(t);</span>
<span class="fc" id="L3127">            this.includeClearTextAsWell = includeClearTextAsWell;</span>
<span class="fc" id="L3128">            new SecureRandom().nextBytes(salt);</span>
<span class="fc" id="L3129">        }</span>

        @Override
        public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException {
<span class="fc" id="L3133">            MessageDigest digest = unchecked(() -&gt; MessageDigest.getInstance(&quot;SHA-256&quot;)).get();</span>
<span class="fc" id="L3134">            digest.update(salt);</span>
<span class="fc" id="L3135">            String valueForSerialisation = getValueForSerialisation(value);</span>
<span class="fc bfc" id="L3136" title="All 2 branches covered.">            if (shouldObfuscate(value)) {</span>
<span class="fc" id="L3137">                byte[] encodedhash = digest.digest(valueForSerialisation.getBytes(StandardCharsets.UTF_8));</span>
<span class="fc bfc" id="L3138" title="All 2 branches covered.">                if (includeClearTextAsWell) {</span>
<span class="fc" id="L3139">                    gen.writeStartObject();</span>
<span class="fc" id="L3140">                    gen.writeStringField(&quot;originalValue&quot;, valueForSerialisation);</span>
<span class="fc" id="L3141">                    gen.writeBinaryField(&quot;hashedValue&quot;, encodedhash);</span>
<span class="fc" id="L3142">                    gen.writeEndObject();</span>
                } else {
<span class="fc" id="L3144">                    gen.writeBinary(encodedhash);</span>
                }
<span class="fc" id="L3146">            } else {</span>
<span class="fc" id="L3147">                gen.writeString(valueForSerialisation);</span>
            }
<span class="fc" id="L3149">        }</span>

        boolean shouldObfuscate(T value) {
<span class="fc" id="L3152">            return true;</span>
        }

        String getValueForSerialisation(T value) {
<span class="fc" id="L3156">            return value.toString();</span>
        }

    }

    private static class Hl7ValueSerializer extends ObfuscatingStringSerializer&lt;HL7Value&gt; {

        Hl7ValueSerializer(boolean includeClearTextAsWell) {
<span class="fc" id="L3164">            super(HL7Value.class, includeClearTextAsWell);</span>
<span class="fc" id="L3165">        }</span>

        Hl7ValueSerializer() {
<span class="fc" id="L3168">            this(false);</span>
<span class="fc" id="L3169">        }</span>

        @Override
        String getValueForSerialisation(HL7Value value) {
<span class="fc" id="L3173">            return value.getRawValue();</span>
        }

        @Override
        boolean shouldObfuscate(HL7Value value) {
<span class="fc" id="L3178">            return value.isProvided();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>