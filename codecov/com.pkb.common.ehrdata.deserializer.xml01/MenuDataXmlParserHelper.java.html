<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MenuDataXmlParserHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.common.ehrdata.deserializer.xml01</a> &gt; <span class="el_source">MenuDataXmlParserHelper.java</span></div><h1>MenuDataXmlParserHelper.java</h1><pre class="source lang-java linenums">package com.pkb.common.ehrdata.deserializer.xml01;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Timer;
import io.vavr.Function1;
import io.vavr.Function2;
import org.apache.commons.lang3.ArrayUtils;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.google.common.base.Preconditions.checkState;
import static io.vavr.API.unchecked;
import static io.vavr.Function1.identity;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.stream.Collectors.toMap;
import static org.apache.commons.lang3.StringUtils.isEmpty;

public class MenuDataXmlParserHelper {

<span class="fc" id="L45">    public static final ZoneId APPLICATION_TZ = ZoneId.of(&quot;Europe/London&quot;);</span>
<span class="fc" id="L46">    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

<span class="fc" id="L48">    private static final XMLInputFactory XML_INPUT_FACTORY = XMLInputFactory.newInstance();</span>
    private static final String CDATA_ENCODING_ATTRIB = &quot;cdataEncoding&quot;;
    private static final String CDATA_ENCODING_BASE64 = &quot;Base64&quot;;

<span class="fc" id="L52">    private static final Timer XML_PARSE_TIMER = Timer.builder(&quot;pkb_phr_menudata_xmlparseseconds&quot;)</span>
<span class="fc" id="L53">            .description(&quot;Time needed to parse xml&quot;)</span>
<span class="fc" id="L54">            .publishPercentileHistogram()</span>
<span class="fc" id="L55">            .publishPercentiles(0.5, 0.9, 0.95, 0.99)</span>
<span class="fc" id="L56">            .register(Metrics.globalRegistry);</span>

    private MenuDataXmlParserHelper() {
    }

    @NotNull
    public static Map&lt;String, Object&gt; unmarshalEncryptedFields(byte[] plaintext) {

<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (ArrayUtils.isNotEmpty(plaintext)) {</span>
<span class="fc" id="L65">            return XML_PARSE_TIMER.record(() -&gt; unchecked(() -&gt; {</span>
<span class="fc" id="L66">                XMLStreamReader reader = null;</span>
                try {
<span class="fc" id="L68">                    reader = createXMLStreamReader(plaintext);</span>
<span class="fc" id="L69">                    return readXmlFields(reader);</span>
                } finally {
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                    if (reader != null) {</span>
<span class="fc" id="L72">                        reader.close();</span>
                    }
                }
<span class="fc" id="L75">            }).get());</span>
        }

<span class="nc" id="L78">        return new HashMap&lt;&gt;();</span>
    }

    @NotNull
    private static XMLStreamReader createXMLStreamReader(byte[] plaintext) throws XMLStreamException, IOException {
<span class="fc" id="L83">        try (ByteArrayInputStream bais = new ByteArrayInputStream(plaintext)) {</span>
<span class="fc" id="L84">            return XML_INPUT_FACTORY.createXMLStreamReader(bais, &quot;UTF-8&quot;);</span>
        }
    }

    @NotNull
    private static Map&lt;String, Object&gt; readXmlFields(XMLStreamReader reader) throws XMLStreamException {
<span class="fc" id="L90">        Map&lt;String, Object&gt; loadMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L91">        readXmlFields(reader, loadMap);</span>
<span class="fc" id="L92">        return loadMap;</span>
    }

    private static void readXmlFields(XMLStreamReader reader, Map&lt;String, Object&gt; loadMap) throws XMLStreamException {

<span class="fc" id="L97">        boolean cdataIsBase64 = false;</span>

<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L100">            reader.next();</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (reader.getEventType() == XMLStreamConstants.START_ELEMENT) {</span>

                // no-op for &quot;fields&quot;, but process each &quot;field&quot; entry
<span class="fc" id="L105">                String nodeName = reader.getName().getLocalPart();</span>

<span class="pc bpc" id="L107" title="1 of 3 branches missed.">                switch (nodeName) {</span>
                    case &quot;fields&quot;:
<span class="fc" id="L109">                        cdataIsBase64 = nodeAttributes(reader).anyMatch(MenuDataXmlParserHelper::isBase64EncodingAttribute);</span>
<span class="fc" id="L110">                        break;</span>
                    case &quot;field&quot;:
<span class="fc" id="L112">                        readXmlFieldValue(reader, cdataIsBase64, loadMap);</span>
<span class="fc" id="L113">                        break;</span>
                    default:
<span class="nc" id="L115">                        LOGGER.warn(&quot;Unexpected xml01 start element: {}&quot;, nodeName);</span>
                        break;
                }

<span class="pc bpc" id="L119" title="1 of 2 branches missed.">            } else if (reader.getEventType() == XMLStreamConstants.END_ELEMENT) {</span>
                // when we hit &lt;/fields&gt;, we're done
<span class="fc" id="L121">                String nodeName = reader.getName().getLocalPart();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">                if (&quot;fields&quot;.equals(nodeName)) {</span>
<span class="fc" id="L123">                    return;</span>
                }
<span class="fc" id="L125">            }</span>
        }
<span class="nc" id="L127">    }</span>

    /**
     * Returns true if the attribute identifies the content as base64-encoded, otherwise false
     */
    private static boolean isBase64EncodingAttribute(Map.Entry&lt;String, String&gt; attr) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        return CDATA_ENCODING_ATTRIB.equals(attr.getKey())</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                &amp;&amp; CDATA_ENCODING_BASE64.equals(attr.getValue());</span>
    }

    /**
     * Generate a stream of Map.Entry containing each attribute name/value pair for the current node
     */
    @NotNull
    private static Stream&lt;Map.Entry&lt;String, String&gt;&gt; nodeAttributes(XMLStreamReader reader) {
<span class="fc" id="L142">        Function1&lt;Integer, Map.Entry&lt;String, String&gt;&gt; mapNameAndValue = Function2.of(MenuDataXmlParserHelper::nodeAttributeMapEntry).apply(reader);</span>
<span class="fc" id="L143">        return IntStream.range(0, reader.getAttributeCount())</span>
<span class="fc" id="L144">                .mapToObj(mapNameAndValue::apply);</span>
    }

    /**
     * Constructs a Map.Entry for the attribute name/value pair at index idx
     */
    @NotNull
    private static Map.Entry&lt;String, String&gt; nodeAttributeMapEntry(XMLStreamReader reader, int idx) {
<span class="fc" id="L152">        return new AbstractMap.SimpleEntry&lt;&gt;(</span>
<span class="fc" id="L153">                reader.getAttributeName(idx).getLocalPart(),</span>
<span class="fc" id="L154">                reader.getAttributeValue(idx));</span>
    }

    /**
     * Returns true if the attribute identifies a node name or type, otherwise false
     */
    private static boolean isNameOrTypeAttribute(Map.Entry&lt;String, String&gt; attr) {
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">        return &quot;type&quot;.equals(attr.getKey()) || &quot;name&quot;.equals(attr.getKey());</span>
    }

    /**
     * From JavaDoc for XMLStreamReader.getElementText() -- because this
     * side-effect is confusing! Precondition: the current event is
     * START_ELEMENT. Postcondition: the current event is the corresponding
     * END_ELEMENT.
     *
     * @throws XMLStreamException
     */
    private static void readXmlFieldValue(XMLStreamReader reader, boolean cdataIsBase64, Map&lt;String, Object&gt; loadMap) throws XMLStreamException {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        checkState(reader.getEventType() == XMLStreamConstants.START_ELEMENT, &quot;Current event type must be START_ELEMENT&quot;);</span>

<span class="fc" id="L175">        Map&lt;String, String&gt; attrs = nodeAttributes(reader)</span>
<span class="fc" id="L176">                .filter(MenuDataXmlParserHelper::isNameOrTypeAttribute)</span>
<span class="fc" id="L177">                .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));</span>
<span class="fc" id="L178">        String name = attrs.getOrDefault(&quot;name&quot;, null);</span>
<span class="fc" id="L179">        String type = attrs.getOrDefault(&quot;type&quot;, null);</span>

        Object value;

<span class="pc bpc" id="L183" title="1 of 4 branches missed.">        if ((type == null) || &quot;null&quot;.equals(type)) {</span>
<span class="fc" id="L184">            value = null;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        } else if (&quot;String&quot;.equals(type)) {</span>
<span class="fc" id="L186">            value = readCData(reader, cdataIsBase64);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        } else if (&quot;Date&quot;.equals(type)) {</span>
<span class="fc" id="L188">            value = Date.from(Instant.ofEpochMilli(Long.parseLong(readCData(reader, cdataIsBase64))));</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        } else if (&quot;ZonedDateTime&quot;.equals(type)) {</span>
<span class="nc" id="L190">            value = ZonedDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(readCData(reader, cdataIsBase64))), APPLICATION_TZ);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        } else if (&quot;ZonedDateTimeFull&quot;.equals(type)) {</span>
<span class="fc" id="L192">            value = ZonedDateTime.parse(readCData(reader, cdataIsBase64), DateTimeFormatter.ISO_ZONED_DATE_TIME);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        } else if (&quot;Instant&quot;.equals(type)) {</span>
<span class="nc" id="L194">            value = DateTimeFormatter.ISO_INSTANT.parse(readCData(reader, cdataIsBase64), Instant::from);</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        } else if (&quot;LocalDateTime&quot;.equals(type)) {</span>
<span class="nc" id="L196">            value = LocalDateTime.parse(readCData(reader, cdataIsBase64), DateTimeFormatter.ISO_LOCAL_DATE_TIME);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        } else if (&quot;LocalDate&quot;.equals(type)) {</span>
<span class="nc" id="L198">            value = LocalDate.parse(readCData(reader, cdataIsBase64), DateTimeFormatter.ISO_LOCAL_DATE);</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        } else if (&quot;LocalTime&quot;.equals(type)) {</span>
<span class="nc" id="L200">            value = LocalTime.parse(readCData(reader, cdataIsBase64), DateTimeFormatter.ISO_LOCAL_TIME);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        } else if (&quot;Long&quot;.equals(type)) {</span>
<span class="fc" id="L202">            value = Long.parseLong(readCData(reader, cdataIsBase64));</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        } else if (&quot;Boolean&quot;.equals(type)) {</span>
<span class="fc" id="L204">            value = Boolean.parseBoolean(readCData(reader, cdataIsBase64));</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        } else if (&quot;Double&quot;.equals(type)) {</span>
<span class="fc" id="L206">            value = Double.parseDouble(readCData(reader, cdataIsBase64));</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        } else if (&quot;List&lt;String&gt;&quot;.equals(type)) {</span>
<span class="fc" id="L208">            value = processSimpleList(reader, cdataIsBase64);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        } else if (&quot;List&lt;Long&gt;&quot;.equals(type)) {</span>
<span class="nc" id="L210">            value = processSimpleList(reader, cdataIsBase64, Long::parseLong);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        } else if (&quot;List&lt;Map&lt;String,Object&gt;&gt;&quot;.equals(type)) {</span>
<span class="fc" id="L212">            value = processMapList(reader);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        } else if (&quot;Map&lt;String,Object&gt;&quot;.equals(type)) { // for nested DTOs</span>
<span class="fc" id="L214">            value = processMap(reader);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        } else if (&quot;MenuData&quot;.equals(type)) {</span>
<span class="nc" id="L216">            LOGGER.warn(&quot;'MenuData' fields stored in xml01 not supported! field {}; value {}&quot;,</span>
<span class="nc" id="L217">                    name, readCData(reader, cdataIsBase64));</span>
<span class="nc" id="L218">            value = null;</span>
        } else {
<span class="nc" id="L220">            throw new RuntimeException(&quot;Unknown Encrypted field type: &quot; + type + &quot; in field &quot; + name);</span>
        }

<span class="fc" id="L223">        loadMap.put(name, value);</span>
<span class="fc" id="L224">    }</span>

    @NotNull
    private static Map&lt;String, Object&gt; processMap(XMLStreamReader reader) throws XMLStreamException {
<span class="fc" id="L228">        Map&lt;String, Object&gt; nestedFieldMap = new HashMap&lt;&gt;();</span>

        // read like when reading a top-level xml01
<span class="fc" id="L231">        readXmlFields(reader, nestedFieldMap);</span>

<span class="fc" id="L233">        return nestedFieldMap;</span>
    }

    @NotNull
    private static List&lt;Map&lt;String, Object&gt;&gt; processMapList(XMLStreamReader reader) throws XMLStreamException {

<span class="fc" id="L239">        List&lt;Map&lt;String, Object&gt;&gt; nestedDtoList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L241">            reader.next();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (reader.getEventType() == XMLStreamConstants.START_ELEMENT) {</span>
<span class="fc" id="L243">                String nodeName = reader.getName().getLocalPart();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">                if (&quot;item&quot;.equals(nodeName)) {</span>
<span class="fc" id="L245">                    nestedDtoList.add(processMap(reader));</span>
                } else {
<span class="nc" id="L247">                    LOGGER.warn(&quot;Unexpected xml01 start element: {}&quot;, reader.getName().getLocalPart());</span>
                }
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            } else if (reader.getEventType() == XMLStreamConstants.END_ELEMENT) {</span>
                // when we hit &lt;/field&gt;, we're done
<span class="fc" id="L251">                String nodeName = reader.getName().getLocalPart();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if (&quot;field&quot;.equals(nodeName)) {</span>
<span class="fc" id="L253">                    break;</span>
                }
<span class="fc" id="L255">            }</span>
        }
<span class="fc" id="L257">        return nestedDtoList;</span>
    }

    @NotNull
    private static List&lt;String&gt; processSimpleList(XMLStreamReader reader, boolean cdataIsBase64) {
<span class="fc" id="L262">        return processSimpleList(reader, cdataIsBase64, identity());</span>
    }

    @NotNull
    private static &lt;T&gt; List&lt;T&gt; processSimpleList(XMLStreamReader reader, boolean cdataIsBase64, Function1&lt;String, T&gt; converter) {
<span class="fc" id="L267">        return unchecked(() -&gt; {</span>
<span class="fc" id="L268">            List&lt;T&gt; values = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">            while (reader.hasNext()) {</span>
<span class="fc" id="L270">                reader.next();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                if (reader.getEventType() == XMLStreamConstants.END_ELEMENT) {</span>
<span class="fc" id="L272">                    break;</span>
                }
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">                if (reader.getEventType() == XMLStreamConstants.START_ELEMENT) {</span>
<span class="fc" id="L275">                    values.add(converter.apply(readCData(reader, cdataIsBase64)));</span>
                }
            }
<span class="fc" id="L278">            return values;</span>
<span class="fc" id="L279">        }).get();</span>
    }

    @NotNull
    private static String readCData(XMLStreamReader reader, boolean cdataIsBase64) throws XMLStreamException {
<span class="fc" id="L284">        String value = reader.getElementText();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        return cdataIsBase64 ? fromBase64(value) : value;</span>
    }

    /**
     * Decodes a base64 string to a UTF8-encoded string
     */
    @NotNull
    private static String fromBase64(String value) {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (isEmpty(value)) {</span>
<span class="nc" id="L294">            return value;</span>
        }
<span class="fc" id="L296">        byte[] asBytes = Base64.getDecoder().decode(value);</span>
<span class="fc" id="L297">        return new String(asBytes, UTF_8);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>