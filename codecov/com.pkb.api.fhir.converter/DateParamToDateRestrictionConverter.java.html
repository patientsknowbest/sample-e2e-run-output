<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateParamToDateRestrictionConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.api.fhir.converter</a> &gt; <span class="el_source">DateParamToDateRestrictionConverter.java</span></div><h1>DateParamToDateRestrictionConverter.java</h1><pre class="source lang-java linenums">package com.pkb.api.fhir.converter;

import ca.uhn.fhir.model.api.TemporalPrecisionEnum;
import ca.uhn.fhir.rest.param.DateParam;
import ca.uhn.fhir.rest.param.ParamPrefixEnum;
import com.pkb.api.fhir.util.Issues;
import com.pkb.api.fhir.util.NamedParam;
import com.pkb.domain.criteria.Constraint;
import com.pkb.domain.criteria.ImmutableRestriction;
import com.pkb.domain.criteria.Restriction;
import io.vavr.API;
import io.vavr.collection.List;
import io.vavr.collection.Map;
import io.vavr.control.Option;
import io.vavr.control.Validation;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;

import static ca.uhn.fhir.rest.param.ParamPrefixEnum.EQUAL;
import static com.pkb.api.fhir.util.Issues.errorFrom;
import static io.vavr.control.Validation.invalid;
import static io.vavr.control.Validation.valid;
import static java.lang.String.format;
import static org.hl7.fhir.dstu3.model.OperationOutcome.IssueSeverity.ERROR;

<span class="fc" id="L31">public class DateParamToDateRestrictionConverter {</span>

    private static final String DEFAULT_MESSAGE = &quot;Search parameter [%s] does not support the prefix [%s].&quot;;

<span class="fc" id="L35">    private static final Map&lt;ParamPrefixEnum, Constraint&gt; DEFAULT_PARAM_PREFIX_2_OPERATOR = API.Map(</span>
            ParamPrefixEnum.LESSTHAN, Constraint.LESS,
            ParamPrefixEnum.LESSTHAN_OR_EQUALS, Constraint.LESS_OR_EQUAL,
            ParamPrefixEnum.EQUAL, Constraint.EQUAL,
            ParamPrefixEnum.GREATERTHAN_OR_EQUALS, Constraint.GREATER_OR_EQUAL,
            ParamPrefixEnum.GREATERTHAN, Constraint.GREATER
    );

    public @NotNull Validation&lt;Issues, Option&lt;Restriction&lt;Constraint, LocalDate&gt;&gt;&gt; convert(@NotNull NamedParam&lt;DateParam&gt; dateParam) {
<span class="fc" id="L44">        return convert(dateParam, DEFAULT_PARAM_PREFIX_2_OPERATOR);</span>
    }

    public @NotNull Validation&lt;Issues, Option&lt;Restriction&lt;Constraint, LocalDate&gt;&gt;&gt; convert(@NotNull NamedParam&lt;DateParam&gt; dateParam, 
                                                                                           Map&lt;ParamPrefixEnum, Constraint&gt; customParamPrefixToOperator) {
<span class="fc" id="L49">        return actualConvert(dateParam, customParamPrefixToOperator);</span>
    }

    private @NotNull Validation&lt;Issues, Option&lt;Restriction&lt;Constraint, LocalDate&gt;&gt;&gt; actualConvert(@NotNull NamedParam&lt;DateParam&gt; dateParam, Map&lt;ParamPrefixEnum, Constraint&gt; paramPrefixToOperator) {
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if (!dateParam.successfullyParsed()) {</span>
            // DateParam is a single value query param.
<span class="fc bfc" id="L55" title="All 2 branches covered.">            return dateParam.getOriginalValues().isEmpty() ? valid(Option.none()) : invalid(errorFrom(&quot;Please provide a date in the format yyyy-mm-dd (time information not supported).&quot;));</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        } else if (dateParam.getParam().getMissing() != null) {</span>
<span class="fc" id="L57">            return invalid(errorFrom(format(&quot;Modifier [MISSING] is not supported for parameter [%s].&quot;, dateParam.getName())));</span>
        }
<span class="fc" id="L59">        Validation&lt;Issues, Constraint&gt; prefixValidation = toConstraint(dateParam, paramPrefixToOperator);</span>
<span class="fc" id="L60">        Validation&lt;Issues, LocalDate&gt; dateValidation = toLocalDate(dateParam.getParam());</span>

<span class="fc" id="L62">        return Validation.combine(prefixValidation, dateValidation).ap((constraint, date) -&gt; {</span>
<span class="fc" id="L63">            Restriction&lt;Constraint, LocalDate&gt; restriction = ImmutableRestriction.&lt;Constraint, LocalDate&gt; builder()</span>
<span class="fc" id="L64">                    .constraint(constraint)</span>
<span class="fc" id="L65">                    .value(date)</span>
<span class="fc" id="L66">                    .build();</span>
<span class="fc" id="L67">            return Option.of(restriction);</span>
<span class="fc" id="L68">        }).mapError(Issues::flatten);</span>
    }

    private Validation&lt;Issues, Constraint&gt; toConstraint(NamedParam&lt;DateParam&gt; date, Map&lt;ParamPrefixEnum, Constraint&gt; paramPrefixToOperator) {

<span class="fc" id="L73">        String message = format(DEFAULT_MESSAGE, date.getName(), &quot;%s&quot;);</span>
<span class="fc" id="L74">        ParamPrefixEnum prefix = date.getParam().getPrefix();</span>
        // FHIR tends to swallow invalid prefixes and use default one - EQUAL
<span class="fc bfc" id="L76" title="All 4 branches covered.">        if (prefix == null || prefix == EQUAL) {</span>
<span class="fc" id="L77">            String dateString = date.getParam().getValueAsString();</span>
<span class="fc" id="L78">            String originalValue = identifyMatchingOriginalValue(date);</span>
<span class="fc" id="L79">            String silentlyIgnoredPrefix = StringUtils.trimToNull(StringUtils.replace(originalValue, dateString, &quot;&quot;));</span>
<span class="pc bpc" id="L80" title="1 of 4 branches missed.">            if (silentlyIgnoredPrefix == null || silentlyIgnoredPrefix.equals(EQUAL.getValue())) {</span>
<span class="fc" id="L81">                prefix = EQUAL;</span>
            } else {
<span class="nc" id="L83">                return invalid(notSupportedPrefix(message, silentlyIgnoredPrefix));</span>
            }
        }
<span class="fc" id="L86">        return paramPrefixToOperator.get(prefix).map(operator -&gt; Validation.&lt;Issues, Constraint&gt;valid(operator))</span>
<span class="fc" id="L87">                .getOrElse(invalid(notSupportedPrefix(message, prefix.getValue())));</span>
    }

    private String identifyMatchingOriginalValue(NamedParam&lt;DateParam&gt; param) {
<span class="fc" id="L91">        List&lt;String&gt; originalValues = param.getOriginalValues();</span>

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (originalValues.size() == 1) {</span>
<span class="fc" id="L94">            return originalValues.get(0);</span>
        }
<span class="nc" id="L96">        return originalValues</span>
<span class="nc" id="L97">                .filter(originalValue -&gt; StringUtils.contains(originalValue, param.getParam().getValueAsString()))</span>
<span class="nc" id="L98">                .headOption()</span>
<span class="nc" id="L99">                .getOrElseThrow(() -&gt; new IllegalArgumentException(</span>
<span class="nc" id="L100">                        format(&quot;Unable to find the original value of the param [%s] = (prefix: %s,value: %s) so that the validation could be completed. [%s] have been sent.&quot;,</span>
<span class="nc" id="L101">                                param.getName(),</span>
<span class="nc" id="L102">                                param.getParam().getPrefix(),</span>
<span class="nc" id="L103">                                param.getParam().getValueAsString(),</span>
<span class="nc" id="L104">                                String.join(&quot;,&quot;, originalValues))));</span>
    }

    private Validation&lt;Issues, LocalDate&gt; toLocalDate(DateParam dateParam) {
<span class="fc" id="L108">        Issues issues = checkDatePrecision(dateParam);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (issues.isEmpty()) {</span>
            // HALF_DAYS solves 23:59:59:999 (day before) &lt;-&gt; 00:00:00:00 (expected day) issue.
<span class="fc" id="L111">            return valid(Instant.ofEpochMilli(dateParam.getValue().getTime())</span>
<span class="fc" id="L112">                    .atOffset(ZoneOffset.UTC)</span>
<span class="fc" id="L113">                    .plus(1, ChronoUnit.HALF_DAYS)</span>
<span class="fc" id="L114">                    .toLocalDate());</span>
        } else {
<span class="fc" id="L116">            return invalid(issues);</span>
        }
    }

    private Issues checkDatePrecision(DateParam date) {
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (date.getPrecision() != TemporalPrecisionEnum.DAY) {</span>
<span class="fc" id="L122">            return Issues.issueFrom(&quot;Please provide a date in the format yyyy-mm-dd (time information not supported).&quot;, ERROR);</span>
        }
<span class="fc" id="L124">        return Issues.empty();</span>
    }

    private Issues notSupportedPrefix(String formatableMessage, String prefix) {
<span class="fc" id="L128">        return Issues.errorFrom(format(formatableMessage, prefix));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>