<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccountSecretKey.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.tolven.security.key</a> &gt; <span class="el_source">AccountSecretKey.java</span></div><h1>AccountSecretKey.java</h1><pre class="source lang-java linenums">/*
 *  Copyright (C) 2006 Tolven Inc 
 *
 * This library is free software; you can redistribute it and/or modify it under the terms of 
 * the GNU Lesser General Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 * See the GNU Lesser General Public License for more details.
 * 
 * Contact: info@tolvenhealth.com
 */
package org.tolven.security.key;

import com.pkb.crypto.javasecurityutil.KeyUtil;
import com.pkb.crypto.util.RandomUtil;
import com.pkb.util.Base64Util;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.persistence.Column;
import javax.persistence.Embeddable;
import java.io.Serializable;
import java.security.GeneralSecurityException;
import java.security.PrivateKey;
import java.security.PublicKey;

/**
 * This class encapsulates a SecretKey which has been encrypted using a
 * PublicKey during initialization. To obtain the unencrypted SecretKey, the
 * PrivateKey companion of the encrypting PublicKey must be supplied.
 *
 * NEW FLOW: this class can also hold details to derive the SecretKey from a
 * random access token.
 *
 * We can't just extend Tolven's version, because Hibernate doesn't handle storage properly; so we're replacing it with a similar (but more
 * flexible) impl.
 *
 * The orig supports storing:
 * - the account private key, encrypted with a random secret key
 * - the secret key stored encrypted with a UserPublicKey
 * and forces you to copy from an existing, encrypted/encoded AccountPrivateKey to pass to a new user.
 *
 * This version supports two simpler init methods, so that we can store as above, OR:
 * - the account private key, encrypted with a GIVEN secret key
 * - the secret key not stored
 * Plus we can more easily save new versions for selected users, given the decrypted acct private key (no copy forced).
 * 
 * @author Joseph Isaac
 * @author Rob Whelan
 */
@Embeddable
public class AccountSecretKey implements Serializable {
    private static final long serialVersionUID = 3L;

    public static final int ACCESS_TOKEN_LENGTH = 16;

    @Column(name = &quot;encrypted_secret_key_inline&quot;)
    private byte[] encryptedKeyInline;

    @Column(name = &quot;secret_key_algorithm&quot;)
    private String algorithm;

    @Column(name = &quot;secret_key_deriv_algorithm&quot;)
    private String secretKeyDerivAlgorithm;

    @Column(name = &quot;secret_key_deriv_data_length&quot;)
    private Integer secretKeyDerivDataLength;

    @Column(name = &quot;secret_key_deriv_salt_inline&quot;)
    private byte[] secretKeyDerivationSaltInline;

    @Column(name = &quot;secret_key_deriv_iterations&quot;)
    private Integer secretKeyDerivIterations;

    // NEW FLOW: need more properties...

    private AccountSecretKey() {
    }

    /**
     * Return an instance of AccountSecretKey
     */
    public static AccountSecretKey getInstance() {
<span class="fc" id="L86">        return new AccountSecretKey();</span>
    }

    /**
     * Encrypt a SecretKey using a PublicKey
     */
    public SecretKey init(PublicKey aPublicKey, String kbeKeyAlgorithm, int kbeKeyLength) throws GeneralSecurityException {
        // The initialization check seems to belong in the superclass, but it's abstract?
<span class="pc bpc" id="L94" title="2 of 4 branches missed.">        if (getEncryptedKey() != null || getAlgorithm() != null) {</span>
<span class="nc" id="L95">            throw new IllegalStateException(getClass() + &quot; already initialized&quot;);</span>
        }

<span class="fc" id="L98">        SecretKey secretKey = KeyUtil.generateSecretKey(kbeKeyAlgorithm, kbeKeyLength);</span>
<span class="fc" id="L99">        setEncryptedKey(KeyUtil.encryptSecretKeyWithPublicKey(secretKey, aPublicKey));</span>
<span class="fc" id="L100">        setAlgorithm(secretKey.getAlgorithm());</span>

<span class="fc" id="L102">        return secretKey;</span>
    }

    /**
     * NEW FLOW! Wrap up a pre-generated SecretKey (derived from an access code), and return it (not encrypted with a PublicKey).
     * DO NOT STORE the secret key for this flow.
     */
    public SecretKey init(String kbeKeyAlgorithm, String accessToken,
                          String secretKeyDerivAlgorithm, int secretKeyDerivDataLength, int secretKeyDerivSaltLength,
                          int secretKeyDerivIterations) throws GeneralSecurityException {
<span class="nc" id="L112">        return init(kbeKeyAlgorithm, accessToken, secretKeyDerivAlgorithm, secretKeyDerivDataLength, secretKeyDerivIterations,</span>
<span class="nc" id="L113">                RandomUtil.randomBytes(secretKeyDerivSaltLength));</span>
    }

    public SecretKey init(String kbeKeyAlgorithm, String accessToken,
                          String secretKeyDerivAlgorithm, int secretKeyDerivDataLength,
                          int secretKeyDerivIterations, byte[] keyDerivSalt) throws GeneralSecurityException {
        // The initialization check seems to belong in the superclass, but it's abstract?
<span class="pc bpc" id="L120" title="2 of 4 branches missed.">        if ((getEncryptedKey() != null) || (getAlgorithm() != null)) {</span>
<span class="nc" id="L121">            throw new IllegalStateException(getClass() + &quot; already initialized&quot;);</span>
        }

<span class="fc" id="L124">        SecretKey derivedKey = KeyUtil.deriveSecretKey(</span>
                secretKeyDerivAlgorithm,
<span class="fc" id="L126">                accessToken.toCharArray(),</span>
                keyDerivSalt,
                secretKeyDerivIterations,
                secretKeyDerivDataLength);

<span class="fc" id="L131">        SecretKey secretKey = new SecretKeySpec(derivedKey.getEncoded(), kbeKeyAlgorithm);</span>
<span class="fc" id="L132">        setEncryptedKey(null);</span>
<span class="fc" id="L133">        setAlgorithm(secretKey.getAlgorithm());</span>
<span class="fc" id="L134">        setKeyDerivationSpec(secretKeyDerivAlgorithm, secretKeyDerivDataLength, keyDerivSalt, secretKeyDerivIterations);</span>

<span class="fc" id="L136">        return secretKey;</span>
    }

    /**
     * Derive the key from the access token, plus stored key derivation spec (including algo, salt, iterations)
     */
    SecretKey getSecretKey(String accessToken) throws GeneralSecurityException {
<span class="fc" id="L143">        byte[] clearKeyBytes = null;</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (secretKeyDerivAlgorithm == null) {</span>
            // historical: old invitation that used the actual key as base64
<span class="nc" id="L146">            clearKeyBytes = Base64Util.decode(accessToken);</span>
        } else {
<span class="fc" id="L148">            SecretKey derivedKey = KeyUtil.deriveSecretKey(</span>
                    secretKeyDerivAlgorithm,
<span class="fc" id="L150">                    accessToken.toCharArray(),</span>
                    secretKeyDerivationSaltInline,
<span class="fc" id="L152">                    secretKeyDerivIterations,</span>
<span class="fc" id="L153">                    secretKeyDerivDataLength);</span>

<span class="fc" id="L155">            clearKeyBytes = derivedKey.getEncoded();</span>
        }

<span class="fc" id="L158">        return getSecretKey(clearKeyBytes);</span>
    }

    private void setKeyDerivationSpec(String secretKeyDerivAlgorithm, int secretKeyDerivDataLength,
                                        byte[] secretKeyDerivationSalt, int secretKeyDerivIterations) {
<span class="fc" id="L163">        this.secretKeyDerivAlgorithm = secretKeyDerivAlgorithm;</span>
<span class="fc" id="L164">        this.secretKeyDerivDataLength = secretKeyDerivDataLength;</span>
<span class="fc" id="L165">        this.secretKeyDerivationSaltInline = secretKeyDerivationSalt;</span>
<span class="fc" id="L166">        this.secretKeyDerivIterations = secretKeyDerivIterations;</span>
<span class="fc" id="L167">    }</span>


    /**
     * NEW FLOW: wrap the SecretKey given the stored algorithm and the cleartext bytes of the secret
     */
    private SecretKey getSecretKey(byte[] clearKeyBytes) {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (getAlgorithm() == null) {</span>
<span class="nc" id="L175">            throw new IllegalStateException(getClass() + &quot; not initialized&quot;);</span>
        }

<span class="fc" id="L178">        return new SecretKeySpec(clearKeyBytes, getAlgorithm());</span>
    }

    /**
     * Decrypt the SecretKey using a PrivateKey and return it
     */
    SecretKey getSecretKey(PrivateKey aDecryptionPrivateKey) throws GeneralSecurityException {
<span class="nc bnc" id="L185" title="All 4 branches missed.">        if ((getEncryptedKey() == null) || (algorithm == null)) {</span>
<span class="nc" id="L186">            throw new IllegalStateException(getClass() + &quot; not initialized&quot;);</span>
        }

        try {
<span class="nc" id="L190">            return KeyUtil.decryptSecretKeyWithPrivateKey(getEncryptedKey(), algorithm, aDecryptionPrivateKey);</span>
<span class="nc" id="L191">        } catch (Exception ex) {</span>
<span class="nc" id="L192">            throw new RuntimeException(&quot;Failed to decrypt &quot; + getClass().getName() + &quot; with a PrivateKey&quot;, ex);</span>
        }
    }

    public byte[] getEncryptedKey() {
<span class="fc" id="L197">        return encryptedKeyInline;</span>
    }

    private void setEncryptedKey(byte[] array) {
<span class="fc" id="L201">        encryptedKeyInline = array;</span>
<span class="fc" id="L202">    }</span>

    /**
     * Return the algorithm of the encrypted SecretKey
     */
    public String getAlgorithm() {
<span class="fc" id="L208">        return algorithm;</span>
    }

    private void setAlgorithm(String aString) {
<span class="fc" id="L212">        algorithm = aString;</span>
<span class="fc" id="L213">    }</span>

    public String getSecretKeyDerivAlgorithm() {
<span class="fc" id="L216">        return secretKeyDerivAlgorithm;</span>
    }

    private void setSecretKeyDerivAlgorithm(String secretKeyDerivAlgorithm) {
<span class="nc" id="L220">        this.secretKeyDerivAlgorithm = secretKeyDerivAlgorithm;</span>
<span class="nc" id="L221">    }</span>

    public Integer getSecretKeyDerivDataLength() {
<span class="fc" id="L224">        return secretKeyDerivDataLength;</span>
    }

    private void setSecretKeyDerivDataLength(Integer secretKeyDerivDataLength) {
<span class="nc" id="L228">        this.secretKeyDerivDataLength = secretKeyDerivDataLength;</span>
<span class="nc" id="L229">    }</span>

    public byte[] getSecretKeyDerivationSalt() {
<span class="fc" id="L232">        return secretKeyDerivationSaltInline;</span>
    }

    private void setSecretKeyDerivationSalt(byte[] secretKeyDerivationSalt) {
<span class="nc" id="L236">        this.secretKeyDerivationSaltInline = secretKeyDerivationSalt;</span>
<span class="nc" id="L237">    }</span>

    public Integer getSecretKeyDerivIterations() {
<span class="fc" id="L240">        return secretKeyDerivIterations;</span>
    }

    private void setSecretKeyDerivIterations(Integer secretKeyDerivIterations) {
<span class="nc" id="L244">        this.secretKeyDerivIterations = secretKeyDerivIterations;</span>
<span class="nc" id="L245">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>