<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedirectMessageInterceptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.interceptor</a> &gt; <span class="el_source">RedirectMessageInterceptor.java</span></div><h1>RedirectMessageInterceptor.java</h1><pre class="source lang-java linenums">package com.pkb.interceptor;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.inject.Inject;
import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;
import com.opensymphony.xwork2.interceptor.ValidationAware;
import org.apache.struts2.result.ServletRedirectResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;


/**
 * Research: how different from MessageStoreInterceptor in AUTOMATIC mode?
 * That one will automatically show the &quot;input&quot; result (SKIPPING the action) if
 * there are any errors. This one will execute normally (hides the messages
 * until after the action has run)
 *
 * An Interceptor to preserve an actions ValidationAware messages across a
 * redirect result.
 *
 * It makes the assumption that you always want to preserve messages across a
 * redirect and restore them to the next action if they exist.
 *
 * The way this works is it looks at the result type after a action has executed
 * and if the result was a redirect (ServletRedirectResult) or a redirectAction
 * (ServletActionRedirectResult) and there were any errors, messages, or
 * fieldErrors they are stored in the session. Before the next action executes
 * it will check if there are any messages stored in the session and add them to
 * the next action.
 *
 * IMPORTANT, from the blog notes:
 * The one thing you need to be aware of is: The action you are redirecting towards
 * will need to configure a result with name=&quot;input&quot; as the added messages will
 * trigger the 'workflow' interceptor to return a result of &quot;input&quot;.
 * This doesn't seem to be true in my tests so far -- maybe only if validation is enabled
 * for the action, or for an earlier version of Struts?
 * UPDATE: this DOES happen if there are ActionErrors -- not ActionMessages.
 * Anyway, if we DO see this, a possible fix would be to use a filter (rather than an
 * interceptor...) to re-add the errors &amp; messages AFTER the action execution, BEFORE
 * the JSP execution (but I'd rather stay within the Struts ecosystem if possible...)
 *
 * Solution: see PreResultListener - this will work!
 * Timing is a bit delicate.
 * Action1:
 * BEFORE execution: no session messages found.
 * AFTER execution (or bypassed execution due to validation errors!):
 * find messages, see redirect-type result, put messages in session
 * Action2:
 * BEFORE execution: find session messages, remove &amp; schedule to re-add PreResult.
 * AFTER execution: re-add messages, then process as above (not redirect result, so leave messages to display)
 *
 * Need to test how this is triggered when validation bypasses execution -- should handle
 * that case as well, so we can do redirect-type input results if desired.
 * Reading code... looks like this interceptor must be placed BEFORE the DefaultWorkflowInterceptor
 * otherwise that will cut short execution (and just return the input result) instead of letting other
 * interceptors proceed. But if this executes before that we're fine (the PreResultListener
 * will be triggered at the right time even though execute() was skipped).
 *
 * Logic run-through:
 * BEFORE execute():
 * do nothing
 * AFTER execute() (in PreResultListener):
 * if result type is redirect
 * merge any real messages into session messages (and remove)
 * if result type is NOT redirect
 * merge any session messages into real messages (and remove)
 * AFTER result is done:
 * do nothing
 */
<span class="fc" id="L78">public class RedirectMessageInterceptor extends MethodFilterInterceptor {</span>
    private static final long serialVersionUID = -1847557437429753540L;

    private static final String FIELD_ERRORS_KEY = &quot;RedirectMessageInterceptor_FieldErrors&quot;;
    private static final String ACTION_ERRORS_KEY = &quot;RedirectMessageInterceptor_ActionErrors&quot;;
    private static final String ACTION_MESSAGES_KEY = &quot;RedirectMessageInterceptor_ActionMessages&quot;;

<span class="fc" id="L85">    private static final Logger LOGGER = LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());</span>

    private ObjectFactory objectFactory;

    @Override
    public String doIntercept(ActionInvocation invocation) throws Exception {
<span class="fc" id="L91">        Object action = invocation.getAction();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (action instanceof ValidationAware) {</span>
<span class="fc" id="L93">            LOGGER.trace(&quot;before call into {}&quot;, action);</span>

            // execute this before handling the result
<span class="fc" id="L96">            invocation.addPreResultListener((invocation1, resultCode) -&gt; {</span>
<span class="fc" id="L97">                LOGGER.debug(&quot;Handling messages in PreResultListener: {}&quot;, resultCode);</span>
                try {
<span class="fc" id="L99">                    ValidationAware action1 = (ValidationAware) invocation1.getAction();</span>

                    // need to get the actual class to be used by the result, to also catch custom subclasses
<span class="fc" id="L102">                    Result result = null;</span>
<span class="fc" id="L103">                    Map&lt;String, ResultConfig&gt; results = invocation1.getProxy().getConfig().getResults();</span>
<span class="fc" id="L104">                    ResultConfig resultConfig = results.get(resultCode);</span>
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">                    if ((resultConfig != null) &amp;&amp; (resultConfig.getClassName() != null)) {</span>
<span class="fc" id="L106">                        result = (Result) objectFactory.buildBean(resultConfig.getClassName(), null, false);</span>
                    }

                    // get session (if valid)
<span class="fc" id="L110">                    Map&lt;String, Object&gt; session = invocation1.getInvocationContext().getSession();</span>
                    try {
<span class="fc" id="L112">                        session.containsKey(&quot;test&quot;);</span>
<span class="nc" id="L113">                    } catch (IllegalStateException e) {</span>
<span class="nc" id="L114">                        LOGGER.warn(&quot;can't access session; normal if it's invalidated.&quot;, e);</span>
<span class="nc" id="L115">                        return;</span>
<span class="fc" id="L116">                    }</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">                    if ((result instanceof ServletRedirectResult)) {</span>
                        // ActionChainResult seems to stil have the same action context, so don't treat as redirect

<span class="fc" id="L121">                        LOGGER.debug(&quot;found redirect result: {}; merging messages to session&quot;, result);</span>
                        // result type is REDIRECT:
                        // merge any real messages into session messages (and remove)
<span class="fc" id="L124">                        mergeCurrentMessagesToSession(session, action1);</span>
                    } else {
<span class="fc" id="L126">                        LOGGER.debug(&quot;NOT a redirect result: {}; fetching session messages back to action&quot;, result);</span>
                        // NOT a redirect result:
                        // merge any session messages into real messages (and remove)
<span class="fc" id="L129">                        mergeSessionMessagesToCurrent(session, action1);</span>
                    }

<span class="nc" id="L132">                } catch (Exception e) {</span>
<span class="nc" id="L133">                    LOGGER.error(&quot;non-fatal: error in RedirectMessageInterceptor with result {} to action {}&quot;,</span>
<span class="nc" id="L134">                            resultCode, invocation1.getAction().getClass(), e);</span>
                    // DO NOT rethrow; this is not essential processing
<span class="fc" id="L136">                }</span>
<span class="fc" id="L137">            });</span>
        } else {
<span class="fc" id="L139">            LOGGER.debug(&quot;not validation aware (no message processing): {}&quot;, action);</span>
        }

<span class="fc" id="L142">        LOGGER.debug(&quot;invoking action: {}&quot;, action);</span>
<span class="fc" id="L143">        String resultCode = invocation.invoke();</span>

<span class="fc" id="L145">        LOGGER.debug(&quot;result from {}: {}&quot;, action, resultCode);</span>

<span class="fc" id="L147">        return resultCode;</span>
    }

    /**
     * Store error and messages in the session (merge with messages already there).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static void mergeCurrentMessagesToSession(Map&lt;String, Object&gt; session, ValidationAware action) {
<span class="fc" id="L155">        Collection&lt;String&gt; actionErrors = action.getActionErrors();</span>
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">        if ((actionErrors != null) &amp;&amp; !actionErrors.isEmpty()) {</span>
<span class="fc" id="L157">            LOGGER.debug(&quot;SAVE actionErrors: {}&quot;, actionErrors.size());</span>

            // NOTE: can't use return value of put(); Struts doesn't obey the Map interface
<span class="fc" id="L160">            Collection&lt;String&gt; existingList = (Collection&lt;String&gt;) session.get(ACTION_ERRORS_KEY);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (existingList != null) {</span>
<span class="fc" id="L162">                actionErrors.addAll(existingList);</span>
            }
<span class="fc" id="L164">            session.put(ACTION_ERRORS_KEY, actionErrors);</span>
        }

<span class="fc" id="L167">        Collection&lt;String&gt; actionMessages = action.getActionMessages();</span>
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">        if ((actionMessages != null) &amp;&amp; !actionMessages.isEmpty()) {</span>
<span class="fc" id="L169">            LOGGER.debug(&quot;SAVE actionMessages: {}&quot;, actionMessages.size());</span>

            // NOTE: can't use return value of put(); Struts doesn't obey the Map interface
<span class="fc" id="L172">            Collection&lt;String&gt; existingList = (Collection&lt;String&gt;) session.get(ACTION_MESSAGES_KEY);</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            if (existingList != null) {</span>
<span class="nc" id="L174">                actionMessages.addAll(existingList);</span>
            }
<span class="fc" id="L176">            session.put(ACTION_MESSAGES_KEY, actionMessages);</span>
        }

<span class="fc" id="L179">        Map&lt;String, List&lt;String&gt;&gt; fieldErrors = action.getFieldErrors();</span>
<span class="pc bpc" id="L180" title="1 of 4 branches missed.">        if ((fieldErrors != null) &amp;&amp; !fieldErrors.isEmpty()) {</span>
<span class="fc" id="L181">            LOGGER.debug(&quot;SAVE fieldErrors: {}&quot;, fieldErrors.size());</span>

            // NOTE: can't use return value of put(); Struts doesn't obey the Map interface
<span class="fc" id="L184">            Map&lt;String, List&lt;String&gt;&gt; existingMap = (Map&lt;String, List&lt;String&gt;&gt;) session.get(FIELD_ERRORS_KEY);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (existingMap != null) {</span>
                // merges second into first
<span class="nc" id="L187">                mergeMaps(fieldErrors, existingMap);</span>
            }
<span class="fc" id="L189">            session.put(FIELD_ERRORS_KEY, fieldErrors);</span>
        }
<span class="fc" id="L191">    }</span>

    /**
     * Retrieve/remove the errors and messages from the session and add them to the
     * action.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static void mergeSessionMessagesToCurrent(Map&lt;String, Object&gt; session, ValidationAware action) {
        // Notice the side-effect: using session.remove instead of session.get

<span class="fc" id="L201">        Collection&lt;String&gt; mergedErrors = mergeCollections(</span>
<span class="fc" id="L202">                action.getActionErrors(),</span>
<span class="fc" id="L203">                (Collection&lt;String&gt;) session.remove(ACTION_ERRORS_KEY));</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">        if ((mergedErrors != null) &amp;&amp; !mergedErrors.isEmpty()) {</span>
<span class="fc" id="L205">            Collection&lt;String&gt; filteredMergedErrors = mergedErrors.stream()</span>
<span class="fc" id="L206">                    .distinct() // PHR-5152 - error chaining can result in same message propagated (filter duplicates)</span>
<span class="fc" id="L207">                    .collect(Collectors.toList());</span>
<span class="fc" id="L208">            LOGGER.debug(&quot;RESTORE actionErrors: {}; first {}&quot;, filteredMergedErrors.size(), filteredMergedErrors.iterator().next());</span>
<span class="fc" id="L209">            action.setActionErrors(filteredMergedErrors);</span>
        }

<span class="fc" id="L212">        Collection&lt;String&gt; mergedMessages = mergeCollections(</span>
<span class="fc" id="L213">                action.getActionMessages(),</span>
<span class="fc" id="L214">                (Collection&lt;String&gt;) session.remove(ACTION_MESSAGES_KEY));</span>
<span class="pc bpc" id="L215" title="1 of 4 branches missed.">        if ((mergedMessages != null) &amp;&amp; !mergedMessages.isEmpty()) {</span>
<span class="fc" id="L216">            LOGGER.debug(&quot;RESTORE actionMessages: {}&quot;, mergedMessages.size());</span>
<span class="fc" id="L217">            action.setActionMessages(mergedMessages);</span>
        }

<span class="fc" id="L220">        Map&lt;String, List&lt;String&gt;&gt; mergedFieldErrors = mergeMaps(</span>
<span class="fc" id="L221">                action.getFieldErrors(),</span>
<span class="fc" id="L222">                (Map&lt;String, List&lt;String&gt;&gt;) session.remove(FIELD_ERRORS_KEY));</span>
<span class="pc bpc" id="L223" title="1 of 4 branches missed.">        if ((mergedFieldErrors != null) &amp;&amp; !mergedFieldErrors.isEmpty()) {</span>
<span class="fc" id="L224">            LOGGER.debug(&quot;RESTORE fieldErrors: {}&quot;, mergedFieldErrors.size());</span>
<span class="fc" id="L225">            action.setFieldErrors(mergedFieldErrors);</span>
        }
<span class="fc" id="L227">    }</span>

    private static Collection&lt;String&gt; mergeCollections(Collection&lt;String&gt; first, Collection&lt;String&gt; second) {
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">        if ((first == null) || first.isEmpty()) {</span>
<span class="fc" id="L231">            return second;</span>
        }
<span class="pc bpc" id="L233" title="1 of 4 branches missed.">        if ((second == null) || second.isEmpty()) {</span>
<span class="fc" id="L234">            return first;</span>
        }

<span class="fc" id="L237">        first.addAll(second);</span>
<span class="fc" id="L238">        return first;</span>
    }

    private static Map&lt;String, List&lt;String&gt;&gt; mergeMaps(Map&lt;String, List&lt;String&gt;&gt; first, Map&lt;String, List&lt;String&gt;&gt; second) {
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">        if ((first == null) || first.isEmpty()) {</span>
<span class="fc" id="L243">            return second;</span>
        }
<span class="pc bpc" id="L245" title="3 of 4 branches missed.">        if ((second == null) || second.isEmpty()) {</span>
<span class="fc" id="L246">            return first;</span>
        }

<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; secondEntry : second.entrySet()) {</span>
<span class="nc" id="L250">            List&lt;String&gt; values = (List&lt;String&gt;) mergeCollections(first.get(secondEntry.getKey()), secondEntry.getValue());</span>
<span class="nc" id="L251">            first.put(secondEntry.getKey(), values);</span>
<span class="nc" id="L252">        }</span>
<span class="nc" id="L253">        return first;</span>
    }

    @Inject
    public void setObjectFactory(ObjectFactory objectFactory) {
<span class="fc" id="L258">        this.objectFactory = objectFactory;</span>
<span class="fc" id="L259">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>