<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InstituteUserManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">E2E Tests Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.pkb.service.instituteuser</a> &gt; <span class="el_source">InstituteUserManager.java</span></div><h1>InstituteUserManager.java</h1><pre class="source lang-java linenums">package com.pkb.service.instituteuser;

import com.google.common.collect.Lists;
import com.pkb.app.entity.EHRRequestContext;
import com.pkb.app.entity.LoggedInEHRRequestContext;
import com.pkb.common.config.PhrConfig;
import com.pkb.common.datetime.DateTimeService;
import com.pkb.consent.model.ConsentStatus;
import com.pkb.datamodel.Email;
import com.pkb.datamodel.consent.PatientConsentDTO;
import com.pkb.entities.enums.NationalIdType;
import com.pkb.entities.enums.SponsorshipStatus;
import com.pkb.entities.enums.UserStatus;
import com.pkb.entities.enums.UserType;
import com.pkb.entities.enums.ValidNationalId;
import com.pkb.institute.entity.InstituteUser;
import com.pkb.institute.entity.InstituteUserEntity;
import com.pkb.institute.entity.InstituteUserEntity.ContactOptions;
import com.pkb.institute.entity.Org;
import com.pkb.institute.entity.Team;
import com.pkb.institute.entity.TeamWithPKBPerson;
import com.pkb.repository.legacy.CustomizedLegacyInstituteUserRepository;
import com.pkb.repository.legacy.CustomizedLegacyInstituteUserRepositoryImpl;
import com.pkb.repository.legacy.LegacyAccountUserRepository;
import com.pkb.repository.legacy.LegacyIdentityVerificationRepository;
import com.pkb.repository.legacy.LegacyInstituteUserRepository;
import com.pkb.repository.legacy.LegacyPKBPersonRepository;
import com.pkb.repository.legacy.LegacyTeamRepository;
import com.pkb.service.uuid.UUIDProvider;
import com.pkb.user.entity.IdPair;
import com.pkb.user.entity.IdentityVerification;
import com.pkb.user.entity.PKBPerson;
import com.pkb.util.tolven.TolvenBeanFactory;
import com.pkb.util.tolven.TransactionManager;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.invoke.MethodHandles;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.pkb.repository.legacy.QuerySortOrder.SortOrderDirection.ASC;
import static com.pkb.repository.legacy.QuerySortOrder.SortOrderDirection.DESC;
import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;
import static java.util.Comparator.comparing;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;

public class InstituteUserManager extends TransactionManager {

    private static final int ASSIGNED_PATIENT_BATCH_SIZE = 10000;
<span class="fc" id="L81">    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

    private final LegacyInstituteUserRepository instituteUserRepository;
    private final LegacyPKBPersonRepository pkbPersonRepository;
    private final LegacyAccountUserRepository accountUserRepository;
    private final LegacyIdentityVerificationRepository identityVerificationRepository;
    private final LegacyPKBPersonRepository personRepository;
    private final LegacyTeamRepository teamRepository;

    public InstituteUserManager(PhrConfig config, TolvenBeanFactory beanFactory, DateTimeService dateTimeService, UUIDProvider uuidProvider,
                                LegacyInstituteUserRepository instituteUserRepository, LegacyPKBPersonRepository pkbPersonRepository,
                                LegacyAccountUserRepository accountUserRepository, LegacyIdentityVerificationRepository identityVerificationRepository,
                                LegacyPKBPersonRepository personRepository, LegacyTeamRepository teamRepository) {
<span class="fc" id="L94">        super(config, beanFactory, dateTimeService, uuidProvider);</span>
<span class="fc" id="L95">        this.instituteUserRepository = instituteUserRepository;</span>
<span class="fc" id="L96">        this.pkbPersonRepository = pkbPersonRepository;</span>
<span class="fc" id="L97">        this.accountUserRepository = accountUserRepository;</span>
<span class="fc" id="L98">        this.identityVerificationRepository = identityVerificationRepository;</span>
<span class="fc" id="L99">        this.personRepository = personRepository;</span>
<span class="fc" id="L100">        this.teamRepository = teamRepository;</span>
<span class="fc" id="L101">    }</span>

    public List&lt;InstituteUser&gt; getInstituteUsersForPersonStrictlyFiltered(LoggedInEHRRequestContext requestContext, Team.Lazy... fields) {
<span class="fc" id="L104">        List&lt;InstituteUser&gt; unfiltered = getInstituteUsersWithTeamFields(requestContext.getContextOrAccessingUserId(), fields);</span>
<span class="fc" id="L105">        return getInstituteUserListStrictlyFiltered(requestContext, unfiltered);</span>
    }

    private List&lt;InstituteUser&gt; getInstituteUsersWithTeamFields(Long personId, Team.Lazy... fields) {
<span class="fc" id="L109">        PKBPerson pkbPerson = beanFactory.getPKBPersonBean().findPKBPerson(personId).getOrNull();</span>

<span class="fc" id="L111">        List&lt;InstituteUserEntity&gt; instituteUserEntities = instituteUserRepository.getPatientIdsForDataUploadByOrgLevelId(personId, fields);</span>

<span class="fc" id="L113">        return instituteUserEntities.stream().map(instituteUser -&gt; transform(instituteUser, pkbPerson)).collect(toList());</span>
    }

    private InstituteUser transform(InstituteUserEntity entity, PKBPerson person) {
<span class="fc" id="L117">        InstituteUser result = null;</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (entity != null) {</span>
<span class="fc" id="L119">            result = new InstituteUser();</span>
<span class="fc" id="L120">            result.setSponsorshipStatus(entity.getSponsorshipStatus());</span>
<span class="fc" id="L121">            result.setInstitute(entity.getInstitute());</span>
<span class="fc" id="L122">            result.setPerson(person);</span>
<span class="fc" id="L123">            result.setUserType(entity.getUserType());</span>
<span class="fc" id="L124">            result.setContactable(entity.getContactable());</span>
<span class="fc" id="L125">            result.setStatusUpdatedOn(entity.getStatusUpdatedOn());</span>
<span class="fc" id="L126">            result.setId(entity.getId());</span>
        }
<span class="fc" id="L128">        return result;</span>
    }

    private List&lt;InstituteUser&gt; getInstituteUserListStrictlyFiltered(LoggedInEHRRequestContext requestContext, List&lt;InstituteUser&gt; instituteUsers) {

<span class="fc" id="L133">        ConsentStatus consentStatus = requestContext.getConsentStatus();</span>
<span class="fc" id="L134">        PatientConsentDTO consent = consentStatus.getConsent().orElse(null);</span>

<span class="fc" id="L136">        Iterator&lt;InstituteUser&gt; iterator = instituteUsers.iterator();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L138">            InstituteUser iu = iterator.next();</span>

            // If we have access via team consent, the current team is always included
            // in the results so don't remove it
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (EHRRequestContext.AccountLinkType.ORG == requestContext.getAccountLinkType()</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                    &amp;&amp; requestContext.getTeamId().map(teamId -&gt; iu.getInstitute().getId().equals(teamId)).orElse(false)) {</span>
<span class="fc" id="L144">                continue;</span>
            }

<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if (requestContext.isPiggyback()) {</span>
<span class="nc" id="L148">                continue;</span>
            }

<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (!consentStatus.isRequired()) {</span>
<span class="fc" id="L152">                continue;</span>
            }

<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (consentStatus.isBreakTheGlassActive()) {</span>
<span class="fc" id="L156">                continue;</span>
            }

<span class="fc bfc" id="L159" title="All 4 branches covered.">            if (consent == null || !consent.isEntityVisible(iu.getInstitute())) {</span>
<span class="fc" id="L160">                iterator.remove();</span>
            }
<span class="fc" id="L162">        }</span>
<span class="fc" id="L163">        return instituteUsers;</span>
    }

    public List&lt;InstituteUser&gt; getInstituteUsersForPerson(EHRRequestContext requestContext, Long personId, Team.Lazy... fields) {
<span class="fc" id="L167">        return getInstituteUserListFiltered(requestContext, getInstituteUsersWithTeamFields(personId, fields));</span>
    }

    private List&lt;InstituteUser&gt; getInstituteUserListFiltered(@NotNull EHRRequestContext requestContext, @NotNull List&lt;InstituteUser&gt; instituteUsers) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (!requestContext.getConsentStatus().isRequired()) {</span>
<span class="fc" id="L172">            return instituteUsers;</span>
        }

<span class="fc bfc" id="L175" title="All 2 branches covered.">        Predicate&lt;InstituteUser&gt; matchesCurrentTeam = requestContext.getAccountLinkType() == EHRRequestContext.AccountLinkType.ORG</span>
<span class="fc" id="L176">                ? iu -&gt; iu.getInstitute().getId().equals(requestContext.getTeamId().orElse(null))</span>
<span class="fc" id="L177">                : iu -&gt; false;</span>

<span class="fc" id="L179">        return requestContext.getConsentStatus().getConsent().map(consent -&gt; {</span>
<span class="fc" id="L180">            Predicate&lt;InstituteUser&gt; isVisibleByConsent = iu -&gt; consent.isEntityVisible(iu.getInstitute());</span>
<span class="fc" id="L181">            return instituteUsers.stream().filter(matchesCurrentTeam.or(isVisibleByConsent)).collect(Collectors.toList());</span>
<span class="fc" id="L182">        }).orElse(instituteUsers);</span>
    }

    public void createInstituteUser(long userId, Long teamId) {
<span class="fc" id="L186">        PKBPerson person = beanFactory.getPKBPersonBean().getPKBPerson(userId);</span>
<span class="fc" id="L187">        Team team = persistInstituteUser(teamId, person);</span>
        // update the organization details in PKBPerson table if clinician
<span class="fc" id="L189">        updateTeamDetails(person, team);</span>
<span class="fc" id="L190">    }</span>

    private void updateTeamDetails(PKBPerson person, Team team) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (person.isPro()) {</span>
<span class="fc" id="L194">            person.setOrganizationName(team.getOrg().getName());</span>
<span class="fc" id="L195">            person.setOrganizationUnit(team.getName());</span>
<span class="fc" id="L196">            pkbPersonRepository.saveAndFlush(person);</span>
        }
<span class="fc" id="L198">    }</span>

    private Team persistInstituteUser(Long teamId, PKBPerson person) {
<span class="fc" id="L201">        InstituteUserEntity instituteUser = new InstituteUserEntity();</span>
<span class="fc" id="L202">        Team team = teamRepository.getInstitute(teamId);</span>
        // abort if the teamId isn't valid
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (team == null) {</span>
<span class="nc" id="L205">            throw new NullPointerException(&quot;invalid teamId: &quot; + teamId);</span>
        }
<span class="fc" id="L207">        instituteUser.setInstitute(team);</span>
<span class="fc" id="L208">        instituteUser.setPersonId(person.getId());</span>
<span class="fc" id="L209">        instituteUser.setUserType(person.getUserType());</span>
<span class="fc" id="L210">        instituteUser.setSponsorshipStatus(SponsorshipStatus.INVITED);</span>
<span class="fc" id="L211">        instituteUser.setStatusUpdatedOn(dateTimeService.now());</span>
<span class="fc" id="L212">        instituteUserRepository.saveAndFlush(instituteUser);</span>
<span class="fc" id="L213">        return team;</span>
    }

    private Map&lt;Long, Instant&gt; getIdToAccountCreationMap(List&lt;Long&gt; personIds) {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (isEmpty(personIds)) {</span>
<span class="nc" id="L218">            return emptyMap();</span>
        }
<span class="fc" id="L220">        List&lt;Object[]&gt; idAndDateList = accountUserRepository.getActiveDefaultAccountUsersForPersonIds(personIds);</span>

        // Get the last login &amp; account creation date for each user
<span class="fc" id="L223">        return idAndDateList.stream()</span>
<span class="fc" id="L224">                .collect(toMap(idAndDate -&gt; (Long) idAndDate[0], idAndDate -&gt; ((Timestamp) idAndDate[1]).toInstant()));</span>
    }

    public void updateStatus(Long teamId, long userId,
                             SponsorshipStatus sponsorshipStatus) {
<span class="fc" id="L229">        InstituteUserEntity instituteUser = getInstituteUserEntity(teamId, userId);</span>
<span class="fc" id="L230">        instituteUser.setSponsorshipStatus(sponsorshipStatus);</span>
<span class="fc" id="L231">        instituteUser.setStatusUpdatedOn(dateTimeService.now());</span>
<span class="fc" id="L232">        instituteUserRepository.saveAndFlush(instituteUser);</span>
<span class="fc" id="L233">    }</span>

    public void updateContactOptions(Long teamId, long userId,
                                     ContactOptions contactOptions) {
<span class="fc" id="L237">            InstituteUserEntity instituteUser = getInstituteUserEntity(teamId, userId);</span>
<span class="fc" id="L238">            instituteUser.setContactable(contactOptions);</span>
<span class="fc" id="L239">        instituteUserRepository.saveAndFlush(instituteUser);</span>
<span class="fc" id="L240">    }</span>

    public List&lt;PKBPerson&gt; getTeamPatientsForDataUpload(Team team,
                                                        @Nullable ZonedDateTime filterStartDate,
                                                        @Nullable ZonedDateTime filterEndDate,
                                                        String filterPatientId, boolean localIdFlag,
                                                        boolean patientsWithIdsOnly,
                                                        EnumSet&lt;CustomizedLegacyInstituteUserRepository.DataUploadOption&gt; options) {
<span class="fc" id="L248">        Org nullOrg = null;</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (!patientsWithIdsOnly) {</span>
<span class="fc" id="L251">            return fetchPatientsForDataUploadNoIdFilters(team, options);</span>
        }

        // if we are filtering on a national or org-level ID, call just that
        // part
<span class="pc bpc" id="L256" title="3 of 4 branches missed.">        if (StringUtils.isNotBlank(filterPatientId) &amp;&amp; (!localIdFlag)) {</span>
            // filter on national ID
<span class="nc" id="L258">            return fetchPatientsForDataUploadByNationalId(nullOrg, team, filterStartDate,</span>
                    filterEndDate, filterPatientId);
<span class="pc bpc" id="L260" title="3 of 4 branches missed.">        } else if (StringUtils.isNotBlank(filterPatientId) &amp;&amp; (localIdFlag)) {</span>
            // filter on team-level ID
<span class="nc" id="L262">            return fetchPatientsForDataUploadByTeamLevelId(team, filterStartDate, filterEndDate,</span>
                    filterPatientId);
        } else {
            // get all 3 relevant ID types and merge lists
<span class="fc" id="L266">            Set&lt;PKBPerson&gt; uniqueList = new HashSet&lt;&gt;();</span>
            // by national ID
<span class="fc" id="L268">            uniqueList.addAll(fetchPatientsForDataUploadByNationalId(nullOrg, team,</span>
                    filterStartDate, filterEndDate, null));
            // by org-level ID
<span class="fc" id="L271">            uniqueList.addAll(fetchPatientsForDataUploadByOrgLevelId(nullOrg, team,</span>
                    filterStartDate, filterEndDate, null));
            // by team-level ID
<span class="fc" id="L274">            uniqueList.addAll(fetchPatientsForDataUploadByTeamLevelId(team, filterStartDate,</span>
                    filterEndDate, null));

<span class="fc" id="L277">            List&lt;PKBPerson&gt; mergedList = new ArrayList&lt;&gt;(uniqueList);</span>
<span class="fc" id="L278">            mergedList.sort(comparing((PKBPerson o) -&gt; StringUtils.trimToEmpty(o.getLastName()))</span>
<span class="fc" id="L279">                    .thenComparing(o -&gt; StringUtils.trimToEmpty(o.getFirstName())).thenComparing(PKBPerson::getDateOfBirthString));</span>
<span class="fc" id="L280">            return mergedList;</span>
        }
    }

    /**
     * Logic: the patient may have two relevant IDs and dates to filter by. If
     * either matches we return the patients (but force unique). 3 sub-methods -
     * to get when patientsWithIdsOnly = false (simple) - to get patients based
     * on national ID - to get patients based on org-level ID
     */
    public List&lt;PKBPerson&gt; getOrgPatientsForDataUpload(Org org,
                                                       ZonedDateTime filterStartDate, ZonedDateTime filterEndDate,
                                                       String filterPatientId, boolean localIdFlag,
                                                       boolean patientsWithIdsOnly) {
<span class="fc" id="L294">        Team nullTeam = null;</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (!patientsWithIdsOnly) {</span>
<span class="fc" id="L297">            return fetchPatientsForDataUploadNoIdFilters(org);</span>
        }

        // if we are filtering on a national or org-level ID, call just that
        // part
<span class="fc bfc" id="L302" title="All 4 branches covered.">        if (StringUtils.isNotBlank(filterPatientId) &amp;&amp; (!localIdFlag)) {</span>
            // filter on national ID
<span class="fc" id="L304">            return fetchPatientsForDataUploadByNationalId(org, nullTeam, filterStartDate,</span>
                    filterEndDate, filterPatientId);
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">        } else if (StringUtils.isNotBlank(filterPatientId) &amp;&amp; (localIdFlag)) {</span>
            // filter on org-level ID
<span class="fc" id="L308">            return fetchPatientsForDataUploadByOrgLevelId(org, nullTeam, filterStartDate,</span>
                    filterEndDate, filterPatientId);
        } else {
            // get both and merge lists
<span class="fc" id="L312">            Set&lt;PKBPerson&gt; uniqueList = new HashSet&lt;&gt;();</span>
            // by national ID
<span class="fc" id="L314">            uniqueList.addAll(fetchPatientsForDataUploadByNationalId(org, nullTeam,</span>
                    filterStartDate, filterEndDate, null));
            // by org-level ID
<span class="fc" id="L317">            uniqueList.addAll(fetchPatientsForDataUploadByOrgLevelId(org, nullTeam,</span>
                    filterStartDate, filterEndDate, null));

<span class="fc" id="L320">            List&lt;PKBPerson&gt; mergedList = new ArrayList&lt;&gt;(uniqueList);</span>
<span class="fc" id="L321">            mergedList.sort((o1, o2) -&gt; {</span>
<span class="fc" id="L322">                String name1 = o1.getLastName() + &quot;,&quot; + o1.getFirstName();</span>
<span class="fc" id="L323">                String name2 = o2.getLastName() + &quot;,&quot; + o2.getFirstName();</span>
<span class="fc" id="L324">                return name1.compareTo(name2);</span>
            });
<span class="fc" id="L326">            return mergedList;</span>
        }
    }

    private List&lt;PKBPerson&gt; fetchPatientsForDataUploadNoIdFilters(Org org) {

<span class="fc" id="L332">        List&lt;Long&gt; personIds = instituteUserRepository.findPersonIdsByOrgIdAndSponshorshipStatus(org.getId(), SponsorshipStatus.ACTIVE);</span>

<span class="fc" id="L334">            return personRepository.findPKBPersonListByUserTypeOrderedByLastAndFirstNameAndIdAsc(</span>
<span class="fc" id="L335">                    personIds, Collections.singletonList(UserType.PATIENT),</span>
                    PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS_DEEP);

    }

    private List&lt;PKBPerson&gt; fetchPatientsForDataUploadNoIdFilters(Team team, EnumSet&lt;CustomizedLegacyInstituteUserRepository.DataUploadOption&gt; options) {

<span class="fc" id="L342">        List&lt;Long&gt; personIds = instituteUserRepository.fetchPatientIdsForDataUploadNoIdFilters(team.getId(), options);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            if (options.contains(CustomizedLegacyInstituteUserRepository.DataUploadOption.ExcludeDeceased)) {</span>
<span class="nc" id="L344">                return personRepository.findPKBPersonListByUserTypeAndStatusNotInOrderedByLastNameAndFirstNameAndId(personIds, Collections.singletonList(UserType.PATIENT),</span>
<span class="nc" id="L345">                        Collections.singletonList(UserStatus.DEAD),</span>
                        0,0,
                        ASC,
                        PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);
            } else {
<span class="fc" id="L350">                return personRepository.findPKBPersonListByUserTypeOrderedByLastAndFirstNameAndIdAsc(personIds, Collections.singletonList(UserType.PATIENT),</span>
                        PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);
            }
    }

    public List&lt;IdPair&gt; getActivePatientIds(Team team) {
<span class="fc" id="L356">        List&lt;Long&gt; patientIds = instituteUserRepository.findActivePatientIds(team.getId());</span>
<span class="fc" id="L357">        return personRepository.findActivePatients(patientIds).stream().map(person -&gt; new IdPair(person.getId(), person.getPublicId())).collect(Collectors.toList());</span>
    }

    /**
     * assume org OR team is provided, not both (or neither)
     */
    private List&lt;PKBPerson&gt; fetchPatientsForDataUploadByNationalId(Org org,
                                                                   Team team,
                                                                   @Nullable ZonedDateTime filterStartDate,
                                                                   @Nullable ZonedDateTime filterEndDate,
                                                                   String filterNationalId) {
        Optional&lt;NationalIdType&gt; maybeNationalIdType;
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (team != null) {</span>
<span class="fc" id="L370">            maybeNationalIdType = NationalIdType.getPrimaryNationalIdTypeFromCountryCode(team.getCountry());</span>
        } else {
<span class="fc" id="L372">            Team firstTeam = org.getTeams().iterator().next();</span>
<span class="fc" id="L373">            maybeNationalIdType = NationalIdType.getPrimaryNationalIdTypeFromCountryCode(firstTeam.getCountry());</span>
        }

<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (maybeNationalIdType.isEmpty()) {</span>
            // no national ID for this country -- empty list
<span class="nc" id="L378">            return new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L381">        Optional&lt;ValidNationalId&gt; maybeValidNationalId = maybeNationalIdType.flatMap(nidt -&gt; nidt.getValidNationalIdAndType(filterNationalId));</span>

<span class="fc bfc" id="L383" title="All 4 branches covered.">        if (maybeValidNationalId.isEmpty() &amp;&amp; StringUtils.isNotBlank(filterNationalId)) {</span>
<span class="fc" id="L384">            return new ArrayList&lt;&gt;();</span>
        } else {
<span class="fc" id="L386">            List&lt;Long&gt; personIds = instituteUserRepository.findPersonIdsForTeamOrOrg(team, org);</span>

<span class="fc" id="L388">            NationalIdType searchType = maybeValidNationalId.map(ValidNationalId::type).orElse(maybeNationalIdType.get());</span>

<span class="fc" id="L390">            List&lt;PKBPerson&gt; result = personRepository.findPatientsByNationalId(personIds, filterStartDate, filterEndDate,</span>
<span class="fc" id="L391">                    maybeValidNationalId.map(ValidNationalId::value).orElse(null), searchType);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            result.forEach(person -&gt; person.getNationalIds().removeIf(nid -&gt; nid.getType() != searchType));</span>
<span class="fc" id="L393">            return result;</span>
        }
    }

    /**
     * assume org OR team is provided, not both (or neither)
     */
    private List&lt;PKBPerson&gt; fetchPatientsForDataUploadByOrgLevelId(Org org,
                                                                   Team team,
                                                                   @Nullable ZonedDateTime filterStartDate,
                                                                   @Nullable ZonedDateTime filterEndDate,
                                                                   String filterOrgLevelId) {

<span class="fc" id="L406">            List&lt;Long&gt; patientIdsForDataUploadByOrgLevelId = instituteUserRepository.getPatientIdsForDataUploadByOrgLevelId(</span>
                    team, org, filterStartDate, filterEndDate, filterOrgLevelId);

<span class="fc" id="L409">            return personRepository.findPKBPersonListByUserTypeOrderedByLastAndFirstNameAndIdAsc(</span>
<span class="fc" id="L410">                    patientIdsForDataUploadByOrgLevelId, Collections.singletonList(UserType.PATIENT),</span>
                    PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS_DEEP);

    }

    public List&lt;PKBPerson&gt; getPatientsForOrg(Long orgId, SponsorshipStatus[] statuses, PKBPerson.Lazy... fields) {

        // Default to all statuses loaded
<span class="nc bnc" id="L418" title="All 4 branches missed.">        if ((statuses == null) || (statuses.length == 0)) {</span>
<span class="nc" id="L419">            statuses = SponsorshipStatus.values();</span>
        }

<span class="nc" id="L422">        List&lt;Long&gt; personIds = instituteUserRepository.findPersonIdsForOrgAndSponsorshipStatuses(orgId, statuses);</span>

<span class="nc" id="L424">        return personRepository.findPKBPersonListByUserType(personIds, Collections.singletonList(UserType.PATIENT), fields);</span>
    }

    /**
     * assume team is not null
     */
    private List&lt;PKBPerson&gt; fetchPatientsForDataUploadByTeamLevelId(Team team,
                                                                    @Nullable ZonedDateTime filterStartDate,
                                                                    @Nullable ZonedDateTime filterEndDate,
                                                                    String filterTeamLevelId) {
<span class="fc" id="L434">        List&lt;Long&gt; patientIds = instituteUserRepository.fetchPatientIdsForDataUploadByTeamLevelId(team, filterStartDate, filterEndDate, filterTeamLevelId);</span>
<span class="fc" id="L435">        return personRepository.findPKBPersonListByUserTypeOrderedByLastAndFirstNameAndIdAsc(</span>
                patientIds,
<span class="fc" id="L437">                Collections.singletonList(UserType.PATIENT),</span>
                PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS);
    }

    @Nullable
    public InstituteUser getInstituteUser(Long teamId, long userId) {
<span class="fc" id="L443">        InstituteUserEntity instituteUserEntity = getInstituteUserEntity(teamId, userId);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">        return instituteUserEntity == null ? null : transform(instituteUserEntity, beanFactory.getPKBPersonBean().findPKBPerson(instituteUserEntity.getPersonId()).getOrNull());</span>
    }

    @Nullable
    public InstituteUser getInstituteUserWithInstitute(Long teamId, long userId) {
<span class="fc" id="L449">        InstituteUserEntity instituteUserEntity = getInstituteUserEntityWithIntitute(teamId, userId);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">        return instituteUserEntity == null ? null : transform(instituteUserEntity, beanFactory.getPKBPersonBean().findPKBPerson(instituteUserEntity.getPersonId()).getOrNull());</span>
    }

    @Nullable
    private InstituteUserEntity getInstituteUserEntity(Long teamId, long userId) {
<span class="fc" id="L455">        return instituteUserRepository.getInstituteUserEntity(teamId, userId);</span>
    }

    @Nullable
    private InstituteUserEntity getInstituteUserEntityWithIntitute(Long teamId, long userId) {
<span class="fc" id="L460">        return instituteUserRepository.getInstituteUserEntityWithInstitute(teamId, userId);</span>
    }

    public List&lt;InstituteUser&gt; getInstituteUsersByType(Long teamId, @NotNull UserType userType, int pageSize, int offset) {
<span class="fc" id="L464">        return getInstituteUsersByType(Collections.singleton(teamId), userType, EnumSet.complementOf(EnumSet.of(SponsorshipStatus.INACTIVE)), pageSize, offset);</span>
    }

    public List&lt;InstituteUser&gt; getInstituteUsersByType(Collection&lt;Long&gt; teamIds,
                                                       @NotNull UserType userType,
                                                       EnumSet&lt;SponsorshipStatus&gt; sponsorshipStatuses,
                                                       int pageSize,
                                                       int offset) {
<span class="pc bpc" id="L472" title="2 of 4 branches missed.">        if (isEmpty(teamIds) || isEmpty(sponsorshipStatuses)) {</span>
<span class="nc" id="L473">            return emptyList();</span>
        }

<span class="fc" id="L476">        List&lt;CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair&gt; institutePersonIds = instituteUserRepository.getInstitutePersonIdsByType(teamIds, userType, sponsorshipStatuses);</span>

<span class="fc" id="L478">        List&lt;PKBPerson&gt; pkbPersons = personRepository.findPKBPersonListByUserTypeOrderedByFirstAndLastNameAndIdAsc(</span>
<span class="fc" id="L479">                institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getPersonId).collect(Collectors.toSet()),</span>
<span class="fc" id="L480">                Set.of(userType),</span>
                pageSize,
                offset,
                PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS, PKBPerson.Lazy.CONTACTS);

<span class="fc" id="L485">        return getInstituteUsersWithPersonInfo(pkbPersons, institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getInstituteUserId).collect(toList()));</span>
    }

    private List&lt;InstituteUser&gt; getInstituteUsersWithPersonInfo(List&lt;PKBPerson&gt; sourcePersons, List&lt;Long&gt; instituteUserIds) {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (sourcePersons.isEmpty()) {</span>
<span class="fc" id="L490">            return emptyList();</span>
        } else {

<span class="fc" id="L493">            Map&lt;Long, List&lt;InstituteUserEntity&gt;&gt; instituteUserEntityMap = instituteUserRepository.getInstituteUserEntityMap(config, instituteUserIds);</span>

<span class="fc" id="L495">            return sourcePersons.stream().flatMap(person -&gt; instituteUserEntityMap.get(person.getId())</span>
<span class="fc" id="L496">                            .stream()</span>
<span class="fc" id="L497">                            .map(entity -&gt; transform(entity, person)))</span>
<span class="fc" id="L498">                    .collect(Collectors.toList());</span>
        }
    }

    public Map&lt;Long, List&lt;InstituteUser&gt;&gt; getInstituteUsersForPersonsFiltered(EHRRequestContext requestContext, Collection&lt;Long&gt; personIds) {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (isEmpty(personIds)) {</span>
<span class="nc" id="L504">            return emptyMap();</span>
        }
<span class="fc" id="L506">        List&lt;InstituteUser&gt; filteredInstitutes = getInstituteUserListFiltered(requestContext, queryInstituteUsers(personIds));</span>
<span class="fc" id="L507">        return filteredInstitutes.stream().collect(Collectors.groupingBy(iu -&gt; iu.getPerson().getId()));</span>
    }

    public List&lt;Long&gt; getInstituteIdsForPerson(Long personId) {
<span class="fc" id="L511">        return findInstituteIdsForPerson(personId);</span>
    }

    public List&lt;UUID&gt; getActiveTeamPublicIdsForPerson(Long personId) {
<span class="fc" id="L515">        return findActiveTeamPublicIdsForPerson(personId);</span>
    }

    public List&lt;InstituteUser&gt; getInstituteUsersForPerson(Long personId) {
<span class="fc" id="L519">        return getInstituteUsers(personId);</span>
    }

    public Map&lt;Long, List&lt;InstituteUser&gt;&gt; getInstituteUsersForPersons(Collection&lt;Long&gt; personIds) {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (isEmpty(personIds)) {</span>
<span class="nc" id="L524">            return emptyMap();</span>
        }
<span class="fc" id="L526">        return queryInstituteUsers(personIds).stream().collect(Collectors.groupingBy(iu -&gt; iu.getPerson().getId()));</span>
    }

    private List&lt;InstituteUser&gt; queryInstituteUsers(Collection&lt;Long&gt; personIds) {
<span class="fc" id="L530">        Map&lt;Long, PKBPerson&gt; pkbPersonMap = beanFactory.getPKBPersonBean().findPKBPersonMap(personIds);</span>

<span class="fc" id="L532">        return instituteUserRepository.findInstituteUsersForPersonIds(personIds).stream()</span>
<span class="fc" id="L533">                .map(instituteUser -&gt; transform(instituteUser, pkbPersonMap.get(instituteUser.getPersonId())))</span>
<span class="fc" id="L534">                .collect(Collectors.toList());</span>
    }

    private List&lt;InstituteUser&gt; getInstituteUsers(Long personId) {
<span class="fc" id="L538">        PKBPerson pkbPerson = beanFactory.getPKBPersonBean().findPKBPerson(personId).getOrNull();</span>
<span class="fc" id="L539">        List&lt;InstituteUserEntity&gt; returnValues = instituteUserRepository.getInstituteUserEntitiesForPerson(personId);</span>
<span class="fc" id="L540">        return returnValues.stream().map(instituteUser -&gt; transform(instituteUser, pkbPerson)).collect(Collectors.toList());</span>
    }

    private List&lt;UUID&gt; findActiveTeamPublicIdsForPerson(Long personId) {
<span class="fc" id="L544">        return instituteUserRepository.findActiveTeamPublicIdsForPerson(personId);</span>
    }

    private List&lt;Long&gt; findInstituteIdsForPerson(Long personId) {
<span class="fc" id="L548">        return instituteUserRepository.findInstituteIdsForPerson(personId);</span>
    }

    public List&lt;InstituteUser&gt; getInstituteAdminRecords(long personId) {
<span class="fc" id="L552">        PKBPerson pkbPerson = beanFactory.getPKBPersonBean().getPKBPerson(personId);</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (pkbPerson.isTeamCoordinator()) {</span>
<span class="fc" id="L554">            List&lt;InstituteUserEntity&gt; returnValue = instituteUserRepository.findInstituteUserEntitiesForPersonUnordered(personId);</span>
<span class="fc" id="L555">            return returnValue.stream().map(instituteUser -&gt; transform(instituteUser, pkbPerson)).collect(Collectors.toList());</span>
        } else {
<span class="nc" id="L557">            return Collections.emptyList();</span>
        }
    }

    public PKBPerson getSuperAdmin() {
<span class="nc" id="L562">        return personRepository.getSuperAdmin();</span>
    }

    public List&lt;PKBPerson&gt; getInstituteAdmin(String teamCode) {
<span class="fc" id="L566">        List&lt;Long&gt; instituteAdminIds = instituteUserRepository.getInstituteAdminIds(teamCode);</span>
<span class="fc" id="L567">        List&lt;PKBPerson&gt; adminList = beanFactory.getPKBPersonBean().findPKBPersonList(instituteAdminIds, PKBPerson.Lazy.CONTACTS);</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (adminList.isEmpty()) {</span>
<span class="nc" id="L569">            LOGGER.error(&quot;No result from getInstituteAdmin({})&quot;, teamCode);</span>
        }
<span class="fc" id="L571">        return adminList;</span>
    }

    /**
     * Get institute admin given team id
     */
    public List&lt;PKBPerson&gt; getInstituteAdmin(Long teamId) {
<span class="fc" id="L578">        List&lt;Long&gt; instituteAdminIdsForTeam = instituteUserRepository.getInstituteAdminIdsForTeam(teamId);</span>

<span class="fc" id="L580">        List&lt;PKBPerson&gt; adminList = beanFactory.getPKBPersonBean().findPKBPersonList(instituteAdminIdsForTeam, PKBPerson.Lazy.CONTACTS);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if (adminList.isEmpty()) {</span>
<span class="nc" id="L582">            LOGGER.error(&quot;No result from getInstituteAdmin({})&quot;, teamId);</span>
        }
<span class="fc" id="L584">        return adminList;</span>
    }

    /**
     * Get institute admin given team id
     */
    public List&lt;PKBPerson&gt; getActiveInstituteAdmin(Long teamId) {
<span class="fc" id="L591">        List&lt;Long&gt; activeInstituteAdminIdsForTeam = instituteUserRepository.getActiveInstituteAdminIdsForTeam(teamId);</span>

<span class="fc" id="L593">        List&lt;PKBPerson&gt; adminList = beanFactory.getPKBPersonBean().findPKBPersonList(activeInstituteAdminIdsForTeam, PKBPerson.Lazy.CONTACTS);</span>

<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (adminList.isEmpty()) {</span>
<span class="nc" id="L596">            LOGGER.error(&quot;No result from getInstituteAdmin({})&quot;, teamId);</span>
        }
<span class="fc" id="L598">        return adminList;</span>
    }

    public List&lt;Long&gt; getPersonIdsInTeam(long teamId) {
<span class="fc" id="L602">        return instituteUserRepository.getPersonIdsInTeam(teamId);</span>
    }

    public List&lt;PKBPerson&gt; getColleagues(Long clinicianId,
                                         Long teamId,
                                         ContactOptions requireOptionOrNull,
                                         PKBPerson.Lazy... fields) {
<span class="fc" id="L609">        List&lt;Long&gt; colleagueIds = instituteUserRepository.getColleagueIds(clinicianId, teamId, requireOptionOrNull);</span>

<span class="fc" id="L611">        return personRepository.findPkbPersonListOrderedByLastNameAndFirstNameAndIdDesc(</span>
                colleagueIds,
                fields);
    }

    public boolean isTeamUser(long userId) {
<span class="fc" id="L617">        return instituteUserRepository.isTeamUser(userId);</span>
    }

    public boolean isAffilatedUser(long userId) {
<span class="fc" id="L621">        return instituteUserRepository.isAffilatedUser(userId);</span>
    }

    public boolean isActiveTeamUser(long userId) {
<span class="fc" id="L625">        return instituteUserRepository.isActiveTeamUser(userId);</span>
    }

    public boolean isUserRegistered(long userId) {
<span class="fc" id="L629">        boolean atLeastOneActiveInstituteUserExistsForUserId =</span>
<span class="fc" id="L630">                instituteUserRepository.atLeastOneActiveInstituteUserExistsForUserId(userId);</span>

<span class="fc" id="L632">        List&lt;PKBPerson&gt; pkbPersonListWithUserStatus = personRepository.findPKBPersonListByUserStatus(singletonList(userId), singletonList(UserStatus.EMAIL_CONFIRMED));</span>

<span class="fc bfc" id="L634" title="All 4 branches covered.">        return !pkbPersonListWithUserStatus.isEmpty() &amp;&amp; atLeastOneActiveInstituteUserExistsForUserId;</span>
    }


    public void activateUserAccount(long userId, Long teamId, IdentityVerification verification) {
        // Save the verification information
<span class="fc" id="L640">        identityVerificationRepository.saveAndFlush(verification);</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (teamId != null) {</span>
<span class="fc" id="L642">            updateStatus(teamId, userId, SponsorshipStatus.ACTIVE);</span>
        }
<span class="fc" id="L644">    }</span>

    public Long createInstituteUser(long userId, Long teamId, SponsorshipStatus sponsorshipStatus) {
<span class="fc" id="L647">        PKBPerson person = beanFactory.getPKBPersonBean().getPKBPerson(userId);</span>
<span class="fc" id="L648">        InstituteUserEntity instituteUser = new InstituteUserEntity();</span>
<span class="fc" id="L649">        Team team = teamRepository.getInstitute(teamId);</span>
        // abort if the teamId isn't valid
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (team == null) {</span>
<span class="nc" id="L652">            throw new NullPointerException(&quot;invalid teamId: &quot; + teamId);</span>
        }
<span class="fc" id="L654">        instituteUser.setInstitute(team);</span>
<span class="fc" id="L655">        instituteUser.setPersonId(person.getId());</span>
<span class="fc" id="L656">        instituteUser.setUserType(person.getUserType());</span>
<span class="fc" id="L657">        instituteUser.setSponsorshipStatus(sponsorshipStatus);</span>
<span class="fc" id="L658">        instituteUser.setStatusUpdatedOn(dateTimeService.now());</span>
<span class="fc" id="L659">        instituteUserRepository.saveAndFlush(instituteUser);</span>
<span class="fc" id="L660">        return instituteUser.getId();</span>
    }

    public List&lt;PKBPerson&gt; getCliniciansWithIndivAccess(long patientId, ContactOptions contactOptions) {
<span class="nc" id="L664">        var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(patientId);</span>

<span class="nc" id="L666">        List&lt;Long&gt; personIdsForPatientIdAndDefaultAccountIdAndContactOptions = instituteUserRepository.findPersonIdsForPatientIdAndDefaultAccountIdAndContactOptions(patientId, defaultAccountId, contactOptions);</span>

<span class="nc" id="L668">        List&lt;PKBPerson&gt; users = personRepository.findPKBPersonListByUserTypeOrderedByFirstAndLastNameAndIdAsc(</span>
<span class="nc" id="L669">                personIdsForPatientIdAndDefaultAccountIdAndContactOptions, singletonList(UserType.REG_CLINICIAN),</span>
                0,0,
                PKBPerson.Lazy.CONTACTS);

<span class="nc" id="L673">        List&lt;Long&gt; userIds = users.stream().map(PKBPerson::getId).collect(toList());</span>
<span class="nc" id="L674">        Map&lt;Long, Instant&gt; accountCreationDateMap = getIdToAccountCreationMap(userIds);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        for (PKBPerson person : users) {</span>
<span class="nc" id="L676">            person.setAccountCreation(Date.from(accountCreationDateMap.get(person.getId())));</span>
<span class="nc" id="L677">        }</span>
<span class="nc" id="L678">        return users;</span>
    }

    public List&lt;PKBPerson&gt; getAssignedPatients(long userId, PKBPerson.Lazy... fields) {

<span class="fc" id="L683">        Set&lt;Long&gt; accountIds = getAccessibleAccountIds(userId);</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (accountIds.isEmpty()) {</span>
<span class="nc" id="L685">            return emptyList();</span>
        }

<span class="fc" id="L688">        Stream&lt;PKBPerson&gt; userList = instituteUserRepository.findPatientsByAccountId(accountIds, fields);</span>

        List&lt;PKBPerson&gt; users;
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if (ASSIGNED_PATIENT_BATCH_SIZE &lt; accountIds.size()) {</span>
<span class="nc" id="L692">            users = Lists.newArrayList(userList.collect(toMap(PKBPerson::getId, identity(), (p1, p2) -&gt; p1, LinkedHashMap::new)).values());</span>
        } else {
<span class="fc" id="L694">            users = userList.collect(toList());</span>
        }

        // Get the last login for each user
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (isNotEmpty(users)) {</span>
<span class="fc" id="L699">            List&lt;Long&gt; userIds = users.stream().map(PKBPerson::getId).collect(toList());</span>
<span class="fc" id="L700">            Map&lt;Long, Instant&gt; accountCreationDateMap = getIdToAccountCreationMap(userIds);</span>
<span class="fc" id="L701">            users.forEach(u -&gt; {</span>
<span class="fc" id="L702">                u.setAccountCreation(Date.from(accountCreationDateMap.get(u.getId())));</span>
                //u.fetchLazies(fields);
<span class="fc" id="L704">            });</span>
        }

<span class="fc" id="L707">        return users;</span>
    }

    private Set&lt;Long&gt; getAccessibleAccountIds(long userId) {
        //This maxes out at ~15K; should batch, but this is small in terms of data size
<span class="fc" id="L712">        var defaultAccountId = beanFactory.getPKBPersonBean().getDefaultAccountId(userId);</span>
<span class="fc" id="L713">        return instituteUserRepository.getAccessibleAccountIds(userId, defaultAccountId);</span>
    }

    public List&lt;InstituteUser&gt; getInstitutePatientsByStatus(Long teamId,
                                                            EnumSet&lt;UserStatus&gt; userStatuses,
                                                            EnumSet&lt;SponsorshipStatus&gt; sponsorshipStatuses,
                                                            int pageSize,
                                                            int offset) {
<span class="fc" id="L721">        return getInstituteUserByStatus(teamId, userStatuses, sponsorshipStatuses, EnumSet.of(UserType.PATIENT), pageSize, offset);</span>
    }

    public List&lt;InstituteUser&gt; getInstituteUserByStatus(Long teamId,
                                                        EnumSet&lt;UserStatus&gt; userStatuses,
                                                        EnumSet&lt;SponsorshipStatus&gt; sponsorshipStatuses,
                                                        EnumSet&lt;UserType&gt; userTypes,
                                                        int pageSize,
                                                        int offset) {
<span class="pc bpc" id="L730" title="3 of 6 branches missed.">        if (isEmpty(userStatuses) || isEmpty(sponsorshipStatuses) || isEmpty(userTypes)) {</span>
<span class="nc" id="L731">            return emptyList();</span>
        }
<span class="fc" id="L733">        List&lt;CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair&gt; institutePersonIds = instituteUserRepository.findInstituteUserIdsByStatus(teamId, sponsorshipStatuses, userTypes);</span>

<span class="fc" id="L735">        List&lt;PKBPerson&gt; pkbPersons = personRepository.findPKBPersonListByUserTypeAndStatusOrderedByLastNameFirstNameAndIdDesc(</span>
<span class="fc" id="L736">                institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getPersonId).collect(Collectors.toSet()),</span>
                userTypes, userStatuses,
                pageSize, offset,
                PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS, PKBPerson.Lazy.CONTACTS);

<span class="fc" id="L741">        return getInstituteUsersWithPersonInfo(pkbPersons, institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getInstituteUserId).collect(toList()));</span>
    }

    public List&lt;InstituteUser&gt; getNonRegInstituteUsersByType(Long teamId, UserType userType, int pageSize, int offset) {
        try {
<span class="fc" id="L746">            List&lt;CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair&gt; institutePersonIds = instituteUserRepository.getNonRegInstituteUsersByType(teamId, userType);</span>
<span class="fc" id="L747">            List&lt;PKBPerson&gt; pkbPersons = personRepository.findPKBPersonListByUserTypeAndStatusNotInOrderedByLastNameAndFirstNameAndId(</span>
<span class="fc" id="L748">                    institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getPersonId).collect(Collectors.toSet()),</span>
<span class="fc" id="L749">                    Collections.singletonList(userType), Arrays.asList(UserStatus.EMAIL_CONFIRMED, UserStatus.DEAD),</span>
                    pageSize, offset,
                    DESC,
                    PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS, PKBPerson.Lazy.CONTACTS);

<span class="fc" id="L754">            return getInstituteUsersWithPersonInfo(pkbPersons, institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getInstituteUserId).collect(toList()));</span>

<span class="nc" id="L756">        } catch (Exception e) {</span>
<span class="nc" id="L757">            throw new RuntimeException(&quot;Error while getting the nonregistered user list for team -&quot; + teamId, e);</span>
        }
    }

    public Map&lt;Long, List&lt;Team&gt;&gt; getUserToTeamMap(List&lt;Long&gt; userIds) {

<span class="fc" id="L763">            Map&lt;Long, List&lt;Team&gt;&gt; userToTeamMap = new HashMap&lt;&gt;();</span>
            // if no users return an empty hashmap
<span class="pc bpc" id="L765" title="2 of 4 branches missed.">            if ((userIds == null) || userIds.isEmpty()) {</span>
<span class="nc" id="L766">                return userToTeamMap;</span>
            }

<span class="fc bfc" id="L769" title="All 2 branches covered.">            for (Long userId : userIds) {</span>
<span class="fc" id="L770">                userToTeamMap.put(userId, new LinkedList&lt;&gt;());</span>
<span class="fc" id="L771">            }</span>

<span class="fc" id="L773">            List&lt;InstituteUserEntity&gt; instituteUsers = instituteUserRepository.findInstituteUsersForUserIds(userIds);</span>
<span class="pc bpc" id="L774" title="2 of 4 branches missed.">            if ((instituteUsers == null) || instituteUsers.isEmpty()) {</span>
<span class="nc" id="L775">                return userToTeamMap;</span>
            }

<span class="fc bfc" id="L778" title="All 2 branches covered.">            for (InstituteUserEntity instituteUser : instituteUsers) {</span>
<span class="fc" id="L779">                instituteUser.getInstitute().getId(); // Touch to fetch lazies</span>
<span class="fc" id="L780">                userToTeamMap.get(instituteUser.getPersonId()).add(instituteUser.getInstitute());</span>
<span class="fc" id="L781">            }</span>
<span class="fc" id="L782">            return userToTeamMap;</span>

    }

    public List&lt;InstituteUser&gt; getInstituteCliniciansByStatus(Long teamId,
                                                              UserStatus userStatus,
                                                              SponsorshipStatus sponsorshipStatus,
                                                              int pageSize,
                                                              int offset) {
        try {
<span class="fc" id="L792">            return getInstituteUserByStatus(teamId, EnumSet.of(userStatus, UserStatus.NOCONTACT), EnumSet.of(sponsorshipStatus), EnumSet.of(UserType.REG_CLINICIAN), pageSize,</span>
                    offset);
<span class="nc" id="L794">        } catch (Exception e) {</span>
<span class="nc" id="L795">            throw new RuntimeException(&quot;Error while getting the clinician list for team -&quot;</span>
<span class="nc" id="L796">                    + teamId + &quot; for user status-&quot; + userStatus.toString()</span>
                    + &quot; and sponsorshipStatus-&quot; + sponsorshipStatus, e);
        }
    }

    public List&lt;InstituteUser&gt; getInstituteCliniciansByEmailAddress(
            Long teamId, Set&lt;Email&gt; emailAddresses) {

<span class="fc" id="L804">            List&lt;PKBPerson&gt; personList = personRepository.findPKBPersonListByUserTypeAndEmail(emailAddresses.stream().map(e -&gt; e.address()).collect(toList()), singletonList(UserType.REG_CLINICIAN));</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">            if (personList.isEmpty()) {</span>
<span class="fc" id="L806">                return new ArrayList&lt;&gt;();</span>
            }

<span class="fc" id="L809">            Map&lt;Long, PKBPerson&gt; personMap = personList.stream().collect(toMap(PKBPerson::getId, Function.identity()));</span>

<span class="fc" id="L811">            List&lt;InstituteUserEntity&gt; activeInstituteUsersByTeamAndPersonIds = instituteUserRepository.findActiveInstituteUsersByTeamAndPersonIds(teamId, personMap.keySet());</span>

<span class="fc" id="L813">            return activeInstituteUsersByTeamAndPersonIds.stream().map(entity -&gt; transform(entity, personMap.get(entity.getPersonId()))).collect(Collectors.toList());</span>
    }

    public List&lt;InstituteUser&gt; getInactiveTeamClinicians(Long teamId, int pageSize, int offset) {

<span class="fc" id="L818">        List&lt;CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair&gt; institutePersonIds = instituteUserRepository.getInactiveTeamClinicianIds(teamId);</span>

<span class="fc" id="L820">        List&lt;PKBPerson&gt; pkbPersons = personRepository.findPKBPersonListOrderedByFirstAndLastNameAndIdAscending(</span>
<span class="fc" id="L821">                institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getPersonId).collect(Collectors.toSet()),</span>
                pageSize,
                offset,
                PKBPerson.Lazy.NATIONAL_AND_LOCAL_IDS, PKBPerson.Lazy.CONTACTS);

<span class="fc" id="L826">        return getInstituteUsersWithPersonInfo(pkbPersons, institutePersonIds.stream().map(CustomizedLegacyInstituteUserRepositoryImpl.InstituteUserIdPersonIdPair::getInstituteUserId).collect(toList()));</span>
    }

    public List&lt;PKBPerson&gt; getOrgPatientsByLastnameAndDob(@NotNull Org org, @NotNull String lastName, @NotNull String dob) {
        try {
<span class="fc" id="L831">            List&lt;PKBPerson&gt; patientListSharingLastNameAndDob = personRepository.findPatientListByLastNameAndDob(lastName, dob);</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">            if (patientListSharingLastNameAndDob.isEmpty()) {</span>
<span class="fc" id="L833">                return List.of();</span>
            }

<span class="nc" id="L836">            List&lt;Long&gt; patientListSharingLastNameAndDobAtOrg = instituteUserRepository.getPatientListSharingLastNameAndDobAtOrg(</span>
<span class="nc" id="L837">                    org, patientListSharingLastNameAndDob.stream().map(PKBPerson::getId).collect(Collectors.toList()));</span>
<span class="nc" id="L838">            return patientListSharingLastNameAndDob.stream()</span>
<span class="nc" id="L839">                    .filter(person -&gt; patientListSharingLastNameAndDobAtOrg.contains(person.getId()))</span>
<span class="nc" id="L840">                    .collect(Collectors.toList());</span>
<span class="nc" id="L841">        } catch (Exception e) {</span>
<span class="nc" id="L842">            String msg = &quot;Error while getting patients for org-&quot; + org.getId() + &quot; lastName-&quot;</span>
                    + lastName + &quot; dob-&quot; + dob;
<span class="nc" id="L844">            throw new RuntimeException(msg, e);</span>
        }
    }

    public List&lt;TeamWithPKBPerson&gt; getAllActiveTeamsForClinicianWithHumanUUID(String humanUUID) {
        try {
<span class="fc" id="L850">            Map&lt;Long, PKBPerson&gt; personMap = beanFactory.getPKBPersonBean().getPKBPersonListByHumanUUID(humanUUID, PKBPerson.Lazy.CONTACTS)</span>
<span class="fc" id="L851">                    .stream().collect(toMap(PKBPerson::getId, identity()));</span>

<span class="fc" id="L853">            return instituteUserRepository.findActiveInstituteUsersForPersonIds(personMap.keySet()).stream()</span>
<span class="fc" id="L854">                    .map(entity -&gt; new TeamWithPKBPerson(entity.getInstitute(), transform(entity, personMap.get(entity.getPersonId())), personMap.get(entity.getPersonId())))</span>
<span class="fc" id="L855">                    .collect(Collectors.toList());</span>

<span class="nc" id="L857">        } catch (Exception e) {</span>
<span class="nc" id="L858">            throw new RuntimeException(&quot;Error while getting all teams/users for humanUUID - &quot; + humanUUID, e);</span>
        }
    }

    @Nullable
    public PKBPerson getSpecificPersonaForTeam(String humanUUID, long teamId) {
        try {
<span class="fc" id="L865">            Map&lt;Long, PKBPerson&gt; personMap = beanFactory.getPKBPersonBean().getPKBPersonListByHumanUUID(humanUUID, PKBPerson.Lazy.CONTACTS)</span>
<span class="fc" id="L866">                    .stream().collect(toMap(PKBPerson::getId, identity()));</span>

<span class="fc" id="L868">            PKBPerson result = null;</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">            if (personMap.isEmpty()) {</span>
<span class="nc" id="L870">                LOGGER.warn(&quot;No person found by humanUUID {}&quot;, humanUUID);</span>
            } else {
<span class="fc" id="L872">                List&lt;Long&gt; personIds = instituteUserRepository.findPersonIdsForPersonIdsAndTeamId(personMap.keySet(), teamId);</span>

<span class="pc bpc" id="L874" title="1 of 2 branches missed.">                if (personIds.isEmpty()) {</span>
<span class="nc" id="L875">                    LOGGER.warn(&quot;No person with humanUUID {} found in institute-{}&quot;, humanUUID, teamId);</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">                } else if (personIds.size() &gt; 1) {</span>
<span class="nc" id="L877">                    LOGGER.warn(&quot;Multiple persons {} found in institute-{} by humanUUID {}&quot;, personIds, teamId, humanUUID);</span>
                } else {
<span class="fc" id="L879">                    result = personMap.get(personIds.get(0));</span>
                }
            }
<span class="fc" id="L882">            return result;</span>
<span class="nc" id="L883">        } catch (Exception e) {</span>
<span class="nc" id="L884">            throw new RuntimeException(&quot;Error while getting all teams for humanUUID - &quot; + humanUUID, e);</span>
        }
    }

    /**
     * 2018-08-16 RobW: temporary hack; delete once we can call into the new service layer from pkb-service
     */
    public Map&lt;Integer, Integer&gt; findObsoleteToPrimaryIdMap(long orgId) {
        try {
            //public.emis_es_merged_org_level_id (org_id, merged_value, primary_value, added_date) (select o.id, 300500126, 220001393, current_timestamp from org where code = '');
<span class="fc" id="L894">            List&lt;Object[]&gt; obsoleteToPrimaryIdMap = instituteUserRepository.findObsoleteToPrimaryIdMap(orgId);</span>
<span class="fc" id="L895">            return obsoleteToPrimaryIdMap.stream().collect(toMap(r -&gt; ((Number) r[0]).intValue(), r -&gt; ((Number) r[1]).intValue()));</span>
<span class="nc" id="L896">        } catch (Exception e) {</span>
<span class="nc" id="L897">            throw new RuntimeException(</span>
                    &quot;Failed getting merged id map for org &quot; + orgId, e);
        }
    }

    public List&lt;Long&gt; getPersonIdsForTeam(long teamId, boolean registeredOnly) {
<span class="fc bfc" id="L903" title="All 2 branches covered.">        return registeredOnly</span>
<span class="fc" id="L904">                ? instituteUserRepository.getVerifiedPersonIdsInTeam(teamId, EnumSet.of(UserStatus.ACTIVE, UserStatus.EMAIL_CONFIRMED))</span>
<span class="fc" id="L905">                : instituteUserRepository.getVerifiedPersonIdsInTeam(teamId);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>